# Cursor Rules for Braille Card and Cylinder STL Generator

## Core Architecture Principles

### Settings Schema and Specification-Driven Development

This project uses a **centralized settings architecture** with specification-driven development. Before making any changes to settings, defaults, UI controls, or core features:

1. **ALWAYS consult the master index first:**
   - `SPECIFICATIONS_INDEX.md` — Master index for all specifications
   - `SETTINGS_SCHEMA_CORE_SPECIFICATIONS.md` — Unified settings schema reference
   - `settings.schema.json` — JSON Schema for validation

2. **Follow the Source Priority Order (for each domain):**
   - Settings/Validation: `settings.schema.json` > `app/models.py` > `backend.py`
   - Translation: `backend.py` > `static/liblouis-worker.js`
   - Geometry: `geometry_spec.py` > `app/geometry/*.py`
   - Caching: `app/cache.py` > `backend.py`

3. **When modifying defaults or adding parameters:**
   - Update `settings.schema.json` first (single source of truth)
   - Update `app/models.py` CardSettings defaults
   - Update relevant specification document(s)
   - Update `SPECIFICATIONS_INDEX.md` if adding new systems

4. **Cross-Validation Checklist:**
   - [ ] Schema validates new parameter structure
   - [ ] Defaults are consistent across schema, models, and UI
   - [ ] Related specification documents updated
   - [ ] Cache key normalization handles new fields (if geometry-affecting)
   - [ ] UI elements reflect schema constraints

5. **Key Constants (must remain consistent across 9+ modules):**
   - Unicode Braille Range: `0x2800` to `0x28FF`
   - Dot Position Mapping: `[[0,0], [1,0], [2,0], [0,1], [1,1], [2,1]]`
   - Shape Types: `card`, `cylinder`
   - Plate Types: `positive`, `negative`
   - Placement Modes: `auto`, `manual`

### Specification Documents Reference

| Domain | Primary Specification |
|--------|----------------------|
| Settings/Defaults | `SETTINGS_SCHEMA_CORE_SPECIFICATIONS.md` |
| UI/Accessibility | `UI_INTERFACE_CORE_SPECIFICATIONS.md` |
| Text Input | `BRAILLE_TEXT_INPUT_AND_LANGUAGE_SPECIFICATIONS.md` |
| Translation | `LIBLOUIS_TRANSLATION_CORE_SPECIFICATIONS.md` |
| Geometry | `SURFACE_DIMENSIONS_SPECIFICATIONS.md` |
| Dot Shapes | `BRAILLE_DOT_ADJUSTMENTS_SPECIFICATIONS.md` |
| Indicators | `RECESS_INDICATOR_SPECIFICATIONS.md` |
| Export | `STL_EXPORT_AND_DOWNLOAD_SPECIFICATIONS.md` |
| Caching | `CACHING_SYSTEM_CORE_SPECIFICATIONS.md` |

---

## Git Commit and Push Workflow

When the user asks to commit and/or push code to GitHub (including phrases like "prepare a commit", "prepare a commit and push", "commit and push", "push to github", etc.):

**Preferred approach: Prepare commands for manual execution** - This method has proven reliable (successful commit 2024-12-06). While Cursor's direct git execution may have inconsistent output display, preparing commands for manual terminal execution ensures the user has full visibility and control.

1. **Prepare the commands for manual execution:**
   - Check git status to identify modified, staged, and untracked files
   - Review the changes using git diff
   - Check recent commit history to follow the repository's commit message style
   - Draft an appropriate commit message that:
     - Summarizes the nature of changes (feature, enhancement, bug fix, refactoring, docs, etc.)
     - Is concise (1-2 sentences for simple changes, or multi-line for complex changes)
     - Follows the repository's existing commit message conventions
   - Identify the current branch and remote tracking branch

2. **Provide ready-to-use PowerShell commands:**
   ```powershell
   cd "c:\Users\WATAP\Documents\github\braille-card-and-cylinder-stl-generator"

   git add -A

   git commit -m "Commit message here"

   git push origin [branch-name]
   ```

3. **Include clear instructions:**
   - Explain what each command does
   - Tell the user to copy and paste the commands into their terminal
   - Mention that they can modify the commit message if needed before executing

**Note:** As of 2024-12-06, manual execution of prepared git commands has been verified to work successfully on the first attempt when pre-commit hooks don't require file modifications.

## Pre-Commit Hook Failure Workaround

This repository uses pre-commit hooks that automatically fix files (trailing whitespace, end-of-file newlines, ruff formatting). **When the hooks fix files, the commit will fail** because the modified files are no longer staged.

**Symptom:**
```
[WARNING] Unstaged files detected.
trim trailing whitespace.................................................Failed
- files were modified by this hook
fix end of files.........................................................Failed
- files were modified by this hook
ruff format..............................................................Failed
- files were modified by this hook
```

**Solution - Re-stage and commit again:**
```powershell
# After a failed commit due to pre-commit hooks fixing files:
git add -A
git commit -m "Your commit message"

# The second attempt should succeed because the hooks already fixed the files
```

**Always include this note when providing commit commands:**
> If the commit fails with "files were modified by this hook", run `git add -A` and `git commit -m "..."` again. The second attempt will succeed.

## Additional Git Guidelines

- Always check for sensitive information before preparing commits
- Ensure commit messages are descriptive and follow conventional commit style when appropriate
- For large changesets, consider breaking into multiple logical commits
- Always verify the correct branch before pushing
- Always use `git add -A` to stage all changes (including files fixed by pre-commit hooks)
