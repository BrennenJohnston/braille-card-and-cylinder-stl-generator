import{BufferAttribute as t,Vector3 as e,Plane as n,Line3 as r,Vector2 as o,Triangle as i,Sphere as s,Matrix4 as a,Box3 as c,BackSide as l,DoubleSide as u,REVISION as d,FrontSide as f,Ray as p,Vector4 as h,Mesh as g,Matrix3 as y}from"./three-zd0udLjK.js";const m=1.25,x=65535,w=Math.pow(2,-24),b=Symbol("SKIP_GENERATION");function A(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function B(e,n){if(!e.index){const r=e.attributes.position.count,o=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(r,n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);e.setIndex(new t(o,1));for(let t=0;t<r;t++)o[t]=t}}function T(t,e){const n=A(t),r=e||t.drawRange,o=r.start/3,i=(r.start+r.count)/3,s=Math.max(0,o),a=Math.min(n,i)-s;return[{offset:Math.floor(s),count:Math.floor(a)}]}function M(t,e){if(!t.groups||!t.groups.length)return T(t,e);const n=[],r=new Set,o=e||t.drawRange,i=o.start/3,s=(o.start+o.count)/3;for(const c of t.groups){const t=c.start/3,e=(c.start+c.count)/3;r.add(Math.max(i,t)),r.add(Math.min(s,e))}const a=Array.from(r.values()).sort((t,e)=>t-e);for(let c=0;c<a.length-1;c++){const t=a[c],e=a[c+1];n.push({offset:Math.floor(t),count:Math.floor(e-t)})}return n}function S(t,e,n,r,o){let i=1/0,s=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,d=1/0,f=1/0,p=1/0,h=-1/0,g=-1/0,y=-1/0;for(let m=6*e,x=6*(e+n);m<x;m+=6){const e=t[m+0],n=t[m+1],r=e-n,o=e+n;r<i&&(i=r),o>c&&(c=o),e<d&&(d=e),e>h&&(h=e);const x=t[m+2],w=t[m+3],b=x-w,A=x+w;b<s&&(s=b),A>l&&(l=A),x<f&&(f=x),x>g&&(g=x);const B=t[m+4],T=t[m+5],M=B-T,S=B+T;M<a&&(a=M),S>u&&(u=S),B<p&&(p=B),B>y&&(y=B)}r[0]=i,r[1]=s,r[2]=a,r[3]=c,r[4]=l,r[5]=u,o[0]=d,o[1]=f,o[2]=p,o[3]=h,o[4]=g,o[5]=y}function P(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function v(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function I(t,e){e.set(t)}function z(t,e,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=t[i],o=e[i],n[i]=r<o?r:o,r=t[s],o=e[s],n[s]=r>o?r:o}}function U(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],i=e[t+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function _(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const E=32,F=(t,e)=>t.candidate-e.candidate,C=new Array(E).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),G=new Float32Array(6);class V{constructor(){this.boundingData=new Float32Array(6)}}function X(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}function N(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;{let e=t[s];t[s]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}}function k(t,e){return 65535===e[t+15]}function q(t,e){return e[t+6]}function R(t,e){return e[t+14]}function D(t){return t+8}function j(t,e){return e[t+6]}function O(t,e){return e[t+7]}function $(t){return t}let L,W,Y,Z;const H=Math.pow(2,32);function K(t){return"count"in t?1:1+K(t.left)+K(t.right)}function J(t,e,n){return L=new Float32Array(n),W=new Uint32Array(n),Y=new Uint16Array(n),Z=new Uint8Array(n),Q(t,e)}function Q(t,e){const n=t/4,r=t/2,o="count"in e,i=e.boundingData;for(let s=0;s<6;s++)L[n+s]=i[s];if(o){if(e.buffer){const r=e.buffer;Z.set(new Uint8Array(r),t);for(let e=t,o=t+r.byteLength;e<o;e+=32){k(e/2,Y)||(W[e/4+6]+=n)}return t+r.byteLength}{const o=e.offset,i=e.count;return W[n+6]=o,Y[r+14]=i,Y[r+15]=x,t+32}}{const r=e.left,o=e.right,i=e.splitAxis;let s;if(s=Q(t+32,r),s/4>H)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return W[n+6]=s/4,s=Q(s,o),W[n+7]=i,s}}function tt(t,e,n,r,o){const{maxDepth:i,verbose:s,maxLeafTris:a,strategy:c,onProgress:l,indirect:u}=o,d=t._indirectBuffer,f=t.geometry,p=f.index?f.index.array:null,h=u?N:X,g=A(f),y=new Float32Array(6);let x=!1;const w=new V;return S(e,n,r,w.boundingData,y),function t(n,r,o,s=null,l=0){!x&&l>=i&&(x=!0);if(o<=a||l>=i)return b(r+o),n.offset=r,n.count=o,n;const u=function(t,e,n,r,o,i){let s=-1,a=0;if(0===i)s=v(e),-1!==s&&(a=(e[s]+e[s+3])/2);else if(1===i)s=v(t),-1!==s&&(a=function(t,e,n,r){let o=0;for(let i=e,s=e+n;i<s;i++)o+=t[6*i+2*r];return o/n}(n,r,o,s));else if(2===i){const i=_(t);let c=m*o;const l=6*r,u=6*(r+o);for(let t=0;t<3;t++){const r=e[t],d=(e[t+3]-r)/E;if(o<8){const e=[...C];e.length=o;let r=0;for(let o=l;o<u;o+=6,r++){const i=e[r];i.candidate=n[o+2*t],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=i;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;U(o,n,s)}e.sort(F);let d=o;for(let t=0;t<d;t++){const n=e[t];for(;t+1<d&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),d--}for(let o=l;o<u;o+=6){const r=n[o+2*t];for(let t=0;t<d;t++){const i=e[t];r>=i.candidate?U(o,n,i.rightCacheBounds):(U(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<d;n++){const r=e[n],l=r.count,u=o-r.count,d=r.leftCacheBounds,f=r.rightCacheBounds;let p=0;0!==l&&(p=_(d)/i);let h=0;0!==u&&(h=_(f)/i);const g=1+m*(p*l+h*u);g<c&&(s=t,c=g,a=r.candidate)}}else{for(let t=0;t<E;t++){const e=C[t];e.count=0,e.candidate=r+d+t*d;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let o=l;o<u;o+=6){let e=~~((n[o+2*t]-r)/d);e>=E&&(e=31);const i=C[e];i.count++,U(o,n,i.bounds)}const e=C[31];I(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=C[t],n=C[t+1];z(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let f=0;for(let n=0;n<31;n++){const e=C[n],r=e.count,l=e.bounds,u=C[n+1].rightCacheBounds;0!==r&&(0===f?I(l,G):z(l,G,G)),f+=r;let d=0,p=0;0!==f&&(d=_(G)/i);const h=o-f;0!==h&&(p=_(u)/i);const g=1+m*(d*f+p*h);g<c&&(s=t,c=g,a=e.candidate)}}}}return{axis:s,pos:a}}(n.boundingData,s,e,r,o,c);if(-1===u.axis)return b(r+o),n.offset=r,n.count=o,n;const f=h(d,p,e,r,o,u);if(f===r||f===r+o)b(r+o),n.offset=r,n.count=o;else{n.splitAxis=u.axis;const i=new V,s=r,a=f-r;n.left=i,S(e,s,a,i.boundingData,y),t(i,s,a,y,l+1);const c=new V,d=f,p=o-a;n.right=c,S(e,d,p,c.boundingData,y),t(c,d,p,y,l+1)}return n}(w,n,r,y),w;function b(t){l&&l(t/g)}}function et(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,i=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),s=r?new Uint32Array(i):new Uint16Array(i);for(let a=0,c=s.length;a<c;a++)s[a]=a;return s}(n,e.useSharedArrayBuffer),function(t,e){const n=A(t),r=M(t,e).sort((t,e)=>t.offset-e.offset),o=r[r.length-1];o.count=Math.min(n-o.offset,o.count);let i=0;return r.forEach(({count:t})=>i+=t),n!==i}(n,e.range)&&e.verbose),t._indirectBuffer||B(n,e);const r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=function(t,e=null,n=null,r=null){const o=t.attributes.position,i=t.index?t.index.array:null,s=A(t),a=o.normalized;let c;null===e?(c=new Float32Array(6*s),n=0,r=s):(c=e,n=n||0,r=r||s);const l=o.array,u=o.offset||0;let d=3;o.isInterleavedBufferAttribute&&(d=o.data.stride);const f=["getX","getY","getZ"];for(let p=n;p<n+r;p++){const t=3*p,e=6*p;let n=t+0,r=t+1,s=t+2;i&&(n=i[n],r=i[r],s=i[s]),a||(n=n*d+u,r=r*d+u,s=s*d+u);for(let i=0;i<3;i++){let t,u,d;a?(t=o[f[i]](n),u=o[f[i]](r),d=o[f[i]](s)):(t=l[n+i],u=l[r+i],d=l[s+i]);let p=t;u<p&&(p=u),d<p&&(p=d);let h=t;u>h&&(h=u),d>h&&(h=d);const g=(h-p)/2,y=2*i;c[e+y+0]=p+g,c[e+y+1]=g+(Math.abs(p)+g)*w}}return c}(n),i=e.indirect?T(n,e.range):M(n,e.range);t._roots=i.map(n=>{const i=tt(t,o,n.offset,n.count,e),s=K(i),a=new r(32*s);return J(0,i,a),a})}class nt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o][e];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o],s=t.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}nt.prototype.setFromBox=function(){const t=new e;return function(e,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=r.x*a+o.x*(1-a),t.y=r.y*n+o.y*(1-n),t.z=r.z*c+o.z*(1-c);const l=e.dot(t);i=Math.min(l,i),s=Math.max(l,s)}this.min=i,this.max=s}}();const rt=function(){const t=new e,n=new e,r=new e;return function(e,o,i){const s=e.start,a=t,c=o.start,l=n;r.subVectors(s,c),t.subVectors(e.end,e.start),n.subVectors(o.end,o.start);const u=r.dot(l),d=l.dot(a),f=l.dot(l),p=r.dot(a),h=a.dot(a)*f-d*d;let g,y;g=0!==h?(u*d-p*f)/h:0,y=(u+g*d)/f,i.x=g,i.y=y}}(),ot=function(){const t=new o,n=new e,r=new e;return function(e,o,i,s){rt(e,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return e.at(a,i),void o.at(c,s);if(a>=0&&a<=1)return c<0?o.at(0,s):o.at(1,s),void e.closestPointToPoint(s,!0,i);if(c>=0&&c<=1)return a<0?e.at(0,i):e.at(1,i),void o.closestPointToPoint(i,!0,s);{let t,l;t=a<0?e.start:e.end,l=c<0?o.start:o.end;const u=n,d=r;return e.closestPointToPoint(l,!0,n),o.closestPointToPoint(t,!0,r),u.distanceToSquared(l)<=d.distanceToSquared(t)?(i.copy(u),void s.copy(l)):(i.copy(t),void s.copy(d))}}}(),it=function(){const t=new e,o=new e,i=new n,s=new r;return function(e,n){const{radius:r,center:a}=e,{a:c,b:l,c:u}=n;s.start=c,s.end=l;if(s.closestPointToPoint(a,!0,t).distanceTo(a)<=r)return!0;s.start=c,s.end=u;if(s.closestPointToPoint(a,!0,t).distanceTo(a)<=r)return!0;s.start=l,s.end=u;if(s.closestPointToPoint(a,!0,t).distanceTo(a)<=r)return!0;const d=n.getPlane(i);if(Math.abs(d.distanceToPoint(a))<=r){const t=d.projectPoint(a,o);if(n.containsPoint(t))return!0}return!1}}();function st(t){return Math.abs(t)<1e-15}class at extends i{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new e),this.satBounds=new Array(4).fill().map(()=>new nt),this.points=[this.a,this.b,this.c],this.sphere=new s,this.plane=new n,this.needsUpdate=!0}intersectsSphere(t){return it(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const c=o[1],l=i[1];c.subVectors(t,e),l.setFromPoints(c,r);const u=o[2],d=i[2];u.subVectors(e,n),d.setFromPoints(u,r);const f=o[3],p=i[3];f.subVectors(n,t),p.setFromPoints(f,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}at.prototype.closestPointToSegment=function(){const t=new e,n=new e,o=new r;return function(e,r=null,i=null){const{start:s,end:a}=e,c=this.points;let l,u=1/0;for(let d=0;d<3;d++){const s=(d+1)%3;o.start.copy(c[d]),o.end.copy(c[s]),ot(o,e,t,n),l=t.distanceToSquared(n),l<u&&(u=l,r&&r.copy(t),i&&i.copy(n))}return this.closestPointToPoint(s,t),l=s.distanceToSquared(t),l<u&&(u=l,r&&r.copy(t),i&&i.copy(s)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<u&&(u=l,r&&r.copy(t),i&&i.copy(a)),Math.sqrt(u)}}(),at.prototype.intersectsTriangle=function(){const t=new at,n=new Array(3),o=new Array(3),i=new nt,s=new nt,a=new e,c=new e,l=new e,u=new e,d=new e,f=new r,p=new r,h=new r,g=new e;function y(t,e,n){const r=t.points;let o=0,i=-1;for(let s=0;s<3;s++){const{start:t,end:a}=f;t.copy(r[s]),a.copy(r[(s+1)%3]),f.delta(c);const l=st(e.distanceToPoint(t));if(st(e.normal.dot(c))&&l){n.copy(f),o=2;break}const u=e.intersectLine(f,g);if(!u&&l&&g.copy(t),(u||l)&&!st(g.distanceTo(a))){if(o<=1){(1===o?n.start:n.end).copy(g),l&&(i=o)}else if(o>=2){(1===i?n.start:n.end).copy(g),o=2;break}if(o++,2===o&&-1===i)break}}return o}return function(e,r=null,c=!1){this.needsUpdate&&this.update(),e.isExtendedTriangle?e.needsUpdate&&e.update():(t.copy(e),t.update(),e=t);const f=this.plane,g=e.plane;if(Math.abs(f.normal.dot(g.normal))>1-1e-10){const t=this.satBounds,c=this.satAxes;o[0]=e.a,o[1]=e.b,o[2]=e.c;for(let e=0;e<4;e++){const n=t[e],r=c[e];if(i.setFromPoints(r,o),n.isSeparated(i))return!1}const l=e.satBounds,u=e.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let e=0;e<4;e++){const t=l[e],r=u[e];if(i.setFromPoints(r,n),t.isSeparated(i))return!1}for(let e=0;e<4;e++){const t=c[e];for(let e=0;e<4;e++){const r=u[e];if(a.crossVectors(t,r),i.setFromPoints(a,n),s.setFromPoints(a,o),i.isSeparated(s))return!1}}return r&&(r.start.set(0,0,0),r.end.set(0,0,0)),!0}{const t=y(this,g,p);if(1===t&&e.containsPoint(p.end))return r&&(r.start.copy(p.end),r.end.copy(p.end)),!0;if(2!==t)return!1;const n=y(e,f,h);if(1===n&&this.containsPoint(h.end))return r&&(r.start.copy(h.end),r.end.copy(h.end)),!0;if(2!==n)return!1;if(p.delta(l),h.delta(u),l.dot(u)<0){let t=h.start;h.start=h.end,h.end=t}const o=p.start.dot(l),i=p.end.dot(l),s=h.start.dot(l),a=h.end.dot(l);return(o===a||s===i||i<s!==o<a)&&(r&&(d.subVectors(p.start,h.start),d.dot(l)>0?r.start.copy(p.start):r.start.copy(h.start),d.subVectors(p.end,h.end),d.dot(l)<0?r.end.copy(p.end):r.end.copy(h.end)),!0)}}}(),at.prototype.distanceToPoint=function(){const t=new e;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),at.prototype.distanceToTriangle=function(){const t=new e,n=new e,o=["a","b","c"],i=new r,s=new r;return function(e,r=null,a=null){const c=r||a?i:null;if(this.intersectsTriangle(e,c))return(r||a)&&(r&&c.getCenter(r),a&&c.getCenter(a)),0;let l=1/0;for(let n=0;n<3;n++){let i;const s=o[n],c=e[s];this.closestPointToPoint(c,t),i=c.distanceToSquared(t),i<l&&(l=i,r&&r.copy(t),a&&a.copy(c));const u=this[s];e.closestPointToPoint(u,t),i=u.distanceToSquared(t),i<l&&(l=i,r&&r.copy(u),a&&a.copy(t))}for(let u=0;u<3;u++){const c=o[u],d=o[(u+1)%3];i.set(this[c],this[d]);for(let u=0;u<3;u++){const c=o[u],d=o[(u+1)%3];s.set(e[c],e[d]),ot(i,s,t,n);const f=t.distanceToSquared(n);f<l&&(l=f,r&&r.copy(t),a&&a.copy(n))}}return Math.sqrt(l)}}();class ct{constructor(t,n,r){this.isOrientedBox=!0,this.min=new e,this.max=new e,this.matrix=new a,this.invMatrix=new a,this.points=new Array(8).fill().map(()=>new e),this.satAxes=new Array(3).fill().map(()=>new e),this.satBounds=new Array(3).fill().map(()=>new nt),this.alignedSatBounds=new Array(3).fill().map(()=>new nt),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),r&&this.matrix.copy(r)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}ct.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let c=0;c<=1;c++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=r[1*c|2*o|4*i];s.x=c?n.x:e.x,s.y=o?n.y:e.y,s.z=i?n.z:e.z,s.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let c=0;c<3;c++){const t=i[c],e=o[c],n=r[1<<c];t.subVectors(s,n),e.setFromPoints(t,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},ct.prototype.intersectsBox=function(){const t=new nt;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=i[a],r=o[a];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),ct.prototype.intersectsTriangle=function(){const t=new at,n=new Array(3),r=new nt,o=new nt,i=new e;return function(e){this.needsUpdate&&this.update(),e.isExtendedTriangle?e.needsUpdate&&e.update():(t.copy(e),t.update(),e=t);const s=this.satBounds,a=this.satAxes;n[0]=e.a,n[1]=e.b,n[2]=e.c;for(let t=0;t<3;t++){const e=s[t],o=a[t];if(r.setFromPoints(o,n),e.isSeparated(r))return!1}const c=e.satBounds,l=e.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],n=l[t];if(r.setFromPoints(n,u),e.isSeparated(r))return!1}for(let t=0;t<3;t++){const e=a[t];for(let t=0;t<4;t++){const s=l[t];if(i.crossVectors(e,s),r.setFromPoints(i,n),o.setFromPoints(i,u),r.isSeparated(o))return!1}}return!0}}(),ct.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},ct.prototype.distanceToPoint=function(){const t=new e;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),ct.prototype.distanceToBox=function(){const t=["x","y","z"],n=new Array(12).fill().map(()=>new r),o=new Array(12).fill().map(()=>new r),i=new e,s=new e;return function(e,r=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(e))return(a||c)&&(e.getCenter(s),this.closestPointToPoint(s,i),e.closestPointToPoint(i,s),a&&a.copy(i),c&&c.copy(s)),0;const l=r*r,u=e.min,d=e.max,f=this.points;let p=1/0;for(let t=0;t<8;t++){const e=f[t];s.copy(e).clamp(u,d);const n=e.distanceToSquared(s);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(s),n<l))return Math.sqrt(n)}let h=0;for(let i=0;i<3;i++)for(let e=0;e<=1;e++)for(let r=0;r<=1;r++){const s=(i+1)%3,a=(i+2)%3,c=1<<i|e<<s|r<<a,l=f[e<<s|r<<a],p=f[c];n[h].set(l,p);const g=t[i],y=t[s],m=t[a],x=o[h],w=x.start,b=x.end;w[g]=u[g],w[y]=e?u[y]:d[y],w[m]=r?u[m]:d[y],b[g]=d[g],b[y]=e?u[y]:d[y],b[m]=r?u[m]:d[y],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){s.x=t?d.x:u.x,s.y=e?d.y:u.y,s.z=n?d.z:u.z,this.closestPointToPoint(s,i);const r=s.distanceToSquared(i);if(r<p&&(p=r,a&&a.copy(i),c&&c.copy(s),r<l))return Math.sqrt(r)}for(let t=0;t<12;t++){const e=n[t];for(let t=0;t<12;t++){const n=o[t];ot(e,n,i,s);const r=i.distanceToSquared(s);if(r<p&&(p=r,a&&a.copy(i),c&&c.copy(s),r<l))return Math.sqrt(r)}}return Math.sqrt(p)}}();class lt{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ut extends lt{constructor(){super(()=>new at)}}const dt=new ut;const ft=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let pt,ht;const gt=[],yt=new lt(()=>new c);function mt(t,e,n,r,o,i){pt=yt.getPrimitive(),ht=yt.getPrimitive(),gt.push(pt,ht),ft.setBuffer(t._roots[e]);const s=xt(0,t.geometry,n,r,o,i);ft.clearBuffer(),yt.releasePrimitive(pt),yt.releasePrimitive(ht),gt.pop(),gt.pop();const a=gt.length;return a>0&&(ht=gt[a-1],pt=gt[a-2]),s}function xt(t,e,n,r,o=null,i=0,s=0){const{float32Array:a,uint16Array:c,uint32Array:l}=ft;let u=2*t;if(k(u,c)){const d=q(t,l),f=R(u,c);return P(t,a,pt),r(d,f,!1,s,i+t,pt)}{const p=D(t),h=j(t,l);let g,y,m,x,w=p,b=h;if(o&&(m=pt,x=ht,P(w,a,m),P(b,a,x),g=o(m),y=o(x),y<g)){w=h,b=p;const I=g;g=y,y=I,m=x}m||(m=pt,P(w,a,m));const A=n(m,k(2*w,c),g,s+1,i+w);let B;if(2===A){const z=S(w);B=r(z,v(w)-z,!0,s+1,i+w,m)}else B=A&&xt(w,e,n,r,o,i,s+1);if(B)return!0;x=ht,P(b,a,x);const T=n(x,k(2*b,c),y,s+1,i+b);let M;if(2===T){const U=S(b);M=r(U,v(b)-U,!0,s+1,i+b,x)}else M=T&&xt(b,e,n,r,o,i,s+1);return!!M;function S(t){const{uint16Array:e,uint32Array:n}=ft;let r=2*t;for(;!k(r,e);)r=2*(t=D(t));return q(t,n)}function v(t){const{uint16Array:e,uint32Array:n}=ft;let r=2*t;for(;!k(r,e);)r=2*(t=j(t,n));return q(t,n)+R(r,e)}}}const wt=new e,bt=new e;const At=parseInt(d)>=169,Bt=new e,Tt=new e,Mt=new e,St=new o,Pt=new o,vt=new o,It=new e,zt=new e,Ut=new e,_t=new e;function Et(t,n,r,s,a,c,d,f,p,h,g){Bt.fromBufferAttribute(n,c),Tt.fromBufferAttribute(n,d),Mt.fromBufferAttribute(n,f);const y=function(t,e,n,r,o,i,s,a){let c;if(c=i===l?t.intersectTriangle(r,n,e,!0,o):t.intersectTriangle(e,n,r,i!==u,o),null===c)return null;const d=t.origin.distanceTo(o);return d<s||d>a?null:{distance:d,point:o.clone()}}(t,Bt,Tt,Mt,_t,p,h,g);if(y){const n=new e;i.getBarycoord(_t,Bt,Tt,Mt,n),s&&(St.fromBufferAttribute(s,c),Pt.fromBufferAttribute(s,d),vt.fromBufferAttribute(s,f),y.uv=i.getInterpolation(_t,Bt,Tt,Mt,St,Pt,vt,new o)),a&&(St.fromBufferAttribute(a,c),Pt.fromBufferAttribute(a,d),vt.fromBufferAttribute(a,f),y.uv1=i.getInterpolation(_t,Bt,Tt,Mt,St,Pt,vt,new o)),r&&(It.fromBufferAttribute(r,c),zt.fromBufferAttribute(r,d),Ut.fromBufferAttribute(r,f),y.normal=i.getInterpolation(_t,Bt,Tt,Mt,It,zt,Ut,new e),y.normal.dot(t.direction)>0&&y.normal.multiplyScalar(-1));const l={a:c,b:d,c:f,normal:new e,materialIndex:0};i.getNormal(Bt,Tt,Mt,l.normal),y.face=l,y.faceIndex=c,At&&(y.barycoord=n)}return y}function Ft(t,e,n,r,o,i,s){const a=3*r;let c=a+0,l=a+1,u=a+2;const d=t.index;t.index&&(c=d.getX(c),l=d.getX(l),u=d.getX(u));const{position:f,normal:p,uv:h,uv1:g}=t.attributes,y=Et(n,f,p,h,g,c,l,u,e,i,s);return y?(y.faceIndex=r,o&&o.push(y),y):null}function Ct(t,e,n,r){const o=t.a,i=t.b,s=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(a),c=n.getX(c),l=n.getX(l)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(c),i.y=r.getY(c),i.z=r.getZ(c),s.x=r.getX(l),s.y=r.getY(l),s.z=r.getZ(l)}function Gt(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,d=e+t;u<d;u++){let t;if(t=u,Ct(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function Vt(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,c,l=0;const u=t._roots;for(let f=0,p=u.length;f<p;f++)i=u[f],s=new Uint32Array(i),a=new Uint16Array(i),c=new Float32Array(i),d(0,l),l+=i.byteLength;function d(t,n,i=!1){const l=2*t;if(a[l+15]===x){const e=s[t+6];let n=1/0,i=1/0,u=1/0,d=-1/0,f=-1/0,p=-1/0;for(let t=3*e,s=3*(e+a[l+14]);t<s;t++){let e=r[t];const s=o.getX(e),a=o.getY(e),c=o.getZ(e);s<n&&(n=s),s>d&&(d=s),a<i&&(i=a),a>f&&(f=a),c<u&&(u=c),c>p&&(p=c)}return(c[t+0]!==n||c[t+1]!==i||c[t+2]!==u||c[t+3]!==d||c[t+4]!==f||c[t+5]!==p)&&(c[t+0]=n,c[t+1]=i,c[t+2]=u,c[t+3]=d,c[t+4]=f,c[t+5]=p,!0)}{const r=t+8,o=s[t+6],a=r+n,l=o+n;let u=i,f=!1,p=!1;e?u||(f=e.has(a),p=e.has(l),u=!f&&!p):(f=!0,p=!0);const h=u||p;let g=!1;(u||f)&&(g=d(r,n,u));let y=!1;h&&(y=d(o,n,u));const m=g||y;if(m)for(let e=0;e<3;e++){const n=r+e,i=o+e,s=c[n],a=c[n+3],l=c[i],u=c[i+3];c[t+e]=s<l?s:l,c[t+e+3]=a>u?a:u}return m}}}function Xt(t,e,n,r,o){let i,s,a,c,l,u;const d=1/n.direction.x,f=1/n.direction.y,p=1/n.direction.z,h=n.origin.x,g=n.origin.y,y=n.origin.z;let m=e[t],x=e[t+3],w=e[t+1],b=e[t+3+1],A=e[t+2],B=e[t+3+2];return d>=0?(i=(m-h)*d,s=(x-h)*d):(i=(x-h)*d,s=(m-h)*d),f>=0?(a=(w-g)*f,c=(b-g)*f):(a=(b-g)*f,c=(w-g)*f),!(i>c||a>s)&&((a>i||isNaN(i))&&(i=a),(c<s||isNaN(s))&&(s=c),p>=0?(l=(A-y)*p,u=(B-y)*p):(l=(B-y)*p,u=(A-y)*p),!(i>u||l>s)&&((l>i||i!=i)&&(i=l),(u<s||s!=s)&&(s=u),i<=o&&s>=r))}function Nt(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,d=e+t;u<d;u++){let t;if(t=n.resolveTriangleIndex(u),Ct(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function kt(t,e,n,r,o,i,s){ft.setBuffer(t._roots[e]),qt(0,t,n,r,o,i,s),ft.clearBuffer()}function qt(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:l}=ft,u=2*t;if(k(u,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:l}=t;for(let u=r,d=r+o;u<d;u++)Ft(c,e,n,u,i,s,a)}(e,n,r,q(t,l),R(u,c),o,i,s)}else{const c=D(t);Xt(c,a,r,i,s)&&qt(c,e,n,r,o,i,s);const u=j(t,l);Xt(u,a,r,i,s)&&qt(u,e,n,r,o,i,s)}}const Rt=["x","y","z"];function Dt(t,e,n,r,o,i){ft.setBuffer(t._roots[e]);const s=jt(0,t,n,r,o,i);return ft.clearBuffer(),s}function jt(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=ft;let l=2*t;if(k(l,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let t;t=Ft(a,e,n,d,null,i,s),t&&t.distance<l&&(u=t,l=t.distance)}return u}(e,n,r,q(t,c),R(l,a),o,i)}{const a=O(t,c),l=Rt[a],u=r.direction[l]>=0;let d,f;u?(d=D(t),f=j(t,c)):(d=j(t,c),f=D(t));const p=Xt(d,s,r,o,i)?jt(d,e,n,r,o,i):null;if(p){const t=p.point[l];if(u?t<=s[f+a]:t>=s[f+a+3])return p}const h=Xt(f,s,r,o,i)?jt(f,e,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const Ot=new c,$t=new at,Lt=new at,Wt=new a,Yt=new ct,Zt=new ct;function Ht(t,e,n,r){ft.setBuffer(t._roots[e]);const o=Kt(0,t,n,r);return ft.clearBuffer(),o}function Kt(t,e,n,r,o=null){const{float32Array:i,uint16Array:s,uint32Array:a}=ft;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),Yt.set(n.boundingBox.min,n.boundingBox.max,r),o=Yt);if(!k(c,s)){const s=t+8,c=a[t+6];P(s,i,Ot);if(o.intersectsBox(Ot)&&Kt(s,e,n,r,o))return!0;P(c,i,Ot);return!!(o.intersectsBox(Ot)&&Kt(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,p=q(t,a),h=R(c,s);if(Wt.copy(r).invert(),n.boundsTree){P(t,i,Zt),Zt.matrix.copy(Wt),Zt.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>Zt.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*p,n=3*(h+p);e<n;e+=3)if(Ct(Lt,e,l,u),Lt.needsUpdate=!0,t.intersectsTriangle(Lt))return!0;return!1}})}for(let t=3*p,e=3*(h+p);t<e;t+=3){Ct($t,t,l,u),$t.a.applyMatrix4(Wt),$t.b.applyMatrix4(Wt),$t.c.applyMatrix4(Wt),$t.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Ct(Lt,t,d,f),Lt.needsUpdate=!0,$t.intersectsTriangle(Lt))return!0}}}const Jt=new a,Qt=new ct,te=new ct,ee=new e,ne=new e,re=new e,oe=new e;function ie(t,e,n,r={},o={},i=0,s=1/0){e.boundingBox||e.computeBoundingBox(),Qt.set(e.boundingBox.min,e.boundingBox.max,n),Qt.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,d=e.index,f=dt.getPrimitive(),p=dt.getPrimitive();let h=ee,g=ne,y=null,m=null;o&&(y=re,m=oe);let x=1/0,w=null,b=null;return Jt.copy(n).invert(),te.matrix.copy(Jt),t.shapecast({boundsTraverseOrder:t=>Qt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s&&(e&&(te.min.copy(t.min),te.max.copy(t.max),te.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>te.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s,intersectsRange:(e,o)=>{for(let s=e,a=e+o;s<a;s++){Ct(p,3*s,d,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Ct(f,3*e,l,c),f.needsUpdate=!0;const t=f.distanceToTriangle(p,h,y);if(t<x&&(g.copy(h),m&&m.copy(y),x=t,w=e,b=s),t<i)return!0}}}})}for(let o=0,s=A(e);o<s;o++){Ct(p,3*o,d,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Ct(f,3*e,l,c),f.needsUpdate=!0;const t=f.distanceToTriangle(p,h,y);if(t<x&&(g.copy(h),m&&m.copy(y),x=t,w=e,b=o),t<i)return!0}}}}),dt.releasePrimitive(f),dt.releasePrimitive(p),x===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=x,r.faceIndex=w,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(Jt),g.applyMatrix4(Jt),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}function se(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,c,l=0;const u=t._roots;for(let f=0,p=u.length;f<p;f++)i=u[f],s=new Uint32Array(i),a=new Uint16Array(i),c=new Float32Array(i),d(0,l),l+=i.byteLength;function d(n,i,l=!1){const u=2*n;if(a[u+15]===x){const e=s[n+6];let i=1/0,l=1/0,d=1/0,f=-1/0,p=-1/0,h=-1/0;for(let n=e,s=e+a[u+14];n<s;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const s=o.getX(n),a=o.getY(n),c=o.getZ(n);s<i&&(i=s),s>f&&(f=s),a<l&&(l=a),a>p&&(p=a),c<d&&(d=c),c>h&&(h=c)}}return(c[n+0]!==i||c[n+1]!==l||c[n+2]!==d||c[n+3]!==f||c[n+4]!==p||c[n+5]!==h)&&(c[n+0]=i,c[n+1]=l,c[n+2]=d,c[n+3]=f,c[n+4]=p,c[n+5]=h,!0)}{const t=n+8,r=s[n+6],o=t+i,a=r+i;let u=l,f=!1,p=!1;e?u||(f=e.has(o),p=e.has(a),u=!f&&!p):(f=!0,p=!0);const h=u||p;let g=!1;(u||f)&&(g=d(t,i,u));let y=!1;h&&(y=d(r,i,u));const m=g||y;if(m)for(let e=0;e<3;e++){const o=t+e,i=r+e,s=c[o],a=c[o+3],l=c[i],u=c[i+3];c[n+e]=s<l?s:l,c[n+e+3]=a>u?a:u}return m}}}function ae(t,e,n,r,o,i,s){ft.setBuffer(t._roots[e]),ce(0,t,n,r,o,i,s),ft.clearBuffer()}function ce(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:l}=ft,u=2*t;if(k(u,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:l}=t;for(let u=r,d=r+o;u<d;u++)Ft(c,e,n,l?l[u]:u,i,s,a)}(e,n,r,q(t,l),R(u,c),o,i,s)}else{const c=D(t);Xt(c,a,r,i,s)&&ce(c,e,n,r,o,i,s);const u=j(t,l);Xt(u,a,r,i,s)&&ce(u,e,n,r,o,i,s)}}const le=["x","y","z"];function ue(t,e,n,r,o,i){ft.setBuffer(t._roots[e]);const s=de(0,t,n,r,o,i);return ft.clearBuffer(),s}function de(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=ft;let l=2*t;if(k(l,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let t;t=Ft(a,e,n,c?c[d]:d,null,i,s),t&&t.distance<l&&(u=t,l=t.distance)}return u}(e,n,r,q(t,c),R(l,a),o,i)}{const a=O(t,c),l=le[a],u=r.direction[l]>=0;let d,f;u?(d=D(t),f=j(t,c)):(d=j(t,c),f=D(t));const p=Xt(d,s,r,o,i)?de(d,e,n,r,o,i):null;if(p){const t=p.point[l];if(u?t<=s[f+a]:t>=s[f+a+3])return p}const h=Xt(f,s,r,o,i)?de(f,e,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const fe=new c,pe=new at,he=new at,ge=new a,ye=new ct,me=new ct;function xe(t,e,n,r){ft.setBuffer(t._roots[e]);const o=we(0,t,n,r);return ft.clearBuffer(),o}function we(t,e,n,r,o=null){const{float32Array:i,uint16Array:s,uint32Array:a}=ft;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),ye.set(n.boundingBox.min,n.boundingBox.max,r),o=ye);if(!k(c,s)){const s=t+8,c=a[t+6];P(s,i,fe);if(o.intersectsBox(fe)&&we(s,e,n,r,o))return!0;P(c,i,fe);return!!(o.intersectsBox(fe)&&we(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,p=q(t,a),h=R(c,s);if(ge.copy(r).invert(),n.boundsTree){P(t,i,me),me.matrix.copy(ge),me.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>me.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=p,r=h+p;n<r;n++)if(Ct(he,3*e.resolveTriangleIndex(n),l,u),he.needsUpdate=!0,t.intersectsTriangle(he))return!0;return!1}})}for(let t=p,n=h+p;t<n;t++){const n=e.resolveTriangleIndex(t);Ct(pe,3*n,l,u),pe.a.applyMatrix4(ge),pe.b.applyMatrix4(ge),pe.c.applyMatrix4(ge),pe.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Ct(he,t,d,f),he.needsUpdate=!0,pe.intersectsTriangle(he))return!0}}}const be=new a,Ae=new ct,Be=new ct,Te=new e,Me=new e,Se=new e,Pe=new e;function ve(t,e,n,r={},o={},i=0,s=1/0){e.boundingBox||e.computeBoundingBox(),Ae.set(e.boundingBox.min,e.boundingBox.max,n),Ae.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,d=e.index,f=dt.getPrimitive(),p=dt.getPrimitive();let h=Te,g=Me,y=null,m=null;o&&(y=Se,m=Pe);let x=1/0,w=null,b=null;return be.copy(n).invert(),Be.matrix.copy(be),t.shapecast({boundsTraverseOrder:t=>Ae.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s&&(e&&(Be.min.copy(t.min),Be.max.copy(t.max),Be.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>Be.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<s,intersectsRange:(e,s)=>{for(let A=e,B=e+s;A<B;A++){const e=a.resolveTriangleIndex(A);Ct(p,3*e,d,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let n=r,s=r+o;n<s;n++){const e=t.resolveTriangleIndex(n);Ct(f,3*e,l,c),f.needsUpdate=!0;const r=f.distanceToTriangle(p,h,y);if(r<x&&(g.copy(h),m&&m.copy(y),x=r,w=n,b=A),r<i)return!0}}}})}for(let s=0,a=A(e);s<a;s++){Ct(p,3*s,d,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);Ct(f,3*n,l,c),f.needsUpdate=!0;const r=f.distanceToTriangle(p,h,y);if(r<x&&(g.copy(h),m&&m.copy(y),x=r,w=e,b=s),r<i)return!0}}}}),dt.releasePrimitive(f),dt.releasePrimitive(p),x===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=x,r.faceIndex=w,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(be),g.applyMatrix4(be),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}const Ie=new ft.constructor,ze=new ft.constructor,Ue=new lt(()=>new c),_e=new c,Ee=new c,Fe=new c,Ce=new c;let Ge=!1;function Ve(t,e,n,r,o,i=0,s=0,a=0,c=0,l=null,u=!1){let d,f;u?(d=ze,f=Ie):(d=Ie,f=ze);const p=d.float32Array,h=d.uint32Array,g=d.uint16Array,y=f.float32Array,m=f.uint32Array,x=f.uint16Array,w=2*e,b=k(2*t,g),A=k(w,x);let B=!1;if(A&&b)B=u?o(q(e,m),R(2*e,x),q(t,h),R(2*t,g),c,s+e,a,i+t):o(q(t,h),R(2*t,g),q(e,m),R(2*e,x),a,i+t,c,s+e);else if(A){const l=Ue.getPrimitive();P(e,y,l),l.applyMatrix4(n);const d=D(t),f=j(t,h);P(d,p,_e),P(f,p,Ee);const g=l.intersectsBox(_e),m=l.intersectsBox(Ee);B=g&&Ve(e,d,r,n,o,s,i,c,a+1,l,!u)||m&&Ve(e,f,r,n,o,s,i,c,a+1,l,!u),Ue.releasePrimitive(l)}else{const d=D(e),f=j(e,m);P(d,y,Fe),P(f,y,Ce);const g=l.intersectsBox(Fe),x=l.intersectsBox(Ce);if(g&&x)B=Ve(t,d,n,r,o,i,s,a,c+1,l,u)||Ve(t,f,n,r,o,i,s,a,c+1,l,u);else if(g)if(b)B=Ve(t,d,n,r,o,i,s,a,c+1,l,u);else{const e=Ue.getPrimitive();e.copy(Fe).applyMatrix4(n);const l=D(t),f=j(t,h);P(l,p,_e),P(f,p,Ee);const g=e.intersectsBox(_e),y=e.intersectsBox(Ee);B=g&&Ve(d,l,r,n,o,s,i,c,a+1,e,!u)||y&&Ve(d,f,r,n,o,s,i,c,a+1,e,!u),Ue.releasePrimitive(e)}else if(x)if(b)B=Ve(t,f,n,r,o,i,s,a,c+1,l,u);else{const e=Ue.getPrimitive();e.copy(Ce).applyMatrix4(n);const l=D(t),d=j(t,h);P(l,p,_e),P(d,p,Ee);const g=e.intersectsBox(_e),y=e.intersectsBox(Ee);B=g&&Ve(f,l,r,n,o,s,i,c,a+1,e,!u)||y&&Ve(f,d,r,n,o,s,i,c,a+1,e,!u),Ue.releasePrimitive(e)}}return B}const Xe=new ct,Ne=new c,ke={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class qe{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=t._indirectBuffer,i=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map(t=>t.slice()),index:i?i.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:i?i.array:null,indirectBuffer:o},s}static deserialize(e,n,r={}){r={setIndex:!0,indirect:Boolean(e.indirectBuffer),...r};const{index:o,roots:i,indirectBuffer:s}=e,a=new qe(n,{...r,[b]:!0});if(a._roots=i,a._indirectBuffer=s||null,r.setIndex){const r=n.getIndex();if(null===r){const r=new t(e.index,1,!1);n.setIndex(r)}else r.array!==o&&(r.array.set(o),r.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({...ke,[b]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[b]||(et(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new c))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){return(this.indirect?se:Vt)(this,t)}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(i,s=0){const a=2*i,c=o[a+15]===x;if(c){const e=r[i+6],l=o[a+14];t(s,c,new Float32Array(n,4*i,6),e,l)}else{const o=i+8,a=r[i+6],l=r[i+7];t(s,c,new Float32Array(n,4*i,6),l)||(e(o,s+1),e(a,s+1))}}(0)}raycast(t,e=f,n=0,r=1/0){const o=this._roots,i=this.geometry,s=[],a=e.isMaterial,c=Array.isArray(e),l=i.groups,u=a?e.side:e,d=this.indirect?ae:kt;for(let f=0,p=o.length;f<p;f++){const o=c?e[l[f].materialIndex].side:u,i=s.length;if(d(this,f,o,t,s,n,r),c){const t=l[f].materialIndex;for(let e=i,n=s.length;e<n;e++)s[e].face.materialIndex=t}}return s}raycastFirst(t,e=f,n=0,r=1/0){const o=this._roots,i=this.geometry,s=e.isMaterial,a=Array.isArray(e);let c=null;const l=i.groups,u=s?e.side:e,d=this.indirect?ue:Dt;for(let f=0,p=o.length;f<p;f++){const o=d(this,f,a?e[l[f].materialIndex].side:u,t,n,r);null!=o&&(null==c||o.distance<c.distance)&&(c=o,a&&(o.face.materialIndex=l[f].materialIndex))}return c}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?xe:Ht;for(let i=0,s=r.length;i<s&&(n=o(this,i,t,e),!n);i++);return n}shapecast(t){const e=dt.getPrimitive(),n=this.indirect?Nt:Gt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:i,intersectsTriangle:s}=t;if(i&&s){const t=i;i=(r,o,i,a,c)=>!!t(r,o,i,a,c)||n(r,o,this,s,i,a,e)}else i||(i=s?(t,r,o,i)=>n(t,r,this,s,o,i,e):(t,e,n)=>n);let a=!1,c=0;const l=this._roots;for(let u=0,d=l.length;u<d;u++){const t=l[u];if(a=mt(this,u,o,i,r,c),a)break;c+=t.byteLength}return dt.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const i=dt.getPrimitive(),s=this.geometry.index,c=this.geometry.attributes.position,l=this.indirect?t=>{const e=this.resolveTriangleIndex(t);Ct(i,3*e,s,c)}:t=>{Ct(i,3*t,s,c)},u=dt.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,p=t.indirect?e=>{const n=t.resolveTriangleIndex(e);Ct(u,3*n,d,f)}:t=>{Ct(u,3*t,d,f)};if(o){const t=(t,n,r,s,a,c,d,f)=>{for(let h=r,g=r+s;h<g;h++){p(h),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(l(e),i.needsUpdate=!0,o(i,u,e,h,a,c,d,f))return!0}return!1};if(r){const e=r;r=function(n,r,o,i,s,a,c,l){return!!e(n,r,o,i,s,a,c,l)||t(n,r,o,i,s,a,c,l)}}else r=t}return function(t,e,n,r){if(Ge)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ge=!0;const o=t._roots,i=e._roots;let s,c=0,l=0;const u=(new a).copy(n).invert();for(let a=0,d=o.length;a<d;a++){Ie.setBuffer(o[a]),l=0;const t=Ue.getPrimitive();P($(0),Ie.float32Array,t),t.applyMatrix4(u);for(let e=0,o=i.length;e<o&&(ze.setBuffer(i[e]),s=Ve(0,0,n,u,r,c,l,0,0,t),ze.clearBuffer(),l+=i[e].length,!s);e++);if(Ue.releasePrimitive(t),Ie.clearBuffer(),c+=o[a].length,s)break}return Ge=!1,s}(this,t,e,r)}intersectsBox(t,e){return Xe.set(t.min,t.max,e),Xe.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Xe.intersectsBox(t),intersectsTriangle:t=>Xe.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,i=1/0){return(this.indirect?ve:ie)(this,t,e,n,r,o,i)}closestPointToPoint(t,e={},n=0,r=1/0){return function(t,e,n={},r=0,o=1/0){const i=r*r,s=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(wt.copy(e).clamp(t.min,t.max),wt.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,wt);const r=e.distanceToSquared(wt);return r<a&&(bt.copy(wt),a=r,c=n),r<i}}),a===1/0)return null;const l=Math.sqrt(a);return n.point?n.point.copy(bt):n.point=bt.clone(),n.distance=l,n.faceIndex=c,n}(this,t,e,n,r)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach(e=>{P(0,new Float32Array(e),Ne),t.union(Ne)}),t}}const Re=1e-6,De=Math.pow(10,-Math.log10(Re)),je=5e-7*De;function Oe(t){return~~(t*De+je)}function $e(t){return`${Oe(t.x)},${Oe(t.y)}`}function Le(t){return`${Oe(t.x)},${Oe(t.y)},${Oe(t.z)}`}function We(t){return`${Oe(t.x)},${Oe(t.y)},${Oe(t.z)},${Oe(t.w)}`}function Ye(t,e,n){n.direction.subVectors(e,t).normalize();const r=t.dot(n.direction);return n.origin.copy(t).addScaledVector(n.direction,-r),n}function Ze(){return"undefined"!=typeof SharedArrayBuffer}function He(t){if(t.buffer instanceof SharedArrayBuffer)return t;const e=t.constructor,n=t.buffer,r=new SharedArrayBuffer(n.byteLength),o=new Uint8Array(n);return new Uint8Array(r).set(o,0),new e(r)}function Ke(e,n){if(!e.index){const r=e.attributes.position.count,o=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(r,n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);e.setIndex(new t(o,1));for(let t=0;t<r;t++)o[t]=t}}function Je(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}const Qe=new e;function tn(t){return~~(t/3)}function en(t){return t%3}function nn(t,e){return t.start-e.start}function rn(t,e){return Qe.subVectors(e,t.origin).dot(t.direction)}const on=1e-5,sn=1e-4;class an{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let r=1/0,o=null;for(let a=0,c=e.length;a<c;a++){const c=e[a];if(i(c,t)&&i(c,n))continue;const l=s(c,t),u=s(c,n),d=Math.min(l,u);d<r&&(r=d,o=c)}return o;function i(t,e){const n=t.origin.distanceTo(e.origin)>on;return t.direction.angleTo(e.direction)>sn||n}function s(t,e){const n=t.origin.distanceTo(e.origin),r=t.direction.angleTo(e.direction);return n/on+r/sn}}}const cn=new e,ln=new e,un=new p;function dn(t,e,n){const r=t.attributes,o=t.index,i=r.position,s=new Map,a=new Map,c=Array.from(e),l=new an;for(let u=0,d=c.length;u<d;u++){const t=c[u],e=tn(t),n=en(t);let r,s=3*e+n,d=3*e+(n+1)%3;o&&(s=o.getX(s),d=o.getX(d)),cn.fromBufferAttribute(i,s),ln.fromBufferAttribute(i,d),Ye(cn,ln,un);let f=l.findClosestRay(un);null===f&&(f=un.clone(),l.addRay(f)),a.has(f)||a.set(f,{forward:[],reverse:[],ray:f}),r=a.get(f);let p=rn(f,cn),h=rn(f,ln);p>h&&([p,h]=[h,p]),un.direction.dot(f.direction)<0?r.reverse.push({start:p,end:h,index:t}):r.forward.push({start:p,end:h,index:t})}return a.forEach(({forward:t,reverse:e},r)=>{!function(t,e,n,r=1e-8){t.sort(nn),e.sort(nn);for(let a=0;a<t.length;a++){const r=t[a];for(let o=0;o<e.length;o++){const c=e[o];if(c.start>r.end);else{if(r.end<c.start||c.end<r.start)continue;if(r.start<=c.start&&r.end>=c.end)i(c.end,r.end)||t.splice(a+1,0,{start:c.end,end:r.end,index:r.index}),r.end=c.start,c.start=0,c.end=0;else if(r.start>=c.start&&r.end<=c.end)i(r.end,c.end)||e.splice(o+1,0,{start:r.end,end:c.end,index:c.index}),c.end=r.start,r.start=0,r.end=0;else if(r.start<=c.start&&r.end<=c.end){const t=r.end;r.end=c.start,c.start=t}else{if(!(r.start>=c.start&&r.end>=c.end))throw new Error;{const t=c.end;c.end=r.start,r.start=t}}}if(n.has(r.index)||n.set(r.index,[]),n.has(c.index)||n.set(c.index,[]),n.get(r.index).push(c.index),n.get(c.index).push(r.index),s(c)&&(e.splice(o,1),o--),s(r)){t.splice(a,1),a--;break}}}function o(t){for(let e=0;e<t.length;e++)s(t[e])&&(t.splice(e,1),e--)}function i(t,e){return Math.abs(e-t)<r}function s(t){return Math.abs(t.end-t.start)<r}o(t),o(e)}(t,e,s,n),0===t.length&&0===e.length&&a.delete(r)}),{disjointConnectivityMap:s,fragmentMap:a}}const fn=new o,pn=new e,hn=new h,gn=["","",""];class yn{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map(t=>~~(t/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map(t=>t%3):[]}isFullyConnected(){return 0===this.unmatchedEdges}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:r,degenerateEpsilon:o}=this,i=e?function(t){let e="";for(let n=0,r=c.length;n<r;n++){const r=a[c[n]];let o;switch(r.itemSize){case 1:o=Oe(r.getX(t));break;case 2:o=$e(fn.fromBufferAttribute(r,t));break;case 3:o=Le(pn.fromBufferAttribute(r,t));break;case 4:o=We(hn.fromBufferAttribute(r,t))}""!==e&&(e+="|"),e+=o}return e}:function(t){return pn.fromBufferAttribute(u,t),Le(pn)},s=new Map,{attributes:a}=t,c=e?Object.keys(a):null,l=t.index,u=a.position;let d=Je(t);const f=d;let p=0;n&&(p=t.drawRange.start,t.drawRange.count!==1/0&&(d=~~(t.drawRange.count/3)));let h=this.data;(!h||h.length<3*f)&&(h=new Int32Array(3*f)),h.fill(-1);let g=0,y=new Set;for(let m=p,x=3*d+p;m<x;m+=3){const t=m;for(let e=0;e<3;e++){let n=t+e;l&&(n=l.getX(n)),gn[e]=i(n)}for(let e=0;e<3;e++){const n=(e+1)%3,r=gn[e],o=gn[n],i=`${o}_${r}`;if(s.has(i)){const n=t+e,r=s.get(i);h[n]=r,h[r]=n,s.delete(i),g+=2,y.delete(r)}else{const n=`${r}_${o}`,i=t+e;s.set(n,i),y.add(i)}}}if(r){const{fragmentMap:e,disjointConnectivityMap:n}=dn(t,y,o);y.clear(),e.forEach(({forward:t,reverse:e})=>{t.forEach(({index:t})=>y.add(t)),e.forEach(({index:t})=>y.add(t))}),this.unmatchedDisjointEdges=e,this.disjointConnections=n,g=3*d-y.size}this.matchedEdges=g,this.unmatchedEdges=y.size,this.data=h}}class mn extends g{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new a,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,r=e.elements;for(let o=0;o<16;o++)if(n[o]!==r[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=Ze();if(n)for(const r in e){const t=e[r];if(t.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");t.array=He(t.array)}if(t.boundsTree||(Ke(t,{useSharedArrayBuffer:n}),t.boundsTree=new qe(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new yn(t)),!t.groupIndices){const e=Je(t),n=new Uint16Array(e),r=t.groups;for(let t=0,o=r.length;t<o;t++){const{start:e,count:o}=r[t];for(let r=e/3,i=(e+o)/3;r<i;r++)n[r]=t}t.groupIndices=n}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const xn=new e,wn=new e,bn=new e;function An(t,e=1e-14){xn.subVectors(t.b,t.a),wn.subVectors(t.c,t.a),bn.subVectors(t.b,t.c);const n=xn.angleTo(wn),r=xn.angleTo(bn),o=Math.PI-n-r;return Math.abs(n)<e||Math.abs(r)<e||Math.abs(o)<e||t.a.distanceToSquared(t.b)<e||t.a.distanceToSquared(t.c)<e||t.b.distanceToSquared(t.c)<e}const Bn=1e-10,Tn=1e-10,Mn=new r,Sn=new r,Pn=new e,vn=new e,In=new e,zn=new n,Un=new at;class _n{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new i),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class En{constructor(){this.trianglePool=new _n,this.triangles=[],this.normal=new e,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:r}=this;if(Array.isArray(t))for(let o=0,i=t.length;o<i;o++){const i=t[o];if(0===o)i.getNormal(r);else if(Math.abs(1-i.getNormal(Pn).dot(r))>Bn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const s=n.getTriangle();s.copy(i),e.push(s)}else{t.getNormal(r);const o=n.getTriangle();o.copy(t),e.push(o)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(vn).normalize(),Math.abs(1-Math.abs(vn.dot(e)))<1e-10){this.coplanarTriangleUsed=!0;for(let t=0,r=n.length;t<r;t++){n[t].coplanarCount=0}const e=[t.a,t.b,t.c];for(let n=0;n<3;n++){const r=(n+1)%3,o=e[n],i=e[r];Pn.subVectors(i,o).normalize(),In.crossVectors(vn,Pn),zn.setFromNormalAndCoplanarPoint(In,o),this.splitByPlane(zn,t)}}else t.getPlane(zn),this.splitByPlane(zn,t)}splitByPlane(t,e){const{triangles:n,trianglePool:r}=this;Un.copy(e),Un.needsUpdate=!0;for(let o=0,i=n.length;o<i;o++){const e=n[o];if(!Un.intersectsTriangle(e,Mn,!0))continue;const{a:s,b:a,c:c}=e;let l=0,u=-1,d=!1,f=[],p=[];const h=[s,a,c];for(let n=0;n<3;n++){const e=(n+1)%3;Mn.start.copy(h[n]),Mn.end.copy(h[e]);const r=t.distanceToPoint(Mn.start),o=t.distanceToPoint(Mn.end);if(Math.abs(r)<Tn&&Math.abs(o)<Tn){d=!0;break}if(r>0?f.push(n):p.push(n),Math.abs(r)<Tn)continue;let i=!!t.intersectLine(Mn,Pn);!i&&Math.abs(o)<Tn&&(Pn.copy(Mn.end),i=!0),!i||Pn.distanceTo(Mn.start)<Bn||(Pn.distanceTo(Mn.end)<Bn&&(u=n),0===l?Sn.start.copy(Pn):Sn.end.copy(Pn),l++)}if(!d&&2===l&&Sn.distance()>Tn)if(-1!==u){u=(u+1)%3;let t=0;t===u&&(t=(t+1)%3);let s=t+1;s===u&&(s=(s+1)%3);const a=r.getTriangle();a.a.copy(h[s]),a.b.copy(Sn.end),a.c.copy(Sn.start),An(a)||n.push(a),e.a.copy(h[t]),e.b.copy(Sn.start),e.c.copy(Sn.end),An(e)&&(n.splice(o,1),o--,i--)}else{const t=f.length>=2?p[0]:f[0];if(0===t){let t=Sn.start;Sn.start=Sn.end,Sn.end=t}const s=(t+1)%3,a=(t+2)%3,c=r.getTriangle(),l=r.getTriangle();h[s].distanceToSquared(Sn.start)<h[a].distanceToSquared(Sn.end)?(c.a.copy(h[s]),c.b.copy(Sn.start),c.c.copy(Sn.end),l.a.copy(h[s]),l.b.copy(h[a]),l.c.copy(Sn.start)):(c.a.copy(h[a]),c.b.copy(Sn.start),c.c.copy(Sn.end),l.a.copy(h[s]),l.b.copy(h[a]),l.c.copy(Sn.end)),e.a.copy(h[t]),e.b.copy(Sn.end),e.c.copy(Sn.start),An(c)||n.push(c),An(l)||n.push(l),An(e)&&(n.splice(o,1),o--,i--)}}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}class Fn{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(0!==this.length)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=new e(new(Ze()?SharedArrayBuffer:ArrayBuffer)(4+(r=~~(r=t*e.BYTES_PER_ELEMENT))-r%4));var r;this.array&&n.set(this.array,0),this.array=n}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let r=0,o=t.length;r<o;r++)e[n+r]=t[r];this.length+=t.length}clear(){this.length=0}}class Cn{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let r=0;for(let o=0;o<e;o++){r+=n[o][t].length}return r}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const t={};e.push(t);for(const e in n){const r=n[e],o=new Fn(r.type);o.itemSize=r.itemSize,o.normalized=r.normalized,t[e]=o}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,r){const{groupAttributes:o}=this,i=o[0][t];if(i){if(i.type!==e)for(let s=0,a=o.length;s<a;s++){const i=o[s][t];i.setType(e),i.itemSize=n,i.normalized=r}}else for(let s=0,a=o.length;s<a;s++){const i=new Fn(e);i.itemSize=n,i.normalized=r,o[s][t]=i}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(t=>{for(const e in t)t[e].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Gn{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:r}=this;n[t]||(n[t]=[],r.push(t)),n[t].push(e)}}const Vn=0,Xn=new p,Nn=new a,kn=new i,qn=new e,Rn=new h,Dn=new h,jn=new h,On=new h,$n=new h,Ln=new h,Wn=new r,Yn=new e,Zn=1e-8,Hn=-1;let Kn=null;function Jn(t){Kn=t}function Qn(t,e){t.getMidpoint(Xn.origin),t.getNormal(Xn.direction);const n=e.raycastFirst(Xn,u);return Boolean(n&&Xn.direction.dot(n.face.normal)>0)?Hn:1}function tr(t,e){function n(){return Math.random()-.5}t.getNormal(Yn),Xn.direction.copy(Yn),t.getMidpoint(Xn.origin);let r=0,o=1/0;for(let i=0;i<3;i++){Xn.direction.x+=n()*Zn,Xn.direction.y+=n()*Zn,Xn.direction.z+=n()*Zn,Xn.direction.multiplyScalar(-1);const t=e.raycastFirst(Xn,u);if(Boolean(t&&Xn.direction.dot(t.face.normal)>0)&&r++,null!==t&&(o=Math.min(o,t.distance)),o<=1e-15)return t.face.normal.dot(Yn)>0?2:-2;if(r/3>.5||(i-r+1)/3>.5)break}return r/3>.5?Hn:1}function er(t,e,n,r,o,i,s=!1){const a=n.attributes,c=n.index,l=3*t,u=c.getX(l+0),d=c.getX(l+1),f=c.getX(l+2);for(const p in i){const t=a[p],n=i[p];if(!(p in a))throw new Error(`CSG Operations: Attribute ${p} not available on geometry.`);const c=t.itemSize;"position"===p?(kn.a.fromBufferAttribute(t,u).applyMatrix4(r),kn.b.fromBufferAttribute(t,d).applyMatrix4(r),kn.c.fromBufferAttribute(t,f).applyMatrix4(r),or(kn.a,kn.b,kn.c,e,3,n,s)):"normal"===p?(kn.a.fromBufferAttribute(t,u).applyNormalMatrix(o),kn.b.fromBufferAttribute(t,d).applyNormalMatrix(o),kn.c.fromBufferAttribute(t,f).applyNormalMatrix(o),s&&(kn.a.multiplyScalar(-1),kn.b.multiplyScalar(-1),kn.c.multiplyScalar(-1)),or(kn.a,kn.b,kn.c,e,3,n,s,!0)):(Rn.fromBufferAttribute(t,u),Dn.fromBufferAttribute(t,d),jn.fromBufferAttribute(t,f),or(Rn,Dn,jn,e,c,n,s))}}function nr(t,e,n,r,o,i,s,a=!1){ir(t,r,o,i,s,a),ir(a?n:e,r,o,i,s,a),ir(a?e:n,r,o,i,s,a)}function rr(t,e,n=!1){switch(t){case 0:if(1===e||2===e&&!n)return 1;break;case 1:if(n){if(e===Hn)return 0}else if(1===e||-2===e)return 1;break;case 2:if(n){if(1===e||-2===e)return 1}else if(e===Hn)return 0;break;case 4:if(e===Hn)return 0;if(1===e)return 1;break;case 3:if(e===Hn||2===e&&!n)return 1;break;case 5:if(!n&&(1===e||-2===e))return 1;break;case 6:if(!n&&(e===Hn||2===e))return 1;break;default:throw new Error(`Unrecognized CSG operation enum "${t}".`)}return 2}function or(t,e,n,r,o,i,s=!1,a=!1){const c=t=>{i.push(t.x),o>1&&i.push(t.y),o>2&&i.push(t.z),o>3&&i.push(t.w)};On.set(0,0,0,0).addScaledVector(t,r.a.x).addScaledVector(e,r.a.y).addScaledVector(n,r.a.z),$n.set(0,0,0,0).addScaledVector(t,r.b.x).addScaledVector(e,r.b.y).addScaledVector(n,r.b.z),Ln.set(0,0,0,0).addScaledVector(t,r.c.x).addScaledVector(e,r.c.y).addScaledVector(n,r.c.z),a&&(On.normalize(),$n.normalize(),Ln.normalize()),c(On),s?(c(Ln),c($n)):(c($n),c(Ln))}function ir(t,e,n,r,o,i=!1){for(const s in o){const a=e[s],c=o[s];if(!(s in e))throw new Error(`CSG Operations: Attribute ${s} no available on geometry.`);const l=a.itemSize;"position"===s?(qn.fromBufferAttribute(a,t).applyMatrix4(n),c.push(qn.x,qn.y,qn.z)):"normal"===s?(qn.fromBufferAttribute(a,t).applyNormalMatrix(r),i&&qn.multiplyScalar(-1),c.push(qn.x,qn.y,qn.z)):(c.push(a.getX(t)),l>1&&c.push(a.getY(t)),l>2&&c.push(a.getZ(t)),l>3&&c.push(a.getW(t)))}}class sr{constructor(t){this.triangle=(new i).copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=(new i).copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class ar{constructor(){this.data={}}addTriangleIntersection(t,e,n,r){const{data:o}=this;o[t]||(o[t]=new sr(e)),o[t].addTriangle(n,r)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(null!==t)t in e&&n.push(e[t].triangle);else for(const r in e)n.push(e[r].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(t=>parseInt(t)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,r=new Set,o=[],i=t=>{if(n[t])if(null!==e)n[t].intersects[e]&&o.push(n[t].intersects[e]);else{const e=n[t].intersects;for(const t in e)r.has(t)||(r.add(t),o.push(e[t]))}};if(null!==t)i(t);else for(const s in n)i(s);return o}reset(){this.data={}}}class cr{constructor(){this.enabled=!1,this.triangleIntersectsA=new ar,this.triangleIntersectsB=new ar,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,r){const{triangleIntersectsA:o,triangleIntersectsB:i}=this;o.addTriangleIntersection(t,e,n,r),i.addTriangleIntersection(n,r,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Jn(this))}complete(){this.enabled&&Jn(null)}}const lr=new a,ur=new y,dr=new i,fr=new i,pr=new i,hr=new i,gr=[],yr=[];function mr(t){for(const e of t)return e}function xr(t,e,n,r,o,i={}){const{useGroups:s=!0}=i,{aIntersections:a,bIntersections:c}=function(t,e){const n=new Gn,r=new Gn;return Nn.copy(t.matrixWorld).invert().multiply(e.matrixWorld),t.geometry.boundsTree.bvhcast(e.geometry.boundsTree,Nn,{intersectsTriangles(o,i,s,a){if(!An(o)&&!An(i)){let c=o.intersectsTriangle(i,Wn,!0);if(!c){const t=o.plane,e=i.plane,n=t.normal,r=e.normal;1===n.dot(r)&&Math.abs(t.constant-e.constant)<1e-14&&(c=!0)}if(c){let c=t.geometry.boundsTree.resolveTriangleIndex(s),l=e.geometry.boundsTree.resolveTriangleIndex(a);n.add(c,l),r.add(l,c),Kn&&(Kn.addEdge(Wn),Kn.addIntersectingTriangles(s,o,a,i))}}return!1}}),{aIntersections:n,bIntersections:r}}(t,e);let l;l=s?0:-1,wr(t,e,a,n,!1,r,o,l),br(t,e,a,n,!1,o,l);return-1!==n.findIndex(t=>6!==t&&5!==t)&&(l=s?t.geometry.groups.length||1:-1,wr(e,t,c,n,!0,r,o,l),br(e,t,c,n,!0,o,l)),gr.length=0,yr.length=0,{groups:[],materials:null}}function wr(t,e,n,r,o,i,s,a=0){const c=t.matrixWorld.determinant()<0;lr.copy(e.matrixWorld).invert().multiply(t.matrixWorld),ur.getNormalMatrix(t.matrixWorld).multiplyScalar(c?-1:1);const l=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes.position,f=e.geometry.boundsTree,p=e.geometry.index,h=e.geometry.attributes.position,g=n.ids,y=n.intersectionSet;for(let m=0,x=g.length;m<x;m++){const e=g[m],n=-1===a?0:l[e]+a,x=3*e,w=u.getX(x+0),b=u.getX(x+1),A=u.getX(x+2);dr.a.fromBufferAttribute(d,w).applyMatrix4(lr),dr.b.fromBufferAttribute(d,b).applyMatrix4(lr),dr.c.fromBufferAttribute(d,A).applyMatrix4(lr),i.reset(),i.initialize(dr);const B=y[e];for(let t=0,r=B.length;t<r;t++){const e=3*B[t],n=p.getX(e+0),r=p.getX(e+1),o=p.getX(e+2);fr.a.fromBufferAttribute(h,n),fr.b.fromBufferAttribute(h,r),fr.c.fromBufferAttribute(h,o),i.splitByTriangle(fr)}const T=i.triangles;for(let a=0,l=T.length;a<l;a++){const l=T[a],u=i.coplanarTriangleUsed?tr(l,f):Qn(l,f);gr.length=0,yr.length=0;for(let t=0,e=r.length;t<e;t++){const e=rr(r[t],u,o);2!==e&&(yr.push(e),gr.push(s[t].getGroupAttrSet(n)))}if(0!==gr.length){dr.getBarycoord(l.a,hr.a),dr.getBarycoord(l.b,hr.b),dr.getBarycoord(l.c,hr.c);for(let n=0,r=gr.length;n<r;n++){const r=gr[n],o=0===yr[n];er(e,hr,t.geometry,t.matrixWorld,ur,r,c!==o)}}}}return g.length}function br(t,e,n,r,o,i,s=0){const a=t.matrixWorld.determinant()<0;lr.copy(e.matrixWorld).invert().multiply(t.matrixWorld),ur.getNormalMatrix(t.matrixWorld).multiplyScalar(a?-1:1);const c=e.geometry.boundsTree,l=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes,f=d.position,p=[],h=t.geometry.halfEdges,g=new Set;for(let y=0,m=Je(t.geometry);y<m;y++)y in n.intersectionSet||g.add(y);for(;g.size>0;){const e=mr(g);g.delete(e),p.push(e);const n=3*e,y=u.getX(n+0),m=u.getX(n+1),x=u.getX(n+2);pr.a.fromBufferAttribute(f,y).applyMatrix4(lr),pr.b.fromBufferAttribute(f,m).applyMatrix4(lr),pr.c.fromBufferAttribute(f,x).applyMatrix4(lr);const w=Qn(pr,c);yr.length=0,gr.length=0;for(let t=0,s=r.length;t<s;t++){const e=rr(r[t],w,o);2!==e&&(yr.push(e),gr.push(i[t]))}for(;p.length>0;){const e=p.pop();for(let t=0;t<3;t++){const n=h.getSiblingTriangleIndex(e,t);-1!==n&&g.has(n)&&(p.push(n),g.delete(n))}if(0!==gr.length){const n=3*e,r=u.getX(n+0),o=u.getX(n+1),i=u.getX(n+2),c=-1===s?0:l[e]+s;if(pr.a.fromBufferAttribute(f,r),pr.b.fromBufferAttribute(f,o),pr.c.fromBufferAttribute(f,i),!An(pr))for(let e=0,s=gr.length;e<s;e++){const n=yr[e],s=gr[e].getGroupAttrSet(c),l=0===n;nr(r,o,i,d,t.matrixWorld,ur,s,l!==a)}}}}}function Ar(t,e){let n=e;return Array.isArray(e)||(n=[],t.forEach(t=>{n[t.materialIndex]=e})),n}class Br{constructor(){this.triangleSplitter=new En,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new cr}getGroupRanges(t){return this.useGroups&&0!==t.groups.length?t.groups.map(t=>({...t})):[{start:0,count:1/0,materialIndex:0}]}evaluate(e,n,r,o=new mn){let i=!0;if(Array.isArray(r)||(r=[r]),Array.isArray(o)||(o=[o],i=!1),o.length!==r.length)throw new Error("Evaluator: operations and target array passed as different sizes.");e.prepareGeometry(),n.prepareGeometry();const{triangleSplitter:s,attributeData:a,attributes:c,useGroups:l,consolidateGroups:u,debug:d}=this;for(;a.length<o.length;)a.push(new Cn);o.forEach((t,n)=>{!function(t,e,n,r){n.clear();const o=t.attributes;for(let i=0,s=r.length;i<s;i++){const t=r[i],e=o[t];n.initializeArray(t,e.array.constructor,e.itemSize,e.normalized)}for(const i in n.attributes)r.includes(i)||n.delete(i);for(const i in e.attributes)r.includes(i)||(e.deleteAttribute(i),e.dispose())}(e.geometry,t.geometry,a[n],c)}),d.init(),xr(e,n,r,s,a,{useGroups:l}),d.complete();const f=this.getGroupRanges(e.geometry),p=Ar(f,e.material),h=this.getGroupRanges(n.geometry),g=Ar(h,n.material);h.forEach(t=>t.materialIndex+=p.length);let y=[...f,...h].map((t,e)=>({...t,index:e}));if(l){const t=[...p,...g];u&&(y=y.map(e=>{const n=t[e.materialIndex];return e.materialIndex=t.indexOf(n),e}).sort((t,e)=>t.materialIndex-e.materialIndex));const e=[];for(let n=0,r=t.length;n<r;n++){let r=!1;for(let t=0,o=y.length;t<o;t++){const o=y[t];o.materialIndex===n&&(r=!0,o.materialIndex=e.length)}r&&e.push(t[n])}o.forEach(t=>{t.material=e})}else y=[{start:0,count:1/0,index:0,materialIndex:0}],o.forEach(t=>{t.material=p[0]});return o.forEach((e,n)=>{const r=e.geometry;!function(e,n,r){let o=!1,i=-1;const s=e.attributes,a=n.groupAttributes[0];for(const l in a){const a=n.getTotalLength(l),c=n.getType(l),u=n.getItemSize(l),d=n.getNormalized(l);let f=s[l];(!f||f.array.length<a)&&(f=new t(new c(a),u,d),e.setAttribute(l,f),o=!0);let p=0;for(let t=0,e=Math.min(r.length,n.groupCount);t<e;t++){const e=r[t].index,{array:o,type:i,length:s}=n.groupAttributes[e][l],a=new i(o.buffer,0,s);f.array.set(a,p),p+=a.length}f.needsUpdate=!0,i=a/f.itemSize}if(e.index){const t=e.index.array;if(t.length<i)e.index=null,o=!0;else for(let e=0,n=t.length;e<n;e++)t[e]=e}let c=0;e.clearGroups();for(let t=0,l=Math.min(r.length,n.groupCount);t<l;t++){const{index:o,materialIndex:i}=r[t],s=n.getCount(o);0!==s&&(e.addGroup(c,s,i),c+=s)}e.setDrawRange(0,i),e.boundsTree=null,o&&e.dispose()}(r,a[n],y),u&&function(t){for(let e=0;e<t.length-1;e++){const n=t[e],r=t[e+1];if(n.materialIndex===r.materialIndex){const o=n.start,i=r.start+r.count;r.start=o,r.count=i-o,t.splice(e,1),e--}}}(r.groups)}),i?o:o[0]}evaluateHierarchy(t,e=new mn){t.updateMatrixWorld(!0);const n=(t,e)=>{const r=t.children;for(let o=0,i=r.length;o<i;o++){const t=r[o];t.isOperationGroup?n(t,e):e(t)}},r=t=>{const e=t.children;let o=!1;for(let n=0,s=e.length;n<s;n++){const t=e[n];o=r(t)||o}const i=t.isDirty();if(i&&t.markUpdated(),o&&!t.isOperationGroup){let e;return n(t,n=>{e=e?this.evaluate(e,n,n.operation):this.evaluate(t,n,n.operation)}),t._cachedGeometry=e.geometry,t._cachedMaterials=e.material,!0}return o||i};return r(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}export{Vn as A,mn as B,Br as E};
