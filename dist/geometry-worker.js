import{CylinderGeometry as e,SphereGeometry as t,BoxGeometry as r,Vector3 as n}from"./chunks/three-zd0udLjK.js";import{E as o,B as i,A as s}from"./chunks/three-bvh-csg-D0nAhu--.js";const a={};class l{constructor(e={}){this.card_width=e.card_width??85.6,this.card_height=e.card_height??53.98,this.card_thickness=e.card_thickness??.76,this.grid_columns=e.grid_columns??32,this.grid_rows=e.grid_rows??4,this.cell_spacing=e.cell_spacing??2.5,this.line_spacing=e.line_spacing??10,this.dot_spacing=e.dot_spacing??2.5,this.left_margin=e.left_margin??5,this.top_margin=e.top_margin??5,this.braille_x_adjust=e.braille_x_adjust??0,this.braille_y_adjust=e.braille_y_adjust??0,this.active_dot_height=e.active_dot_height??.6,this.active_dot_base_diameter=e.active_dot_base_diameter??1.5,this.active_dot_top_diameter=e.active_dot_top_diameter??1.2,this.use_rounded_dots=e.use_rounded_dots??!1,this.rounded_dot_base_diameter=e.rounded_dot_base_diameter??2,this.rounded_dot_dome_diameter=e.rounded_dot_dome_diameter??1.5,this.rounded_dot_base_height=e.rounded_dot_base_height??.2,this.rounded_dot_dome_height=e.rounded_dot_dome_height??.6,this.indicator_shapes=e.indicator_shapes??1,this.recess_shape=e.recess_shape??1,this.recessed_dot_base_diameter=e.recessed_dot_base_diameter??1.8,this.hemisphere_subdivisions=e.hemisphere_subdivisions??1}}class d{constructor(){this.evaluator=new o,this.evaluator.attributes=["position","normal"],this.evaluator.useGroups=!1,this.dotPositions=[[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]]}brailleToDots(e){if(!e||"string"!=typeof e)return[0,0,0,0,0,0];const t=e.charCodeAt(0);if(t<10240||t>10495)return[0,0,0,0,0,0];const r=t-10240,n=[0,0,0,0,0,0];for(let o=0;o<6;o++)r&1<<o&&(n[o]=1);return n}createBrailleDot(r,n,o,i){let s;if(i.use_rounded_dots){const r=Math.max(0,i.rounded_dot_base_diameter/2),n=Math.max(0,i.rounded_dot_dome_diameter/2),o=Math.max(0,i.rounded_dot_base_height),a=Math.max(0,i.rounded_dot_dome_height);if(r>0&&o>=0&&a>0){const i=[];if(o>0){const t=new e(n,r,o,48);i.push(t)}if(a>0&&n>0){const e=(n*n+a*a)/(2*a),r=new t(e,32,16),s=o/2+(a-e);r.translate(0,s,0),i.push(r)}s=i.length>1?i[0]:i[0]||new e(r,r,o,16)}else s=new e(i.active_dot_base_diameter/2,i.active_dot_base_diameter/2,i.active_dot_height,16)}else{const t=i.active_dot_base_diameter/2,r=i.active_dot_top_diameter/2,n=i.active_dot_height;s=new e(r,t,n,16)}return s.translate(r,n,o),s}async generateCard(e,t={}){const n=new l(t),o=t.onProgress||(()=>{});o(5,"Creating card base...");const a=new r(n.card_width,n.card_height,n.card_thickness,2,2,1);a.translate(n.card_width/2,n.card_height/2,n.card_thickness/2);const d=new i(a),c=[];o(10,"Processing braille text...");const h=[];for(let r=0;r<Math.min(e.length,n.grid_rows);r++){const t=e[r]||"";h.push(t.trim())}const m=[-n.dot_spacing/2,n.dot_spacing/2],u=[n.dot_spacing,0,-n.dot_spacing];let g=0,_=0;for(let r=0;r<h.length;r++){const e=h[r];for(const t of e){g+=this.brailleToDots(t).filter(e=>1===e).length}}for(let r=0;r<h.length;r++){const e=h[r];if(!e)continue;if(!Array.from(e).some(e=>{const t=e.charCodeAt(0);return t>=10240&&t<=10495}))continue;const t=n.card_height-n.top_margin-r*n.line_spacing+n.braille_y_adjust,s=Array.from(e);for(let r=0;r<s.length&&r<n.grid_columns-2;r++){const e=s[r],a=this.brailleToDots(e),l=n.indicator_shapes?1:0,d=n.left_margin+(r+l)*n.cell_spacing+n.braille_x_adjust;for(let r=0;r<a.length;r++)if(1===a[r]){const e=this.dotPositions[r],s=d+m[e[1]],a=t+u[e[0]],l=n.card_thickness+n.active_dot_height/2,h=this.createBrailleDot(s,a,l,n);if(c.push(new i(h)),_++,_%10==0||_===g){const e=10+_/g*80;o(Math.min(90,e),`Processing dots: ${_}/${g}`),_%50==0&&await new Promise(e=>setTimeout(e,0))}}}}o(90,"Combining geometry...");let p=d;for(let r=0;r<c.length;r+=20){const e=c.slice(r,r+20);for(const r of e)try{p=this.evaluator.evaluate(p,r,s)}catch(f){}const t=90+(r+e.length)/c.length*10;o(Math.min(100,t),"Combining geometry..."),await new Promise(e=>setTimeout(e,0))}return o(100,"Card generation complete!"),p.geometry}async generateCylinder(t,r={}){const n=new l(r),o=r.onProgress||(()=>{}),a={diameter_mm:31.35,height_mm:n.card_height,...r.cylinder_params},d=a.diameter_mm,c=a.height_mm,h=d/2;o(10,"Creating cylinder shell...");const m=new e(h,h,c,48);m.translate(0,c/2,0);const u=new i(m);o(20,"Processing braille text for cylinder...");const g=[];for(let e=0;e<Math.min(t.length,n.grid_rows);e++){const r=t[e]||"";g.push(r.trim())}const _=n.dot_spacing/h,p=n.cell_spacing/h,f=[-_/2,_/2],y=[n.dot_spacing,0,-n.dot_spacing],b=-((n.grid_columns-1)*n.cell_spacing/h)/2,w=[];let E=0,x=0;for(const e of g)for(const t of e){E+=this.brailleToDots(t).filter(e=>1===e).length}for(let e=0;e<g.length;e++){const t=g[e];if(!t)continue;if(!Array.from(t).some(e=>{const t=e.charCodeAt(0);return t>=10240&&t<=10495}))continue;const r=c-n.top_margin-e*n.line_spacing+n.braille_y_adjust,s=Array.from(t);for(let e=0;e<s.length&&e<n.grid_columns-2;e++){const t=s[e],a=this.brailleToDots(t),l=b+e*p;for(let e=0;e<a.length;e++)if(1===a[e]){const t=this.dotPositions[e],s=l+f[t[1]],a=r+y[t[0]],d=h+n.active_dot_height/2,c=d*Math.cos(s),m=d*Math.sin(s),u=this.createBrailleDot(c,a,m,n);if(w.push(new i(u)),x++,x%10==0||x===E){const e=20+x/E*60;o(Math.min(80,e),`Processing cylinder dots: ${x}/${E}`)}}}}o(80,"Combining cylinder geometry...");let v=u;for(let e=0;e<w.length;e+=15){const t=w.slice(e,e+15);for(const e of t)try{v=this.evaluator.evaluate(v,e,s)}catch(T){}const r=80+(e+t.length)/w.length*20;o(Math.min(100,r),"Combining cylinder geometry..."),await new Promise(e=>setTimeout(e,0))}return o(100,"Cylinder generation complete!"),v.geometry}dispose(){}}class c{constructor(){}exportBinary(e){if(!e)throw new Error("No geometry provided for STL export");const t=e.attributes.position.array,r=e.attributes.normal?.array,n=e.index?.array,o=n?n.length/3:t.length/9,i=new ArrayBuffer(84+50*o),s=new DataView(i),a="Braille STL Generator v2.0 - Cloudflare Pages Edition";for(let d=0;d<80;d++)s.setUint8(d,d<53?a.charCodeAt(d):0);s.setUint32(80,o,!0);let l=84;for(let d=0;d<o;d++){const e=n?n[3*d]:3*d,o=n?n[3*d+1]:3*d+1,i=n?n[3*d+2]:3*d+2,a=r?this.getVertexNormal(r,e):this.calculateNormal(t,e,o,i);s.setFloat32(l,a.x,!0),s.setFloat32(l+4,a.y,!0),s.setFloat32(l+8,a.z,!0),l+=12,this.writeVertex(s,l,t,e),l+=12,this.writeVertex(s,l,t,o),l+=12,this.writeVertex(s,l,t,i),l+=12,s.setUint16(l,0,!0),l+=2,d%1e3==0&&d>0&&setTimeout(()=>{},0)}return i}exportASCII(e){const t=e.attributes.position.array,r=e.attributes.normal?.array,n=e.index?.array,o=n?n.length/3:t.length/9;let i="solid BrailleSTLGenerator\n";for(let s=0;s<o;s++){const e=n?n[3*s]:3*s,o=n?n[3*s+1]:3*s+1,a=n?n[3*s+2]:3*s+2,l=r?this.getVertexNormal(r,e):this.calculateNormal(t,e,o,a);i+=`  facet normal ${l.x.toExponential()} ${l.y.toExponential()} ${l.z.toExponential()}\n`,i+="    outer loop\n";const d=this.getVertex(t,e),c=this.getVertex(t,o),h=this.getVertex(t,a);i+=`      vertex ${d.x.toExponential()} ${d.y.toExponential()} ${d.z.toExponential()}\n`,i+=`      vertex ${c.x.toExponential()} ${c.y.toExponential()} ${c.z.toExponential()}\n`,i+=`      vertex ${h.x.toExponential()} ${h.y.toExponential()} ${h.z.toExponential()}\n`,i+="    endloop\n",i+="  endfacet\n"}return i+="endsolid BrailleSTLGenerator\n",i}writeVertex(e,t,r,n){e.setFloat32(t,r[3*n],!0),e.setFloat32(t+4,r[3*n+1],!0),e.setFloat32(t+8,r[3*n+2],!0)}getVertex(e,t){return new n(e[3*t],e[3*t+1],e[3*t+2])}calculateNormal(e,t,r,o){const i=new n(e[3*t],e[3*t+1],e[3*t+2]),s=new n(e[3*r],e[3*r+1],e[3*r+2]),a=new n(e[3*o],e[3*o+1],e[3*o+2]),l=s.clone().sub(i),d=a.clone().sub(i);return l.cross(d).normalize()}getVertexNormal(e,t){return new n(e[3*t],e[3*t+1],e[3*t+2])}validateGeometry(e){if(!e)throw new Error("Geometry is null or undefined");if(!e.attributes.position)throw new Error("Geometry missing position attribute");const t=e.attributes.position.array;if(0===t.length)throw new Error("Geometry has no vertices");if(t.length%3!=0)throw new Error("Invalid position data - not divisible by 3");return!0}getStats(e){const t=e.attributes.position.array,r=e.index?.array,n=t.length/3,o=r?r.length/3:n/3;return{vertices:n,triangles:o,estimatedFileSize:84+50*o,hasNormals:!!e.attributes.normal,hasIndices:!!e.index}}}let h=null,m=null,u=null;const g={initialized:!1,busy:!1,lastJobId:null};function _(){if(!g.initialized)throw new Error("Worker not initialized. Call INIT first.");if(!h||!m)throw new Error("Required libraries not loaded")}self.addEventListener("message",async e=>{const{type:t,data:r,id:n}=e.data;try{switch(t){case"INIT":await async function(e){try{h=new d,m=new c,g.initialized=!0,self.postMessage({type:"READY",id:e,capabilities:{brailleGeneration:!0,stlExport:!0,cardGeneration:!0,cylinderGeneration:!0}})}catch(t){throw new Error(`Worker initialization failed: ${t.message}`)}}(n);break;case"GENERATE_CARD":await async function(e,t){_();const{brailleLines:r,options:n={}}=e;if(!r||!Array.isArray(r))throw new Error("Invalid brailleLines provided - expected array of braille Unicode strings");g.busy=!0,g.lastJobId=t,u={type:"card",id:t,startTime:Date.now()};const o=(e,r=null)=>{g.lastJobId===t&&self.postMessage({type:"PROGRESS",id:t,progress:Math.min(100,Math.max(0,e)),message:r||`Processing braille dots: ${Math.round(e)}%`,stage:"generation"})};try{o(5,"Initializing card generation...");const e=await h.generateCard(r,{...n,onProgress:(e,t)=>{o(e,t)}});if(g.lastJobId!==t)return;const i={vertices:e.attributes.position.count,faces:e.index?e.index.count/3:e.attributes.position.count/3,processingTime:Date.now()-u.startTime};self.postMessage({type:"GENERATION_COMPLETE",id:t,result:{geometry:{positions:e.attributes.position.array,normals:e.attributes.normal?.array,indices:e.index?.array},stats:i}})}finally{g.busy=!1,u=null}}(r,n);break;case"GENERATE_CYLINDER":await async function(e,t){_();const{brailleLines:r,options:n={}}=e;if(!r||!Array.isArray(r))throw new Error("Invalid brailleLines provided - expected array of braille Unicode strings");g.busy=!0,g.lastJobId=t,u={type:"cylinder",id:t,startTime:Date.now()};const o=(e,r=null)=>{g.lastJobId===t&&self.postMessage({type:"PROGRESS",id:t,progress:Math.min(100,Math.max(0,e)),message:r||`Generating cylinder: ${Math.round(e)}%`,stage:"generation"})};try{o(10,"Initializing cylinder generation...");const e=await h.generateCylinder(r,{...n,onProgress:(e,t)=>{o(e,t)}});if(g.lastJobId!==t)return;const i={vertices:e.attributes.position.count,faces:e.index?e.index.count/3:e.attributes.position.count/3,processingTime:Date.now()-u.startTime};self.postMessage({type:"GENERATION_COMPLETE",id:t,result:{geometry:{positions:e.attributes.position.array,normals:e.attributes.normal?.array,indices:e.index?.array},stats:i}})}finally{g.busy=!1,u=null}}(r,n);break;case"EXPORT_STL":await async function(e,t){_();const{geometry:r,format:n="binary"}=e;g.busy=!0,u={type:"export",id:t,startTime:Date.now()};const o=(e,r=null)=>{g.lastJobId===t&&self.postMessage({type:"PROGRESS",id:t,progress:e,message:r||`Exporting STL: ${Math.round(e)}%`,stage:"export"})};try{o(10,"Preparing geometry for export...");const e=await async function(e){const t=globalThis.THREE||await function(e,t){let r=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const e=document.querySelector("meta[property=csp-nonce]"),n=e?.nonce||e?.getAttribute("nonce");r=Promise.allSettled(t.map(e=>{if((e=function(e){return"/"+e}(e))in a)return;a[e]=!0;const t=e.endsWith(".css"),r=t?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${e}"]${r}`))return;const o=document.createElement("link");return o.rel=t?"stylesheet":"modulepreload",t||(o.as="script"),o.crossOrigin="",o.href=e,n&&o.setAttribute("nonce",n),document.head.appendChild(o),t?new Promise((t,r)=>{o.addEventListener("load",t),o.addEventListener("error",()=>r(new Error(`Unable to preload CSS for ${e}`)))}):void 0}))}function n(e){const t=new Event("vite:preloadError",{cancelable:!0});if(t.payload=e,window.dispatchEvent(t),!t.defaultPrevented)throw e}return r.then(t=>{for(const e of t||[])"rejected"===e.status&&n(e.reason);return e().catch(n)})}(()=>import("./chunks/three-zd0udLjK.js"),[]),r=new t.BufferGeometry;e.positions&&r.setAttribute("position",new t.BufferAttribute(e.positions,3));e.normals&&r.setAttribute("normal",new t.BufferAttribute(e.normals,3));e.indices&&r.setIndex(new t.BufferAttribute(e.indices,1));return r}(r);o(30,"Validating geometry...");if(!m.validateGeometry(e))throw new Error("Geometry validation failed");let i;if(o(50,`Exporting to ${n} format...`),"binary"===n)i=m.exportBinary(e);else{if("ascii"!==n)throw new Error(`Unsupported export format: ${n}`);i=m.exportASCII(e)}o(90,"Export complete, preparing download...");const s=m.getStats(e);o(100,"STL export ready!");const l="binary"===n?[i]:[];self.postMessage({type:"EXPORT_COMPLETE",id:t,result:{data:i,format:n,stats:{...s,processingTime:Date.now()-u.startTime}}},l)}finally{g.busy=!1,u=null}}(r,n);break;case"CANCEL":await async function(e){u&&u.id===e&&(g.lastJobId=null,u=null,g.busy=!1,self.postMessage({type:"CANCELLED",id:e}))}(n);break;case"GET_STATUS":!function(e){self.postMessage({type:"STATUS",id:e,status:{...g,currentJob:u?{type:u.type,id:u.id,duration:Date.now()-u.startTime}:null,memoryUsage:performance.memory?{used:performance.memory.usedJSHeapSize,total:performance.memory.totalJSHeapSize,limit:performance.memory.jsHeapSizeLimit}:null}})}(n);break;default:throw new Error(`Unknown message type: ${t}`)}}catch(o){self.postMessage({type:"ERROR",id:n,error:{message:o.message,stack:o.stack,name:o.name}})}}),self.addEventListener("error",e=>{self.postMessage({type:"ERROR",error:{message:e.message,filename:e.filename,lineno:e.lineno,colno:e.colno}})}),self.addEventListener("unhandledrejection",e=>{self.postMessage({type:"ERROR",error:{message:e.reason.message||"Unhandled promise rejection",stack:e.reason.stack}})});
