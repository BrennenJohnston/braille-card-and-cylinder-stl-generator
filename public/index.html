<!-- VERSION: 2024-12-19-revised -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Custom Braille STL Generator</title>
    <link rel="icon" href="/static/favicon.svg" type="image/svg+xml">
    <link rel="alternate icon" href="/favicon.ico" sizes="any">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

    <!-- Unsupported browser fallback - runs only if ES6 modules are not supported -->
    <script nomodule>
        document.addEventListener('DOMContentLoaded', function() {
            var banner = document.createElement('div');
            banner.id = 'unsupported-browser-banner';
            banner.setAttribute('role', 'alert');
            banner.innerHTML = [
                '<div style="background:#fee2e2;border:2px solid #b91c1c;padding:1.5em;margin:1em;border-radius:8px;text-align:center;font-family:sans-serif;">',
                '<strong style="color:#b91c1c;font-size:1.2em;">Browser Not Supported</strong>',
                '<p style="margin:0.5em 0;">This application requires a modern browser with ES6 module support.</p>',
                '<p style="margin:0.5em 0;">Please upgrade to the latest version of Chrome, Firefox, Safari, or Edge.</p>',
                '</div>'
            ].join('');
            document.body.insertBefore(banner, document.body.firstChild);
        });
    </script>

    <style>
        /* WCAG 1.4.12 Text Spacing Support */
        * {
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .info-panel,
        .grade-selection,
        .line-input-group,
        .expert-settings {
            min-height: fit-content;
            height: auto !important;
        }

        /* Theme CSS Variables */
        :root {
            /* iOS Safe Area Support */
            --vh: 1vh; /* Dynamic viewport height fallback */

            /* Light mode colors */
            --bg-gradient-start: #e0e7ff;
            --bg-gradient-end: #f6f8fa;
            --bg-primary: #fff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --bg-input: #f9fafb;
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --text-tertiary: #666;
            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;
            --border-focus: #3182ce;
            --btn-primary-bg: linear-gradient(90deg, #3182ce 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #2563eb 60%, #4299e1 100%);
            --btn-success-bg: #10b981;
            --btn-success-hover-bg: #059669;
            --btn-secondary-bg: #9ca3af;
            --btn-tertiary-bg: #6b7280;
            --error-bg: #fee2e2;
            --error-border: #fecaca;
            --error-text: #b91c1c;
            --info-bg: #dbeafe;
            --info-border: #93c5fd;
            --info-text: #1e40af;
            --shadow-light: rgba(49,130,206,0.10);
            --shadow-medium: rgba(49,130,206,0.18);
            --stl-mesh-color: #6699cc;
            --stl-background: #f1f5f9;
            --stl-ambient-light: #888888;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.5;
            --stl-directional-intensity: 1.0;
            --scrollbar-width: 18px; /* Form section scrollbar */
            --global-scrollbar-width: 13.5px; /* Global page scrollbar - 25% smaller */
            --scrollbar-arrow-color: #3182ce; /* Light/default arrow color matches scrollbar */
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --bg-gradient-start: #1a202c;
            --bg-gradient-end: #2d3748;
            --bg-primary: #2d3748;
            --bg-secondary: #374151;
            --bg-tertiary: #4a5568;
            --bg-input: #374151;
            --text-primary: #f7fafc;
            --text-secondary: #e2e8f0;
            --text-tertiary: #cbd5e1;
            --border-primary: #4a5568;
            --border-secondary: #718096;
            --border-focus: #63b3ed;
            --btn-primary-bg: linear-gradient(90deg, #4299e1 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #3182ce 60%, #4299e1 100%);
            --btn-success-bg: #059669;
            --btn-success-hover-bg: #047857;
            --btn-secondary-bg: #718096;
            --btn-tertiary-bg: #4a5568;
            --error-bg: #742a2a;
            --error-border: #9b2c2c;
            --error-text: #fed7d7;
            --info-bg: #2c5282;
            --info-border: #3182ce;
            --info-text: #bee3f8;
            --shadow-light: rgba(0,0,0,0.3);
            --shadow-medium: rgba(0,0,0,0.5);
            --stl-mesh-color: #90cdf4;
            --stl-background: #2d3748;
            --stl-ambient-light: #666666;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.6;
            --stl-directional-intensity: 0.9;
            --scrollbar-arrow-color: #63b3ed; /* Bright blue arrows in dark theme */
        }

        /* High contrast mode */
        [data-theme="high-contrast"] {
            --bg-gradient-start: #000000;
            --bg-gradient-end: #000000;
            --bg-primary: #000000; /* Keep black background */
            --bg-secondary: #1a1a1a; /* Keep dark background */
            --bg-tertiary: #2a2a2a; /* Keep dark background */
            --bg-input: #1a1a1a; /* Keep dark background for inputs */
            --text-primary: #02fe05; /* Green instead of white */
            --text-secondary: #02fe05; /* Green instead of white */
            --text-tertiary: #02fe05; /* Green instead of white */
            --border-primary: #ffff00;
            --border-secondary: #00ffff;
            --border-focus: #ff00ff;
            --btn-primary-bg: #02fe05; /* Green */
            --btn-primary-hover-bg: #02fe05; /* Green */
            --btn-success-bg: #02fe05; /* Green */
            --btn-success-hover-bg: #02fe05; /* Green */
            --btn-secondary-bg: #ff6600;
            --btn-tertiary-bg: #ff6600;
            --error-bg: #ff0000;
            --error-border: #ff0000;
            --error-text: #02fe05; /* Green instead of white */
            --info-bg: #0000ff;
            --info-border: #0000ff;
            --info-text: #02fe05; /* Green instead of white */
            --shadow-light: transparent;
            --shadow-medium: transparent;
            --stl-mesh-color: #00ffff; /* Bright cyan for high contrast */
            --stl-background: #000000; /* Keep black background */
            --stl-ambient-light: #666666; /* Reduced ambient light to prevent washing out */
            --stl-directional-light: #e6e6e6; /* Slightly dimmed directional light for better contrast */
            --stl-ambient-intensity: 0.4; /* Lower ambient light intensity */
            --stl-directional-intensity: 0.8; /* Controlled directional light intensity */
            --scrollbar-arrow-color: #02fe05; /* High-contrast arrows */
        }

        /* High contrast mode specific button styling */
        [data-theme="high-contrast"] button[type="submit"] {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] button[type="submit"]:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        /* High contrast mode - Generate STL button state (blue) */
        [data-theme="high-contrast"] #action-btn.generate-state {
            background: #0201fe !important; /* Blue background for generate */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #fdfe00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] #action-btn.generate-state:hover {
            background: #0201fe !important; /* Blue background */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #02fe05 !important; /* Green border on hover */
        }

        /* High contrast mode - Download STL button state (green) */
        [data-theme="high-contrast"] #action-btn.download-state {
            background: #02fe05 !important; /* Green background for download */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] #action-btn.download-state:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        /* High contrast mode - Disabled/Loading state */
        [data-theme="high-contrast"] #action-btn:disabled {
            background: #666666 !important; /* Gray background for disabled */
            color: #cccccc !important; /* Light gray text */
            border: 2px solid #999999 !important; /* Gray border */
            cursor: not-allowed !important;
        }

        [data-theme="high-contrast"] #download-counter-plate-btn {
            background: #ff6600 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] #download-counter-plate-btn:hover {
            background: #ff8800 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        [data-theme="high-contrast"] .expert-toggle-btn,
        [data-theme="high-contrast"] .info-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn:hover,
        [data-theme="high-contrast"] .info-toggle-btn:hover {
            background: #000000 !important; /* Black background on hover */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn.active,
        [data-theme="high-contrast"] .info-toggle-btn.active {
            background: #000000 !important; /* Black background when active */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .font-size-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .font-size-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        [data-theme="high-contrast"] .font-size-btn.reset-btn {
            background: #2a2a2a !important; /* Darker background */
            color: #00ffff !important; /* Cyan text */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .font-size-display {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        /* Apply transition to theme changes */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; /* Ensure all elements include padding/borders in width */
        }

        /* Reduced Motion Support - WCAG 2.1 Requirement */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }

            /* Specifically disable theme transition animations */
            body,
            .container,
            button,
            input,
            select,
            .preview-section,
            .form-section {
                transition: none !important;
            }
        }

        /* Skip Link for Keyboard Navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--border-focus);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 0 0 8px 0;
            z-index: 1000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }



        /* Font Size Controls */
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.4em 0.6em;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .font-size-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            min-width: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .font-size-btn:hover {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px var(--shadow-medium);
        }

        .font-size-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .font-size-btn.reset-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.8em;
        }

        .font-size-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 3.5em;
            text-align: center;
            user-select: none;
        }



        /* Enhanced focus indicators for all interactive elements */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        a:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Ensure proper keyboard navigation visibility */
        *:focus-visible {
            outline: 3px solid var(--border-focus) !important;
            outline-offset: 2px !important;
        }

        /* Mobile-optimized containers */
        @media (max-width: 768px) {
            .main-layout {
                overflow-y: auto; /* Allow main scroll on mobile if needed */
            }

            /* Sticky generate button on mobile */
            .button-row {
                position: sticky;
                bottom: 0;
                background: var(--bg-primary);
                padding: 1em 0;
                margin: 0; /* Avoid horizontal overflow from negative margins */
                padding-left: 1em;
                padding-right: 1em;
                width: 100%;
                box-shadow: 0 -2px 8px var(--shadow-light);
                z-index: 10;
            }
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Fieldset styling */
        fieldset {
            border: none;
            padding: 0;
            margin: 0;
        }

        .line-input-fieldset {
            margin: 0;
        }

        /* Braille preview styles */
        .braille-preview {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
        }

        .preview-heading {
            margin-top: 0;
            color: var(--text-primary);
        }

        .preview-line-success {
            margin: 10px 0;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 5px;
            border: 1px solid var(--border-primary);
        }

        .preview-line-error {
            margin: 10px 0;
            padding: 10px;
            background: var(--error-bg);
            border-radius: 5px;
            border: 1px solid var(--error-border);
            color: var(--error-text);
        }

        .expert-info {
            font-size: 0.9em;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 1em;
            text-align: center;
        }

        /* High contrast text styling */
        [data-theme="high-contrast"] strong,
        [data-theme="high-contrast"] b {
            color: #02fe05 !important; /* Green for bold text */
        }

        [data-theme="high-contrast"] .grade-label[style*="font-weight: 700"] {
            color: #02fe05 !important; /* Green for bold labels */
        }

        [data-theme="high-contrast"] em,
        [data-theme="high-contrast"] i,
        [data-theme="high-contrast"] [style*="font-style: italic"] {
            color: #fdfe00 !important; /* Yellow for italic text */
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-info span {
            color: #fdfe00 !important; /* Yellow for grade info notes */
        }

        [data-theme="high-contrast"] #offset-help {
            color: #fdfe00 !important; /* Yellow for offset help text */
        }

        /* Note styling classes */
        .grade-note,
        .offset-note {
            color: var(--text-tertiary);
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-note,
        [data-theme="high-contrast"] .offset-note {
            color: #fdfe00 !important; /* Yellow for all note text */
        }

        html {
            background: linear-gradient(120deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh; /* Ensure background covers viewport */
            overscroll-behavior: none;
        }

        body {
            background: transparent; /* Inherit gradient from html */
            min-height: 100vh; /* Minimum viewport height, can grow if needed */
            font-family: 'Inter', system-ui, Arial, sans-serif;
            margin: 0;
            display: flex;
            align-items: flex-start; /* Align to top to prevent centering issues */
            justify-content: center;
            padding: 0; /* Remove padding to extend to browser edges */
            /* iOS Safe Area Support - prevent content from being hidden under notch/Dynamic Island */
            padding-top: env(safe-area-inset-top);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            color: var(--text-primary);
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            box-sizing: border-box;
            overflow-x: hidden;
            overflow-y: auto; /* Allow scrolling if content overflows */
            overscroll-behavior: none;
        }

        /* Mobile-specific body adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0; /* Remove padding on mobile too */
                min-height: 100vh;
                overflow-y: auto; /* Allow scrolling on mobile if needed */
                overflow-x: hidden;
                align-items: flex-start; /* Align to top on mobile */
            }
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 2em;
            background: var(--bg-primary);
            border-radius: 0; /* Remove border radius to extend to edges */
            box-shadow: none; /* Remove shadow since we're edge-to-edge */
            padding: 2.5em;
            width: 100%;
            min-height: 100vh; /* Minimum full viewport height, can grow if needed */
            margin: 0;
            overflow-y: auto; /* Allow main scroll if content overflows */
            overflow-x: hidden;
            box-sizing: border-box;
        }

        /* Mobile layout optimization */
        @media (max-width: 768px) {
            .main-layout {
                padding: 1.5em;
                border-radius: 0; /* Remove border radius on mobile too */
                gap: 1.5em;
                box-shadow: none; /* Remove shadow on mobile too */
                min-height: 100vh; /* Minimum full height on mobile */
                overflow-y: auto; /* Allow main scroll on mobile if needed */
                overflow-x: hidden;
            }
        }

        @media (max-width: 480px) {
            .main-layout {
                padding: 1em;
                border-radius: 0; /* Remove border radius on small mobile too */
                gap: 1em;
            }
        }

        /* Title Section - Full Width at Top */
        .title-section {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 1.5em;
            width: 100%;
            flex-wrap: wrap; /* Allow wrapping when space is tight */
            gap: 1rem; /* Add gap for when items wrap */
        }

        .title-section h1 {
            margin: 0;
            display: flex;
            flex-direction: row;
            align-items: baseline;
            gap: 0.4em;
            line-height: 1.1;
            white-space: nowrap;
        }

        .title-line-1 {
            font-size: 19.6pt;
            font-weight: 700;
            color: var(--text-primary); /* Default theme color */
        }

        .title-line-2 {
            font-size: 19.6pt;
            font-weight: 600;
            color: var(--text-secondary); /* Default theme color */
            margin: 0;
        }

        /* High contrast mode - bright violet title */
        [data-theme="high-contrast"] .title-line-1,
        [data-theme="high-contrast"] .title-line-2 {
            color: #fd01fc !important; /* Bright violet for high contrast mode */
        }

        /* Top Accessibility Controls */
        .accessibility-controls-top {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-end;
            gap: 0.8rem;
            margin-left: 1rem;
            flex-wrap: wrap; /* Allow wrapping to prevent overflow on all screen sizes */
            flex-shrink: 1; /* Allow shrinking when needed */
            min-width: 0; /* Allow shrinking below content size */
        }
        /* Ensure theme toggle appears before font-size controls (to the left) */
        .accessibility-controls-top .theme-toggle-section { order: 0; flex-shrink: 0; }
        .accessibility-controls-top .font-size-controls { order: 1; flex-shrink: 0; }
        .accessibility-controls-top .github-link { order: 2; flex-shrink: 0; }
        .accessibility-controls-top .btn-help { order: 3; flex-shrink: 0; }

        /* Content Area - Two Column Layout */
        .content-area {
            display: flex;
            gap: 2.5em;
            width: 100%;
            flex: 1; /* Take remaining space after title */
            min-height: 0; /* Allow shrinking for scrolling to work */
            overflow: visible; /* Allow content to be visible */
        }

        /* Dynamic viewport height for full-height layouts (iOS Safari address bar handling) */
        @supports (height: 100dvh) {
            .content-area {
                min-height: 100dvh;
            }
        }

        @supports not (height: 100dvh) {
            .content-area {
                min-height: calc(var(--vh, 1vh) * 100);
            }
        }

        /* Left Column - Preview Section (45% width) */
        .preview-section {
            flex: 0 0 45%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            /* Make left column independently scrollable without collapsing viewer */
            max-height: none;
            min-height: 0;
            overflow-y: visible;
            -webkit-overflow-scrolling: touch;
            overflow-x: hidden;
            padding-right: 1em; /* Add padding to prevent cutoff */
        }

        /* Right Column - Form Section (55% width) */
        .form-section {
            flex: 0 0 calc(55% - 2em); /* Subtract padding to prevent overflow */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-width: 320px;
            max-width: calc(55% - 2em); /* Prevent form from extending past background */
            /* Make right column independently scrollable - separate from left column */
            max-height: calc(100vh - 10em); /* Account for main-layout padding (5em) and title section (~5em) */
            min-height: 0;
            overflow-y: scroll; /* Enable scrolling for right column menu boxes */
            -webkit-overflow-scrolling: touch;
            overflow-x: hidden; /* Prevent horizontal overflow */
            scrollbar-width: auto; /* Firefox standard scrollbar */
            /* iOS Safe Area Support - ensure bottom buttons are accessible */
            padding-bottom: calc(1em + env(safe-area-inset-bottom));
            scrollbar-color: #3182ce #e2e8f0; /* Firefox: blue thumb on light grey track */
            /* Distinct background for scrollable area */
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.2em;
            border: 1px solid var(--border-secondary);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        /* Custom scrollbar styling for webkit browsers - larger and more visible */
        .form-section::-webkit-scrollbar {
            width: var(--scrollbar-width); /* +~28% width for clearer grab area */
        }

        .form-section::-webkit-scrollbar-track {
            background: #e2e8f0; /* Light grey background */
            border-radius: 8px;
            margin: 4px 0; /* Add some margin at top and bottom */
            border: 2px solid #3182ce; /* Blue border for high visibility */
        }

        .form-section::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #4299e1, #3182ce); /* Bright blue gradient */
            border-radius: 10px;
            border: 2px solid #ffffff; /* White border for strong contrast */
            box-shadow: 0 3px 6px rgba(49, 130, 206, 0.4); /* Blue shadow for depth */
        }

        .form-section::-webkit-scrollbar-thumb:hover {
            background: #2563eb; /* Darker blue on hover */
            border-color: #3182ce; /* Blue border on hover */
            box-shadow: 0 4px 8px rgba(49, 130, 206, 0.6); /* Enhanced shadow on hover */
        }

        /* Global scrollbar styling for main page scrollbar */
        body::-webkit-scrollbar {
            width: var(--global-scrollbar-width);
        }

        /* Use default browser scrollbar arrow buttons (no custom styling) */

        body::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-secondary);
        }

        body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--text-secondary), var(--text-primary));
            border-radius: 10px;
            border: 2px solid var(--bg-primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        body::-webkit-scrollbar-thumb:hover {
            background: var(--text-primary);
            border-color: var(--border-focus);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        /* Dark theme specific scrollbar improvements - Firefox */
        [data-theme="dark"] .form-section {
            scrollbar-color: #63b3ed #2d3748 !important; /* thumb color, track color */
        }

        /* Dark theme specific scrollbar improvements - WebKit (Chrome, Edge, Safari) */
        [data-theme="dark"] .form-section::-webkit-scrollbar-track {
            background: #2d3748 !important; /* Darker background for better contrast */
            border: 1px solid #63b3ed !important; /* Bright blue border for visibility */
            border-radius: 8px !important;
        }

        [data-theme="dark"] .form-section::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #90cdf4, #63b3ed) !important; /* Bright blue gradient */
            border: 2px solid #1a202c !important; /* Very dark border for definition */
            border-radius: 10px !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5) !important; /* Stronger shadow for dark theme */
        }

        [data-theme="dark"] .form-section::-webkit-scrollbar-thumb:hover {
            background: #4299e1 !important; /* Solid bright blue on hover */
            border-color: #63b3ed !important; /* Bright blue border on hover */
            box-shadow: 0 3px 6px rgba(0,0,0,0.6) !important; /* Enhanced shadow on hover */
        }

        [data-theme="dark"] body::-webkit-scrollbar-track {
            background: #2d3748; /* Darker background for better contrast */
            border: 1px solid #63b3ed; /* Bright blue border for visibility */
        }

        [data-theme="dark"] body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #90cdf4, #63b3ed); /* Bright blue gradient */
            border: 2px solid #1a202c; /* Very dark border for definition */
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); /* Stronger shadow for dark theme */
        }

        [data-theme="dark"] body::-webkit-scrollbar-thumb:hover {
            background: #4299e1; /* Solid bright blue on hover */
            border-color: #63b3ed; /* Bright blue border on hover */
            box-shadow: 0 3px 6px rgba(0,0,0,0.6); /* Enhanced shadow on hover */
        }

        /* High contrast: match form-section scrollbar to global scrollbar scheme */
        [data-theme="high-contrast"] .form-section {
            /* Firefox */
            scrollbar-color: var(--text-secondary) var(--bg-tertiary) !important;
        }

        [data-theme="high-contrast"] .form-section::-webkit-scrollbar-track {
            background: var(--bg-tertiary) !important;
            border: 2px solid var(--border-secondary) !important;
            border-radius: 8px !important;
        }

        [data-theme="high-contrast"] .form-section::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--text-secondary), var(--text-primary)) !important;
            border: 2px solid var(--bg-primary) !important;
            border-radius: 10px !important;
            box-shadow: none !important;
        }

        /* Mobile layout - stack columns */
        @media (max-width: 768px) {
            .content-area {
                flex-direction: column;
                gap: 1.5em;
                overflow: visible; /* Allow content to be visible on mobile */
            }

            .preview-section {
                flex: none;
                width: 100%;
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .form-section {
                flex: 1; /* Take remaining space */
                width: 100%;
                max-height: none; /* Remove height restriction on mobile */
                overflow-y: auto; /* Enable scrolling within the container */
                overflow-x: hidden;
                /* Keep scrollable styling on mobile for inner content */
                background: var(--bg-secondary);
                border: 1px solid var(--border-primary);
                border-radius: 12px;
                padding: 1.2em;
                box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            }
        }

        /* Desktop layout - sticky left preview, separate right column scrolling */
        @media (min-width: 769px) {
            .preview-section {
                position: sticky;
                top: 0;
                align-self: flex-start; /* ensure sticky positions relative to content area */
            }

            /* Ensure right column scrolling is properly configured for desktop */
            .form-section {
                max-height: calc(100vh - 10em); /* Account for main-layout padding and title section */
                overflow-y: scroll;
                position: relative; /* For scroll indicator positioning */
            }

            /* Visual scroll indicator - shadow at bottom when scrollable */
            .form-section::after {
                content: '';
                position: sticky;
                bottom: 0;
                left: 0;
                right: var(--scrollbar-width);
                height: 20px;
                background: linear-gradient(to top, var(--bg-secondary), transparent);
                pointer-events: none;
                opacity: 0.8;
            }
        }

        #viewer {
            width: 100%;
            min-width: 0; /* Avoid forcing horizontal scroll on very small devices */
            max-width: 100%;
            height: calc(100vh - 16em); /* Adjust for new layout spacing */
            border-radius: 18px;
            border: 2px solid var(--border-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 4px 24px var(--shadow-light);
            display: flex;
            align-items: center; /* vertically center canvas */
            justify-content: center; /* horizontally center canvas */
            margin: 0 0 1.5em 0;
            transition: box-shadow 0.2s;
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden; /* Ensure content doesn't overflow rounded corners */
            box-sizing: border-box; /* Include border in size calculation */
            position: relative; /* Create positioning context for overlay */
        }

        /* Canvas should fill the content box and be clipped by the rounded frame */
        #viewer canvas {
            position: relative;
            z-index: 1;
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Mobile viewer optimizations */
        @media (max-width: 768px) {
            #viewer {
                height: calc(40vh - 1em); /* Responsive height for tablets - leave more room for content */
                min-width: unset;
                width: 100%;
                max-width: 100%;
                border-radius: 12px;
                margin: 0 0 1em 0;
            }
        }

        @media (max-width: 480px) {
            #viewer {
                height: calc(35vh - 1em); /* Responsive height for phones - more compact */
                border-radius: 12px;
            }
        }
        #viewer:focus-within, #viewer:active {
            box-shadow: 0 8px 32px var(--shadow-medium);
        }

        /* WebGL Error and Recovery Messages */
        .webgl-error,
        .webgl-recovery {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5em;
            text-align: center;
            max-width: 80%;
            z-index: 20;
        }

        .webgl-error strong,
        .webgl-recovery strong {
            color: var(--error-text, #b91c1c);
            display: block;
            margin-bottom: 0.5em;
            font-size: 1.1em;
        }

        .webgl-error p,
        .webgl-recovery p {
            margin: 0.5em 0;
        }

        [data-theme="high-contrast"] .webgl-error,
        [data-theme="high-contrast"] .webgl-recovery {
            background: #1a1a1a;
            border-color: #ffff00;
            color: #02fe05;
        }

        [data-theme="high-contrast"] .webgl-error strong,
        [data-theme="high-contrast"] .webgl-recovery strong {
            color: #ffff00;
        }

        /* Viewer Container - wraps viewer and overlay label */
        .viewer-container {
            position: relative;
            width: 100%;
        }

        /* STL Preview Label - Overlay at top of viewer */
        .stl-preview-label {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            text-align: center;
            padding: 0.5em 0.75em;
            font-size: 0.85em;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px 8px 0 0;
            opacity: 0.95;
        }

        .stl-preview-label strong {
            color: var(--text-primary);
        }

        /* High contrast mode - STL preview label */
        [data-theme="high-contrast"] .stl-preview-label {
            background: #1a1a1a;
            border: 2px solid #ffff00;
            color: #02fe05;
            opacity: 1;
        }

        [data-theme="high-contrast"] .stl-preview-label strong {
            color: #fdfe00;
        }

        /* Preview Display Controls Container - Bottom overlay inside viewer */
        .preview-display-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 15;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 0.6em;
            padding: 0.35em 0.5em;
            background: rgba(var(--bg-secondary-rgb, 30, 41, 59), 0.85);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            border-top: 1px solid var(--border-primary);
            border-radius: 0 0 16px 16px;
            flex-wrap: nowrap;
        }

        /* Preview Control Group (for each setting) */
        .preview-control-group {
            display: flex;
            align-items: center;
            gap: 0.35em;
        }

        .preview-control-label {
            font-size: 0.7em;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
        }

        .preview-stepper {
            display: flex;
            align-items: center;
            gap: 0.2em;
        }

        .preview-stepper-btn {
            min-width: 1.6em !important;
            min-height: 1.6em !important;
            padding: 0.2em 0.35em !important;
            font-size: 0.8em !important;
            border-radius: 4px !important;
        }

        .preview-stepper-value {
            min-width: 5.5em;
            padding: 0.15em 0.3em !important;
            font-size: 0.7em !important;
            text-align: center;
            border-radius: 4px !important;
        }

        [data-theme="high-contrast"] .preview-display-controls {
            background: rgba(0, 0, 0, 0.92) !important;
        }

        [data-theme="high-contrast"] .preview-control-label {
            color: #02fe05 !important;
        }

        [data-theme="light"] .preview-display-controls {
            background: rgba(248, 250, 252, 0.9);
        }

        /* Mobile optimization for preview controls */
        @media (max-width: 768px) {
            .preview-display-controls {
                padding: 0.3em 0.4em;
                gap: 0.4em;
                flex-wrap: wrap;
                justify-content: center;
            }

            .preview-control-group {
                gap: 0.25em;
            }

            .preview-stepper-value {
                min-width: 4.5em;
            }
        }

        @media (max-width: 480px) {
            .preview-display-controls {
                flex-direction: column;
                gap: 0.25em;
                padding: 0.25em;
            }

            .preview-control-group {
                width: 100%;
                justify-content: center;
            }
        }

        h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 0.7em;
            color: var(--text-primary);
            text-align: left;
        }

        /* Mobile heading optimization */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 0.5em;
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
                line-height: 1.3;
            }
        }
        .info-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .info-panel p {
            margin: 0.3em 0;
        }

        /* Link styling for info-panel - Light theme */
        .info-panel a {
            color: #2563eb; /* Blue-600 for good contrast on light backgrounds */
            text-decoration: underline;
            transition: color 0.15s ease;
        }
        .info-panel a:hover {
            color: #1d4ed8; /* Blue-700 for hover state */
        }
        .info-panel a:focus {
            outline: 2px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Link styling for info-panel - Dark theme */
        [data-theme="dark"] .info-panel a {
            color: #93c5fd; /* Blue-300 - light blue for contrast on dark gray (#374151) */
        }
        [data-theme="dark"] .info-panel a:hover {
            color: #bfdbfe; /* Blue-200 - lighter on hover */
        }

        /* Link styling for info-panel - High contrast theme */
        [data-theme="high-contrast"] .info-panel a {
            color: #00ffff; /* Cyan for high visibility */
            text-decoration: underline;
        }
        [data-theme="high-contrast"] .info-panel a:hover {
            color: #ffff00; /* Yellow on hover */
        }

        .grade-selection {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
        }

        /* Mobile grade selection optimization */
        @media (max-width: 768px) {
            .grade-selection {
                padding: 1.2em;
                margin-bottom: 1.2em;
            }
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.6em;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.6em;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--text-secondary);
            padding: 0.5em 0;
            margin: -0.5em 0;
        }

        /* Mobile radio option optimization */
        @media (max-width: 768px) {
            .radio-option {
                padding: 0.8em 0;
                font-size: 1em;
                gap: 0.8em;
            }

            .radio-option input[type="radio"] {
                width: 20px;
                height: 20px;
                min-width: 20px;
                min-height: 20px;
            }
        }
        .radio-option input[type="radio"] {
            margin: 0;
            cursor: pointer;
        }
        .radio-text {
            cursor: pointer;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 1.1em;
        }
        .line-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
        }
        .line-input {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.8em;
        }
        .line-translation-row,
        .line-text-row {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.4em;
        }
        .line-text-row input[type="text"] {
            width: 100%;
        }
        /* Ensure even vertical spacing between each manual line group */
        #dynamic-line-inputs {
            display: flex;
            flex-direction: column;
            gap: 1em;
        }
        /* Normalize label spacing within rows */
        .line-translation-row .line-label,
        .line-text-row .line-label {
            margin: 0;
        }

        /* Mobile line input optimization */
        @media (max-width: 768px) {
            .line-input {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5em;
            }

            .line-label {
                font-size: 0.95em;
                font-weight: 600;
                margin-bottom: 0.2em;
            }
        }
        /* Placement mode toggle: allow wrapping to avoid right cutoff on small screens */
        .line-input-mode-toggle {
            flex-wrap: wrap; /* New: allow items to wrap onto next line */
        }
        /* Put the "Placement Mode:" label on its own line when needed */
        .line-input-mode-toggle > .line-label {
            flex-basis: 100%;
            margin-bottom: 0.2em !important; /* override inline margin */
        }
        @media (max-width: 768px) {
            .line-input-mode-toggle {
                gap: 0.6em; /* slightly tighter gap on mobile */
            }
            .line-input-mode-toggle > * {
                min-width: 0; /* allow flex children to shrink properly */
            }
            .line-input-mode-toggle label {
                max-width: 100%;
                white-space: normal; /* allow label text to wrap */
            }
        }
        .line-label {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 60px;
            font-size: 0.9em;
        }
        input[type="text"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Mobile-friendly input styles */
        @media (max-width: 768px) {
            input[type="text"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
            }
        }
        input[type="text"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }

        /* Ensure number inputs are properly styled and functional */
        input[type="number"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            min-width: 80px;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            appearance: none;
        }

        /* Remove spinner buttons */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Mobile-friendly number input styles */
        @media (max-width: 768px) {
            input[type="number"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
                width: 100%;
                min-width: unset;
            }
        }

        input[type="number"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }

        input[type="number"]:hover {
            border-color: var(--border-primary);
        }

        /* Language select dropdown styling */
        .language-select {
            width: 100%;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%23666" d="M0 0l6 6 6-6z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.8em center;
            background-size: 12px;
            padding-right: 2.5em;
        }

        /* Mobile select optimization */
        @media (max-width: 768px) {
            .language-select {
                padding: 1em;
                padding-right: 3em;
                font-size: 16px;
                min-height: 48px;
            }
        }

        .language-select:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }

        .language-select:hover {
            border-color: var(--border-primary);
        }

        /* High contrast mode select styling */
        [data-theme="high-contrast"] .language-select {
            background: #1a1a1a !important;
            color: #ffffff !important;
            border: 2px solid #ffff00 !important;
        }

        [data-theme="high-contrast"] .language-select:focus {
            background: #2a2a2a !important;
            color: #ffffff !important;
            border: 2px solid #ff00ff !important;
        }

        [data-theme="high-contrast"] .language-select option {
            background: #1a1a1a !important;
            color: #ffffff !important;
        }

        [data-theme="high-contrast"] .language-select optgroup {
            background: #2a2a2a !important;
            color: #ffff00 !important;
            font-weight: bold;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
            margin-top: 1em;
        }
        button {
            border: none;
            border-radius: 8px;
            padding: 0.7em 1em;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            line-height: 1.2;
            white-space: nowrap;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        /* Mobile-friendly button styles */
        @media (max-width: 768px) {
            button {
                padding: 1em 1.2em;
                font-size: 1.1em;
                min-height: 48px;
                min-width: 48px;
                white-space: normal; /* Allow wrapping on small screens */
            }
        }
        button[type="submit"] {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        button[type="submit"]:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }

        /* Action button state styles */
        #action-btn {
            transition: all 0.3s ease;
            min-width: 140px;
            text-align: center;
            font-size: 0.95em;
        }

        #action-btn.generate-state {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        #action-btn.generate-state:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }

        #action-btn.download-state {
            background: var(--btn-success-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        #action-btn.download-state:hover {
            background: var(--btn-success-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }

        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            margin-bottom: 1em;
            flex-wrap: wrap;
        }

        /* Mobile button row optimization */
        @media (max-width: 768px) {
            .button-row {
                gap: 0.8em;
                justify-content: stretch;
            }

            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }

        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }

            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }


        #download-counter-plate-btn {
            background: var(--btn-tertiary-bg);
            color: #fff;
        }
        #download-counter-plate-btn:hover {
            background: var(--btn-tertiary-bg);
            opacity: 0.9;
            transform: translateY(-2px) scale(1.03);
        }
        #error-message {
            color: var(--error-text);
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            border-radius: 6px;
            padding: 0.9em 1.2em;
            margin: 0;
            font-size: 1.25em;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 0.7em;
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            width: 100%;
            text-align: center;
            z-index: 2;
            pointer-events: none;
            box-shadow: 0 6px 20px var(--shadow-light);
            box-sizing: border-box;
        }

        #error-message.info {
            color: var(--info-text);
            background: var(--info-bg);
            border: 1px solid var(--info-border);
        }

        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }

        .expert-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5em;
            transition: background 0.2s, border-color 0.2s;
            width: 100%;
        }

        .expert-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }

        .expert-toggle-btn.active {
            background: #1e4976; /* Darker blue for WCAG AA contrast (6.1:1 with white) */
            color: #fff;
            border-color: #1e4976;
        }

        .expert-toggle-btn.active #expert-toggle-text {
            color: #fff;
        }

        /* Dark mode: Use darker blue for active state to ensure contrast */
        [data-theme="dark"] .expert-toggle-btn.active {
            background: #1e5a8a; /* Darker blue for WCAG AA contrast (4.7:1 with white) */
            border-color: #1e5a8a;
        }

        [data-theme="dark"] .expert-toggle-btn.active #expert-toggle-text {
            color: #fff;
        }

        .expert-toggle-btn.active #expert-toggle-icon {
            transform: rotate(180deg);
        }

        /* Reset to Defaults button styling */
        .reset-container {
            margin-top: 0.6em;
        }
        .reset-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em 1.2em;
            width: 100%;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .reset-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }
        [data-theme="high-contrast"] .reset-btn {
            background: #1a1a1a !important;
            color: #02fe05 !important;
            border: 2px solid #02fe05 !important;
        }
        [data-theme="high-contrast"] .reset-btn:hover {
            background: #000000 !important;
            color: #02fe05 !important;
            border: 2px solid #02fe05 !important;
        }

        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }

        /* Ensure Expert Mode inputs are properly spaced and visible */
        .expert-settings .grade-selection {
            margin-bottom: 1em;
        }

        .expert-settings input[type="number"] {
            margin-top: 0.3em;
            margin-bottom: 0.5em;
        }

        .expert-settings label {
            display: block;
            margin-bottom: 0.3em;
            font-weight: 500;
            color: var(--text-primary);
        }
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }

        .info-dropdown {
            margin-bottom: 1.5em;
        }

        .info-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }

        .info-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }

        .info-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }

        .info-toggle-btn.active #info-toggle-text {
            color: #fff;
        }

        .info-toggle-btn.active #info-toggle-icon {
            transform: rotate(180deg);
        }

        .info-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        /* Expert submenus */
        .expert-submenu {
            margin-top: 0.8em;
        }
        .expert-submenu-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }
        .expert-submenu-toggle:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }
        .expert-submenu-toggle.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        .expert-submenu-toggle.active .expert-submenu-title {
            color: #fff;
        }
        .expert-submenu-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
        }

        .info-content p {
            margin: 0.3em 0;
        }

        /* Additional mobile optimizations */
        @media (max-width: 768px) {
            .viewer-section, .form-section {
                max-width: 100%;
                min-width: unset;
            }

            .info-panel, .info-content {
                padding: 1.2em;
                font-size: 0.95em;
            }

            .info-toggle-btn, .expert-toggle-btn {
                padding: 1em;
                font-size: 1em;
                min-height: 48px;
            }

            #error-message {
                padding: 1em;
                font-size: 0.95em;
                margin: 0.8em 0;
            }

            .button-group {
                gap: 0.8em;
            }

            /* Mobile optimizations */
            html {
                scroll-behavior: smooth;
            }
        }

        /* Extra small devices */
        @media (max-width: 480px) {
            .expert-settings input[type="number"] {
                width: 100%;
            }

            .font-size-controls {
                transform: scale(0.9);
                transform-origin: top right;
            }
        }



        /* Plate Selection Row Layout */
        .plate-selection-row {
            display: flex;
            align-items: flex-start;
            gap: 1.5em;
            margin-top: 1em;
        }

        .plate-type-selection {
            flex: 1;
            min-width: 250px;
        }

        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            flex-shrink: 0;
        }

        /* Mobile plate selection row optimization */
        @media (max-width: 768px) {
            .plate-selection-row {
                flex-direction: column;
                gap: 1em;
            }

            .plate-type-selection {
                min-width: unset;
                width: 100%;
            }

            .button-row {
                width: 100%;
                justify-content: stretch;
            }

            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }

        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }

            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }

        /* Theme Toggle Section */
        .theme-toggle-section {
            display: flex;
            align-items: center;
            gap: 0.8em;
            margin-left: 0;
        }

        .theme-label-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            color: var(--text-secondary);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.3em;
            min-height: 2.5em;
            box-sizing: border-box;
        }

        .theme-label-text {
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Theme Toggle Button */
        .theme-toggle-btn {
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .theme-toggle-btn:hover {
            background: var(--bg-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .theme-toggle-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .theme-icon {
            font-size: 1.2em;
        }

        /* Medium screens - intermediate breakpoint for controls wrapping */
        @media (max-width: 1024px) {
            .accessibility-controls-top {
                gap: 0.6rem;
            }
            
            .theme-label-box {
                padding: 0.5em 0.8em;
                font-size: 0.85em;
            }
            
            .theme-toggle-btn {
                padding: 0.5em 0.8em;
                font-size: 0.85em;
            }
        }

        /* Mobile title section optimization */
        @media (max-width: 768px) {
            .title-section {
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 1rem;
                margin-bottom: 1em;
            }

            .title-section h1 {
                text-align: center;
                white-space: normal; /* Allow multi-line title on small screens */
                word-break: break-word;
            }

            .title-line-1 {
                font-size: 16pt;
            }

            .title-line-2 {
                font-size: 16pt;
            }

            .accessibility-controls-top {
                margin-left: 0;
                align-items: center;
                flex-wrap: wrap; /* Allow controls to wrap horizontally */
                justify-content: center;
                gap: 0.5rem;
                width: 100%; /* Full width on mobile */
            }

            .theme-toggle-section {
                flex-direction: row; /* Keep horizontal on mobile */
                align-items: center;
                gap: 0.5em;
                margin-left: 0;
                flex-wrap: wrap;
                justify-content: center;
            }

            .theme-label-box {
                font-size: 0.85em;
                min-height: 2.2em;
            }
            
            /* Ensure buttons don't overflow on mobile */
            .github-link,
            .btn-help {
                padding: 0.4rem 0.6rem;
            }
        }

        @media (max-width: 480px) {
            .title-line-1 {
                font-size: 13.6pt;
            }

            .title-line-2 {
                font-size: 13.6pt;
            }
        }

        /* Form Section Accessibility Controls */
        [data-theme="high-contrast"] .theme-label-box {
            background: #1a1a1a !important; /* Dark background for high contrast */
            border: 2px solid #ffff00 !important; /* Yellow border for high contrast */
        }

        [data-theme="high-contrast"] .theme-label-text {
            color: #02fe05 !important; /* Green text for high contrast */
        }

        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow instead of yellow */
            color: #0201fe !important; /* Blue instead of black */
            border: 2px solid #0201fe !important; /* Blue instead of black */
        }

        [data-theme="high-contrast"] input[type="text"],
        [data-theme="high-contrast"] input[type="number"] {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] input[type="text"]:focus,
        [data-theme="high-contrast"] input[type="number"]:focus {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ff00ff !important; /* Magenta border on focus */
        }

        [data-theme="high-contrast"] .info-panel,
        [data-theme="high-contrast"] .grade-selection,
        [data-theme="high-contrast"] .info-content {
            background: #1a1a1a !important; /* Dark background for panels */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .braille-preview {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .preview-line-success {
            background: #2a2a2a !important; /* Darker background */
            color: #02fe05 !important; /* Green text for success */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .preview-line-error {
            background: #ff0000 !important;
            color: #02fe05 !important; /* Green text */
            border: 2px solid #ff0000 !important;
        }

        /* Subline under each preview line for computer shorthand */
        .preview-subline {
            font-size: 0.9em;
            opacity: 0.85;
            margin-top: 0.25em;
        }

        /* Section Title Styling - Larger Font for All Themes */
        .info-panel strong,
        .info-panel p strong {
            font-size: 1.3em !important;
            font-weight: 700 !important;
        }

        #info-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }

        .grade-label {
            font-weight: 600;
            color: var(--text-primary);
            display: block;
            margin-bottom: 0.8em;
            font-size: 1.2em !important; /* Increased from 0.9em */
        }

        .expert-toggle-btn #expert-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }

        /* Auto placement textarea styling to visually align with manual inputs */
        #auto-input-container textarea#auto-text {
            width: 100%;
            min-height: 6.5em; /* approx 4 lines */
            line-height: 1.4;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }
        #auto-input-container textarea#auto-text:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        /* High contrast maintains theme variables already set */

        /* ============================================
           GITHUB LINK BUTTON STYLES
           ============================================ */
        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.8rem;
            border: 2px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            transition: transform 0.15s ease, background-color 0.15s ease;
            min-height: 44px; /* Touch target */
        }

        .github-link:hover {
            transform: scale(1.03);
            background: var(--bg-tertiary);
        }

        .github-link:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .github-icon {
            flex-shrink: 0;
        }

        /* Hide label on small screens */
        @media (max-width: 480px) {
            .github-label {
                display: none;
            }
            .github-link {
                padding: 0.4rem;
            }
        }

        /* ============================================
           HELP BUTTON STYLES
           ============================================ */
        .btn-help {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.8rem;
            border: 2px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.15s ease, background-color 0.15s ease;
            min-height: 44px;
        }

        .btn-help:hover {
            transform: scale(1.03);
            background: var(--bg-tertiary);
        }

        .btn-help:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* High Contrast Mode overrides for GitHub & Help buttons */
        [data-theme="high-contrast"] .github-link,
        [data-theme="high-contrast"] .btn-help {
            border-color: #ffff00;
            background: #000;
            color: #02fe05;
        }

        [data-theme="high-contrast"] .github-link:hover,
        [data-theme="high-contrast"] .btn-help:hover {
            background: #1a1a1a;
        }

        [data-theme="high-contrast"] .github-link:focus,
        [data-theme="high-contrast"] .btn-help:focus {
            outline-color: #ff00ff;
        }

        /* ============================================
           MODAL BASE STYLES
           ============================================ */
        .modal {
            position: fixed;
            inset: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal.hidden {
            display: none;
        }

        .modal-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            position: relative;
            background: var(--bg-primary);
            border-radius: 8px;
            box-shadow: 0 4px 20px var(--shadow-medium);
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-large {
            width: 90%;
            max-width: 800px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.25rem;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 4px;
            color: var(--text-primary);
        }

        .modal-close:hover {
            background: var(--bg-tertiary);
        }

        .modal-close:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .modal-body {
            padding: 1rem 1.5rem;
            overflow-y: auto;
            flex: 1;
            color: var(--text-primary);
        }

        /* Modal link styling - Light theme */
        .modal-body a {
            color: #2563eb; /* Blue-600 for good contrast */
            text-decoration: underline;
            transition: color 0.15s ease;
        }
        .modal-body a:hover {
            color: #1d4ed8; /* Blue-700 for hover */
        }
        .modal-body a:focus {
            outline: 2px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Modal link styling - Dark theme */
        [data-theme="dark"] .modal-body a {
            color: #93c5fd; /* Blue-300 - 6:1+ contrast on dark backgrounds */
        }
        [data-theme="dark"] .modal-body a:hover {
            color: #bfdbfe; /* Blue-200 - lighter on hover */
        }

        /* Modal link styling - High contrast theme */
        [data-theme="high-contrast"] .modal-body a {
            color: #00ffff; /* Cyan for high visibility */
        }
        [data-theme="high-contrast"] .modal-body a:hover {
            color: #ffff00; /* Yellow on hover */
        }

        /* ============================================
           HELP MODAL TAB STYLES
           ============================================ */
        .help-tabs {
            display: flex;
            gap: 0.25rem;
            border-bottom: 2px solid var(--border-primary);
            margin-bottom: 1rem;
            overflow-x: auto;
        }

        .help-tab {
            background: none;
            border: none;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-tertiary);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            white-space: nowrap;
        }

        .help-tab:hover {
            color: var(--text-primary);
        }

        .help-tab[aria-selected="true"] {
            color: var(--border-focus);
            border-bottom-color: var(--border-focus);
        }

        .help-tab:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: -3px;
        }

        .help-panel {
            line-height: 1.6;
        }

        .help-panel[hidden] {
            display: none;
        }

        .help-panel h3 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        .help-panel h4 {
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .help-panel p {
            margin: 0.5rem 0;
        }

        .help-panel ul, .help-panel ol {
            margin: 0.5rem 0;
            padding-left: 1.5em;
        }

        .help-panel li {
            margin: 0.3rem 0;
        }

        /* ============================================
           HELP PANEL CONTENT STYLES
           ============================================ */
        .help-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .help-table th,
        .help-table td {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-primary);
            text-align: left;
        }

        .help-table th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .help-table tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        .example-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .example-box pre {
            background: var(--bg-tertiary);
            padding: 0.75rem;
            border-radius: 4px;
            overflow-x: auto;
            font-family: monospace;
            font-size: 0.9rem;
            margin: 0.5rem 0;
        }

        /* Inline link button style */
        .btn-link {
            background: none;
            border: none;
            color: #2563eb; /* Blue-600 for light theme - 4.7:1 contrast on white */
            text-decoration: underline;
            cursor: pointer;
            font-size: inherit;
            padding: 0;
        }

        .btn-link:hover {
            color: #1d4ed8; /* Blue-700 for hover */
        }

        .btn-link:focus {
            outline: 2px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Dark theme btn-link - higher contrast for dark backgrounds */
        [data-theme="dark"] .btn-link {
            color: #93c5fd; /* Blue-300 - 6:1+ contrast on dark gray */
        }
        [data-theme="dark"] .btn-link:hover {
            color: #bfdbfe; /* Blue-200 - lighter on hover */
        }

        /* ============================================
           HIGH CONTRAST MODE - MODAL
           ============================================ */
        [data-theme="high-contrast"] .modal-content {
            background: #000;
            border: 2px solid #ffff00;
        }

        [data-theme="high-contrast"] .modal-header {
            border-color: #ffff00;
        }

        [data-theme="high-contrast"] .modal-close {
            color: #02fe05;
        }

        [data-theme="high-contrast"] .modal-close:hover {
            background: #1a1a1a;
        }

        [data-theme="high-contrast"] .help-tabs {
            border-color: #ffff00;
        }

        [data-theme="high-contrast"] .help-tab {
            color: #02fe05;
        }

        [data-theme="high-contrast"] .help-tab[aria-selected="true"] {
            color: #ffff00;
            border-bottom-color: #ffff00;
        }

        [data-theme="high-contrast"] .help-table th,
        [data-theme="high-contrast"] .help-table td {
            border-color: #ffff00;
        }

        [data-theme="high-contrast"] .example-box {
            border-color: #00ffff;
        }

        [data-theme="high-contrast"] .btn-link {
            color: #00ffff;
        }

        /* ============================================
           RESPONSIVE - MODAL
           ============================================ */
        @media (max-width: 600px) {
            .modal-content {
                width: 95%;
                max-height: 95vh;
            }
            
            .help-tabs {
                flex-wrap: nowrap;
            }
            
            .help-tab {
                font-size: 0.85rem;
                padding: 0.6rem 0.75rem;
            }
        }
    </style>
</head>
<body>
    <!-- Skip Navigation Link for Keyboard Users -->
    <a href="#main-content" class="skip-link" tabindex="0">Skip to main content</a>



    <main class="main-layout" id="main-content">
        <!-- Title Section at the top -->
        <div class="title-section">
            <h1 id="main-heading">
                <span class="title-line-1">Custom Braille</span>
                <span class="title-line-2">STL Generator</span>
            </h1>

            <!-- Accessibility Controls in top right -->
            <div class="accessibility-controls-top" role="group" aria-label="Accessibility controls">
                <!-- Font Size Controls -->
                <div class="font-size-controls" role="group" aria-label="Font size adjustment">
                    <button id="font-decrease" class="font-size-btn" aria-label="Decrease font size" title="Decrease font size">
                        <span aria-hidden="true">A-</span>
                        <span class="sr-only">Decrease font size</span>
                    </button>
                    <span class="font-size-display" role="status" aria-live="polite" aria-atomic="true">
                        <span id="current-font-size">100</span>%
                    </span>
                    <button id="font-increase" class="font-size-btn" aria-label="Increase font size" title="Increase font size">
                        <span aria-hidden="true">A+</span>
                        <span class="sr-only">Increase font size</span>
                    </button>
                    <button id="font-reset" class="font-size-btn reset-btn" aria-label="Reset font size to default" title="Reset font size to default">
                        <span aria-hidden="true"></span>
                        <span class="sr-only">Reset font size</span>
                    </button>
                </div>

                <!-- Theme Toggle Section -->
                <div class="theme-toggle-section" role="group" aria-labelledby="theme-label">
                    <div id="theme-label" class="theme-label-box">
                        <span class="theme-label-text">Change Theme to </span>
                    </div>
                    <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle theme" title="Toggle between light, dark, and high contrast themes">
                        <span class="theme-icon" aria-hidden="true"></span>
                        <span class="theme-text">High Contrast</span>
                    </button>
                </div>

                <!-- GitHub Link Button -->
                <a href="https://github.com/BrennenJohnston/braille-card-and-cylinder-stl-generator"
                   class="btn btn-sm github-link"
                   target="_blank"
                   rel="noopener noreferrer"
                   aria-label="View source code on GitHub (opens in new tab)"
                   title="View on GitHub">
                    <svg class="github-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                    <span class="github-label">GitHub</span>
                </a>

                <!-- Help Button -->
                <button type="button"
                        id="helpModalBtn"
                        class="btn btn-sm btn-help"
                        aria-label="Open help guide and business card tips"
                        title="Help & Guide">
                    <svg class="btn-icon-svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="11" x2="12" y2="16"></line>
                        <circle cx="12" cy="7.5" r="1" fill="currentColor" stroke="none"></circle>
                    </svg>
                    <span class="btn-text">Help</span>
                </button>
            </div>
        </div>

        <!-- Main Content Area - Two Column Layout -->
        <div class="content-area">
            <!-- Left Column - STL Preview Section (45% width) -->
            <div class="preview-section" role="region" aria-label="3D STL Preview">
                <!-- Viewer Container with Overlay Label -->
                <div class="viewer-container">
                    <!-- STL Preview Label - Positioned as overlay at top of viewer -->
                    <div class="stl-preview-label" id="stl-preview-label" role="note" aria-label="STL Preview information">
                        <strong>3D STL Preview</strong>  Interactive preview only (drag to rotate, scroll to zoom)
                    </div>
                    <div id="viewer" role="img" aria-label="3D preview of braille embossing plate. Interactive 3D model requires mouse or touch to rotate and zoom. Shows raised braille dots on plate surface." aria-describedby="viewer-instructions" tabindex="0">
                        <div id="error-message" role="alert" aria-live="assertive" aria-atomic="true">
                            <span style="font-weight:bold;" aria-hidden="true"></span>
                            <span id="error-text-container" style="display: flex; flex-direction: column; align-items: center;">
                                <span id="error-text"></span>
                                <span id="error-subtext" style="display: none; font-size: 0.8em; margin-top: 0.4em; opacity: 0.85;"></span>
                            </span>
                        </div>
                    </div>
                    <!-- Preview Display Controls - Bottom overlay inside viewer -->
                    <div class="preview-display-controls" role="group" aria-label="Preview display settings">
                        <div class="preview-control-group">
                            <span class="preview-control-label" id="brightness-label">Brightness:</span>
                            <div class="preview-stepper" role="group" aria-labelledby="brightness-label brightness-value">
                                <button type="button" id="brightness-decrease" class="font-size-btn preview-stepper-btn"
                                        aria-label="Decrease brightness" aria-controls="brightness-value">
                                    <span aria-hidden="true"></span>
                                </button>
                                <span class="font-size-display preview-stepper-value" id="brightness-value" role="status" aria-live="polite">Normal</span>
                                <button type="button" id="brightness-increase" class="font-size-btn preview-stepper-btn"
                                        aria-label="Increase brightness" aria-controls="brightness-value">
                                    <span aria-hidden="true">+</span>
                                </button>
                            </div>
                        </div>
                        <div class="preview-control-group">
                            <span class="preview-control-label" id="contrast-label">Contrast:</span>
                            <div class="preview-stepper" role="group" aria-labelledby="contrast-label contrast-value">
                                <button type="button" id="contrast-decrease" class="font-size-btn preview-stepper-btn"
                                        aria-label="Decrease contrast" aria-controls="contrast-value">
                                    <span aria-hidden="true"></span>
                                </button>
                                <span class="font-size-display preview-stepper-value" id="contrast-value" role="status" aria-live="polite">Normal</span>
                                <button type="button" id="contrast-increase" class="font-size-btn preview-stepper-btn"
                                        aria-label="Increase contrast" aria-controls="contrast-value">
                                    <span aria-hidden="true">+</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="viewer-instructions" class="sr-only">
                    To interact with the 3D preview: Use mouse drag to rotate, mouse wheel to zoom. Touch users: one finger to rotate, pinch to zoom. Keyboard users: the visual preview is supplementary; generated STL files contain the same geometry.
                </div>
            </div>

            <!-- Right Column - Form Controls Section (55% width) -->
            <div class="form-section" role="region" aria-label="Braille Card Configuration">
                <div class="info-panel">
                    <p><strong>What Does This Program Do?</strong></p>
                    <p>Generates custom braille embossing plates for standard 3.5  2 business cards. 
                       <a href="https://github.com/BrennenJohnston/braille-card-and-cylinder-stl-generator" target="_blank" rel="noopener noreferrer">View on GitHub</a>
                    </p>
                    
                    <p><strong>Where Do I Start?</strong></p>
                    <p>
                        <button type="button" class="btn-link" onclick="window.openHelpModal('quickstart')">
                            Open the Help Guide 
                        </button>
                    </p>
                </div>

                

                <form id="braille-form" aria-labelledby="main-heading">
                    <!-- Text Input Section moved into form (separate scrollable pane) -->
                    <div class="line-input-group">
                        <fieldset class="line-input-fieldset">
                            <legend class="grade-label">Enter Text for Braille Translation</legend>
                            <div class="grade-note" style="margin-bottom: 0.8em; font-size: 0.85em;">
                                <strong>Note:</strong> Contracted braille combines letters into single cells, so the character limit is only confirmed <em>after translation</em>  the program will warn you automatically if it's too long.
                            </div>
                            <!-- Placement mode toggle -->
                            <div class="line-input-mode-toggle" style="margin-bottom: 0.8em; display: flex; align-items: center; gap: 1em;">
                                <span class="line-label" style="margin: 0;">Placement Mode:</span>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="placement_mode" value="auto" id="placement_mode_auto" checked>
                                    Auto Placement
                                </label>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="placement_mode" value="manual" id="placement_mode_manual">
                                    Manual Placement
                                </label>
                            </div>
                            <!-- Auto placement textarea (hidden by default) -->
                            <div id="auto-input-container" style="display: none;">
                                <label for="auto-text" class="line-label">Auto Placement Text</label>
                                <textarea id="auto-text" rows="4" placeholder="Type all your text here. It will be translated to braille and auto-wrapped across rows based on available cells." style="width: 100%; resize: vertical;" autocomplete="off"></textarea>
                                <div id="auto-overflow-warning" class="grade-note" style="margin-top: 0.6em; color: #d73502; display: none;">
                                    <strong>Warning:</strong> <span id="auto-overflow-message"></span>
                                </div>
                            </div>
                            <!-- Dynamic line inputs container -->
                            <div id="dynamic-line-inputs">
                                <!-- Line inputs will be dynamically generated here based on grid_rows value -->
                            </div>
                            <!-- Capitalized Letters toggle -->
                            <div class="line-input-mode-toggle" style="margin-top: 0.8em; display: flex; align-items: center; gap: 1em;" role="radiogroup" aria-labelledby="caps-toggle-label">
                                <span id="caps-toggle-label" class="line-label" style="margin: 0;">Capitalized Letters:</span>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="capitalize_letters" value="enabled" id="capitalize_enabled" aria-describedby="caps-enabled-desc">
                                    Enabled
                                </label>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="capitalize_letters" value="disabled" id="capitalize_disabled" checked aria-describedby="caps-disabled-desc">
                                    Disabled <span style="font-weight: normal; opacity: 0.85;">(recommended)</span>
                                </label>
                                <span id="caps-enabled-desc" class="sr-only">Preserve capital letters in braille translation, using indicator cells</span>
                                <span id="caps-disabled-desc" class="sr-only">Convert text to lowercase before translation to save space on braille cells. Recommended for names and business cards.</span>
                            </div>
                            <!-- Capitalization warning (shown when caps disabled + uppercase detected) -->
                            <div id="caps-warning" class="grade-note" role="status" aria-live="polite"
                                 style="margin-top: 0.6em; color: #059669; display: none;">
                                <strong>Note:</strong> Capital letters in your text will not be translated because "Capitalized Letters" is disabled. Enable it above if you need capitals in braille.
                            </div>
                        </fieldset>
                    </div>
                    <!-- Language Selection -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Language:</legend>
                            <div style="margin-bottom: 0.8em;">
                                <label for="language-table" class="sr-only">Select braille language table</label>
                                <select id="language-table" name="language_table" class="language-select" aria-describedby="language-help">
                                    <option value="en-ueb-g2.ctb">English (UEB), United States  contracted (grade 2)</option>
                                    <option value="en-ueb-g1.ctb" selected>English (UEB), United States  uncontracted (grade 1)</option>
                                    <option value="en-us-g2.ctb">English (EBAE), United States  contracted (grade 2)</option>
                                    <option value="en-us-g1.ctb">English (EBAE), United States  uncontracted (grade 1)</option>
                                </select>
                                <div id="language-help" class="grade-note" style="margin-top: 6px; font-size: 0.85em;">
                                    Default: English (UEB), United States  uncontracted (grade 1). Chosen to align with BANA guidance for business cards and to minimize ambiguity for names, emails, and short contact info. Use contracted (grade 2) only when space is limited.
                                </div>
                            </div>
                        </fieldset>
                    </div>

                    <!-- Card Thickness Preset Selection -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Card Thickness</legend>
                            <div class="radio-group thickness-toggle" role="radiogroup" aria-required="true" aria-label="Select card thickness preset">
                                <label class="radio-option">
                                    <input type="radio" name="card_thickness_preset" value="0.4" checked aria-describedby="thickness-04-desc">
                                    <span class="radio-text">0.4mm</span>
                                </label>
                                <span id="thickness-04-desc" class="sr-only">Preset settings optimized for 0.4mm layer height printing</span>
                                <label class="radio-option">
                                    <input type="radio" name="card_thickness_preset" value="0.3" aria-describedby="thickness-03-desc">
                                    <span class="radio-text">0.3mm</span>
                                </label>
                                <span id="thickness-03-desc" class="sr-only">Preset settings optimized for 0.3mm layer height printing</span>
                                <label class="radio-option">
                                    <input type="radio" name="card_thickness_preset" value="custom" aria-describedby="thickness-custom-desc">
                                    <span class="radio-text">Custom</span>
                                </label>
                                <span id="thickness-custom-desc" class="sr-only">Custom settings - automatically selected when any parameter is modified from preset values</span>
                            </div>
                            <div class="grade-note" style="margin-top: 6px; font-size: 0.85em;">
                                Selecting a thickness preset will automatically adjust all braille dot and surface parameters to optimal values for that layer height. "Custom" is automatically selected when you modify any parameter.
                            </div>
                        </fieldset>
                    </div>

                    <!-- Plate Type Selection moved here -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Plate to Generate</legend>
                            <div class="radio-group" role="radiogroup" aria-required="true">
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="positive" checked aria-describedby="emboss-plate-desc">
                                    <span class="radio-text">Embossing Plate</span>
                                </label>
                                <span id="emboss-plate-desc" class="sr-only">Creates raised braille dots for embossing cards</span>
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="negative" aria-describedby="counter-plate-desc">
                                    <span class="radio-text">Universal Counter Plate</span>
                                </label>
                                <span id="counter-plate-desc" class="sr-only">Creates recessed dots to support embossing process</span>

                            </div>
                        </fieldset>
                    </div>

                    <!-- Generate STL Button -->
                    <div class="button-row" style="margin-top: 1em; margin-bottom: 1em;">
                        <button type="button" id="action-btn" class="generate-state" aria-label="Generate STL file from entered text" data-state="generate">Generate STL</button>
                    </div>

                    <!-- Reset Settings menu box -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Reset Settings</legend>
                            <div class="reset-container">
                                <button type="button" id="reset-defaults-btn" class="reset-btn" aria-label="Reset all settings to default">Reset all settings to default</button>
                            </div>
                        </fieldset>
                    </div>





                    <div class="expert-mode-toggle">
                        <button type="button" id="expert-toggle" class="expert-toggle-btn"
                                aria-expanded="false" aria-controls="expert-settings">
                            <span id="expert-toggle-text">Show Expert Mode</span>
                            <span id="expert-toggle-icon" aria-hidden="true"></span>
                        </button>
                    </div>

                    <div id="expert-settings" class="expert-settings" style="display: none;">
                        <div class="expert-info" role="note" aria-label="Expert mode information">
                            Any changes made here will affect both plates.
                        </div>

                        <!-- Preview button moved to the top of Expert Mode -->
                        <div style="margin-top: 1em; margin-bottom: 0.5em; text-align: center;">
                            <button type="button" id="preview-braille-btn">Preview Braille Translation</button>
                        </div>

                        <div id="braille-preview" class="braille-preview" style="display: none;" role="region" aria-label="Braille translation preview">
                            <h3 class="preview-heading">Braille Translation Preview:</h3>
                            <div id="preview-content"></div>
                        </div>

                        <!-- Submenu: Shape Selection -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false" aria-controls="expert-panel-shapes">
                                <span class="expert-submenu-title">Shape Selection</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div id="expert-panel-shapes" class="expert-submenu-content" style="display: none;">
                                <!-- Output Shape Selection (moved into Expert Mode) -->
                                <div class="grade-selection">
                                    <fieldset>
                                        <legend class="grade-label">Output Shape (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-required="true">
                                            <label class="radio-option">
                                                <input type="radio" name="shape_type" value="cylinder" checked aria-describedby="cylinder-shape-desc">
                                                <span class="radio-text">Cylinder</span>
                                            </label>
                                            <span id="cylinder-shape-desc" class="sr-only">Creates a cylindrical braille surface</span>
                                            <label class="radio-option" style="opacity: 0.5; cursor: not-allowed;">
                                                <input type="radio" name="shape_type" value="card" disabled aria-describedby="card-shape-desc">
                                                <span class="radio-text">Flat Card <em style="font-size: 0.85em; color: var(--warning-color, #f39c12);">(temporarily disabled)</em></span>
                                            </label>
                                            <span id="card-shape-desc" class="sr-only">Creates a flat rectangular braille card - temporarily disabled</span>
                                        </div>
                                    </fieldset>
                                </div>

                                <!-- Combined Shape Selection (for both Embossing Plate and Counter Plate) -->
                                <div class="grade-selection" id="combined-shape-selection" style="display: block;">
                                    <fieldset>
                                        <legend class="grade-label">Braille Dot Shape (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-required="true">
                                            <label class="radio-option">
                                                <input type="radio" name="combined_shape" value="rounded" aria-describedby="rounded-combined-desc">
                                                <span class="radio-text">Rounded</span>
                                            </label>
                                            <span id="rounded-combined-desc" class="sr-only">Creates rounded dome dots for emboss plate and spherical-cap bowl recess for counter plate</span>
                                            <label class="radio-option">
                                                <input type="radio" name="combined_shape" value="cone" checked aria-describedby="cone-combined-desc">
                                                <span class="radio-text">Cone</span>
                                            </label>
                                            <span id="cone-combined-desc" class="sr-only">Creates cone frustum dots for emboss plate and conical frustum recess for counter plate</span>
                                        </div>
                                    </fieldset>
                                </div>

                                <!-- Hidden radio buttons for backend compatibility -->
                                <div style="display: none;">
                                    <input type="radio" name="dot_shape" value="rounded">
                                    <input type="radio" name="dot_shape" value="cone" checked>
                                    <input type="radio" name="recess_shape" value="1">
                                    <input type="radio" name="recess_shape" value="2" checked>
                                </div>

                                <!-- Indicator Shape toggle -->
                                <div class="grade-selection">
                                    <fieldset>
                                        <legend class="grade-label" style="font-size: 1.2em; font-weight: 700;">Indicator Shapes (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-label="Indicator Shape toggle">
                                            <label class="radio-option">
                                                <input type="radio" name="indicator_shapes" id="indicator_on" value="1" checked>
                                                <span class="radio-text">On</span>
                                            </label>
                                            <label class="radio-option">
                                                <input type="radio" name="indicator_shapes" id="indicator_off" value="0">
                                                <span class="radio-text">Off</span>
                                            </label>
                                        </div>
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            When On: 2 cells are reserved per row for start/end markers. When Off: all cells are available for text.
                                        </div>
                                    </fieldset>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Braille Spacing -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false" aria-controls="expert-panel-spacing">
                                <span class="expert-submenu-title">Braille Spacing</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div id="expert-panel-spacing" class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille Dimensions</label>
                                    <div>
                                        <label for="grid_columns" id="grid_columns_label">Number of Braille Cells (Characters):</label>
                                        <input type="number" id="grid_columns" name="grid_columns" value="11" style="width: 110px;" autocomplete="off">
                                        <div id="grid_columns_note" class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            For embossing plates: 2 cells are reserved for row indicators (start/end markers), leaving 11 cells available for text.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="grid_rows">Number of Braille Lines:</label>
                                        <input type="number" id="grid_rows" name="grid_rows" value="4" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cell_spacing">Braille Cell Spacing:</label>
                                        <input type="number" id="cell_spacing" name="cell_spacing" value="6.5" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="line_spacing">Braille Line Spacing:</label>
                                        <input type="number" id="line_spacing" name="line_spacing" value="10.0" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="dot_spacing">Braille Dot Spacing:</label>
                                        <input type="number" id="dot_spacing" name="dot_spacing" value="2.5" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille / Card Positioning</label>
                                    <div>
                                        <label for="braille_y_adjust">Y Adjust:</label>
                                        <input type="number" id="braille_y_adjust" name="braille_y_adjust" value="0.0" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="braille_x_adjust">X Adjust:</label>
                                        <input type="number" id="braille_x_adjust" name="braille_x_adjust" value="0.0" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Braille Dot Adjustments -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false" aria-controls="expert-panel-dots">
                                <span class="expert-submenu-title">Braille Dot Adjustments</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div id="expert-panel-dots" class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection" id="rounded_dot_group" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Embossing Braille Dot Dimensions (Rounded Shape)</label>
                                    <div>
                                        <label for="rounded_dot_base_diameter">Rounded braille dot base diameter (cone base) (mm):</label>
                                        <input type="number" id="rounded_dot_base_diameter" name="rounded_dot_base_diameter" value="2.0" step="0.1" min="0.5" max="3" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_base_height">Rounded braille dot base height (cone height) (mm):</label>
                                        <input type="number" id="rounded_dot_base_height" name="rounded_dot_base_height" value="0.2" step="0.1" min="0" max="2.0" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_dome_diameter">Rounded braille dome diameter (linked to cone flat top) (mm):</label>
                                        <input type="number" id="rounded_dot_dome_diameter" name="rounded_dot_dome_diameter" value="1.5" step="0.1" min="0.5" max="3.0" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_dome_height">Rounded braille dot dome height (mm):</label>
                                        <input type="number" id="rounded_dot_dome_height" name="rounded_dot_dome_height" value="0.6" step="0.1" min="0.1" max="2.0" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                        The cone base sits on the surface; the dome grows from the cone's flat top. Dome diameter is always equal to the cone flat-top diameter.
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Embossing Braille Dot Dimensions (Cone Shape)</label>
                                    <div>
                                        <label for="emboss_dot_base_diameter">Dot diameter:</label>
                                        <input type="number" id="emboss_dot_base_diameter" name="emboss_dot_base_diameter" value="1.8" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="emboss_dot_height">Dot height:</label>
                                        <input type="number" id="emboss_dot_height" name="emboss_dot_height" value="1.0" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="emboss_dot_flat_hat">Flat hat diameter:</label>
                                        <input type="number" id="emboss_dot_flat_hat" name="emboss_dot_flat_hat" value="0.4" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                </div>

                                <!-- Counter Braille Recessed Dot Dimensions (Rounded Shape) -->
                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Braille Recessed Dot Dimensions (Rounded Shape)</label>
                                    <!-- Hidden hemisphere dial for future use -->
                                    <div style="display: none;">
                                        <label for="hemi_counter_dot_base_diameter">Hemisphere Recess Dot Base Diameter (mm):</label>
                                        <input type="number" id="hemi_counter_dot_base_diameter" name="hemi_counter_dot_base_diameter" value="1.6" step="0.1" min="0.5" max="5" autocomplete="off">
                                    </div>
                                    <div id="hemisphere_dimensions_group" style="margin-top: 6px; display: none;">
                                        <div class="grade-note" style="font-size: 0.85em;">
                                            Hemisphere depth equals radius at the opening.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="bowl_counter_dot_base_diameter">Bowl Recess Dot Base Diameter (mm):</label>
                                        <input type="number" id="bowl_counter_dot_base_diameter" name="bowl_counter_dot_base_diameter" value="1.8" step="0.1" min="0.5" max="5" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div id="bowl_dimensions_group" style="margin-top: 6px;">
                                        <div>
                                            <label for="counter_dot_depth">Bowl Recess Dot Depth (mm):</label>
                                            <input type="number" id="counter_dot_depth" name="counter_dot_depth" value="0.8" step="0.1" min="0" max="5" style="width: 110px;" autocomplete="off">
                                        </div>
                                    </div>
                                </div>

                                <!-- Counter Braille Recessed Dot Dimensions (Cone Shape) -->
                                <div class="grade-selection" id="cone_dimensions_group" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Braille Recessed Dot Dimensions (Cone Shape)</label>
                                    <div>
                                        <label for="cone_counter_dot_base_diameter">Dot Base Diameter (mm):</label>
                                        <input type="number" id="cone_counter_dot_base_diameter" name="cone_counter_dot_base_diameter" value="1.6" step="0.1" min="0.1" max="5" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cone_counter_dot_height">Dot Height (mm):</label>
                                        <input type="number" id="cone_counter_dot_height" name="cone_counter_dot_height" value="0.8" step="0.1" min="0" max="5" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cone_counter_dot_flat_hat">Dot Flat Hat Diameter (mm):</label>
                                        <input type="number" id="cone_counter_dot_flat_hat" name="cone_counter_dot_flat_hat" value="0.4" step="0.1" min="0" max="5" style="width: 110px;" autocomplete="off">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Surface Dimensions -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false" aria-controls="expert-panel-dimensions">
                                <span class="expert-submenu-title">Surface Dimensions</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div id="expert-panel-dimensions" class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Cylinder Dimensions</label>
                                    <div>
                                        <label for="cylinder_diameter_mm">Cylinder Diameter (mm):</label>
                                        <input type="number" id="cylinder_diameter_mm" name="cylinder_diameter_mm" value="30.75" step="0.1" min="10" max="200" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_height_mm">Cylinder Height (mm):</label>
                                        <input type="number" id="cylinder_height_mm" name="cylinder_height_mm" value="52" step="0.1" min="10" max="200" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_polygonal_cutout_radius_mm">Polygonal Cutout Circumscribed Radius (mm):</label>
                                        <input type="number" id="cylinder_polygonal_cutout_radius_mm" name="cylinder_polygonal_cutout_radius_mm" value="13" step="0.1" min="0" max="50" style="width: 110px;" autocomplete="off">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Creates a polygonal cutout along the cylinder's length. Set to 0 for no cutout.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_polygonal_cutout_sides">Polygonal Cutout Points:</label>
                                        <input type="number" id="cylinder_polygonal_cutout_sides" name="cylinder_polygonal_cutout_sides" value="12" step="1" min="3" max="60" style="width: 110px;" autocomplete="off">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Lower values create simpler shapes (e.g., 6); higher values approximate a circle.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="seam_offset_deg">Seam Offset (degrees):</label>
                                        <input type="number" id="seam_offset_deg" name="seam_offset_deg" value="355" step="1" min="0" max="360" style="width: 110px;" autocomplete="off">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Rotates the starting position of braille text around the cylinder
                                        </div>
                                    </div>
                                    <div id="cylinder-overflow-warning" class="grade-note" style="margin-top: 10px; color: #d73502; display: none;">
                                        <strong>Warning:</strong> <span id="cylinder-overflow-message"></span>
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Plate Dimensions</label>
                                    <div>
                                        <label for="card_width">Plate Width:</label>
                                        <input type="number" id="card_width" name="card_width" value="90" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="card_height">Plate Height:</label>
                                        <input type="number" id="card_height" name="card_height" value="52" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="card_thickness">Plate Thickness:</label>
                                        <input type="number" id="card_thickness" name="card_thickness" value="2.0" step="0.1" style="width: 110px;" autocomplete="off">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="button-group">
                        <!-- Test buttons removed as they are no longer needed -->
                    </div>
                </form>
            </div>
        </div>
    </main>



    <!-- Load the real liblouis JavaScript implementation from static files -->
    <script src="/static/liblouis/build-no-tables-utf16.js"></script>
    <script src="/static/liblouis/easy-api.js"></script>

    <script type="module">
        import * as THREE from '/static/three.module.js';
        import { STLLoader } from '/static/STLLoader.js';
        import { OrbitControls } from '/static/OrbitControls.js';

        // Dynamic viewport height fix for iOS Safari (address bar handling)
        function setVH() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // Set on load and resize
        setVH();
        window.addEventListener('resize', setVH);
        window.addEventListener('orientationchange', setVH);

        // Also handle visualViewport if available (more accurate on mobile)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', setVH);
        }

        // Runtime capability checks
        function checkBrowserCapabilities() {
            const issues = [];

            // Check Web Workers
            if (typeof Worker === 'undefined') {
                issues.push('Web Workers are not supported');
            }

            // Check WebAssembly
            if (typeof WebAssembly === 'undefined') {
                issues.push('WebAssembly is not supported');
            }

            // Check WebGL (will be checked again in init3D, but useful to warn early)
            try {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!context) {
                    issues.push('WebGL is not supported');
                }
            } catch (e) {
                issues.push('WebGL is not supported');
            }

            // Check Fetch API
            if (typeof fetch === 'undefined') {
                issues.push('Fetch API is not supported');
            }

            if (issues.length > 0) {
                showCapabilityWarning(issues);
                return false;
            }
            return true;
        }

        function showCapabilityWarning(issues) {
            const errorDiv = document.getElementById('error-message');
            if (errorDiv) {
                errorDiv.innerHTML = `
                    <strong>Limited Browser Support</strong>
                    <p>Your browser is missing features required for full functionality:</p>
                    <ul>${issues.map(i => '<li>' + i + '</li>').join('')}</ul>
                    <p>Some features may not work. Please update your browser for the best experience.</p>
                `;
                errorDiv.style.display = 'block';
            }
        }

        // Call early in initialization (after DOM is ready)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                if (!checkBrowserCapabilities()) {
                    console.warn('Browser capability check failed');
                }
            });
        } else {
            if (!checkBrowserCapabilities()) {
                console.warn('Browser capability check failed');
            }
        }

        async function loadLanguageOptions() {
            const select = document.getElementById('language-table');
            if (!select) return;

            // Preserve the four top U.S. English defaults (UEB and EBAE)
            const defaultValues = new Set(['en-ueb-g2.ctb', 'en-ueb-g1.ctb', 'en-us-g2.ctb', 'en-us-g1.ctb']);
            const defaultOptions = Array.from(select.querySelectorAll('option')).filter(o => defaultValues.has(o.value));

            // Clear existing and re-add defaults in an optgroup
            select.innerHTML = '';
            const defaultGroup = document.createElement('optgroup');
            defaultGroup.label = 'Default';
            defaultOptions.forEach(o => defaultGroup.appendChild(o));
            select.appendChild(defaultGroup);

            // Fetch available tables from backend
            let resp;
            try {
                resp = await fetch('/liblouis/tables', { credentials: 'same-origin' });
            } catch (e) {
                return; // Fail silently; defaults remain
            }
            if (!resp || !resp.ok) return;
            const data = await resp.json().catch(() => null);
            if (!data || !Array.isArray(data.tables)) return;

            // Build label for each entry (native-language autonyms)
            const otherGroup = document.createElement('optgroup');
            otherGroup.label = 'Other';

            const seen = new Set(defaultValues);
            const entries = data.tables.slice();

            // Sort: English first, then by locale and file name
            entries.sort((a, b) => {
                const aEn = (a.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                const bEn = (b.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                if (aEn !== bEn) return aEn - bEn;
                const al = (a.locale || '').toLowerCase();
                const bl = (b.locale || '').toLowerCase();
                if (al !== bl) return al < bl ? -1 : 1;
                const af = (a.file || '').toLowerCase();
                const bf = (b.file || '').toLowerCase();
                return af < bf ? -1 : af > bf ? 1 : 0;
            });

            // Name helpers using Intl.DisplayNames for correctness
            const getLanguageAutonym = (lang) => {
                try {
                    // Use the language's own locale to get its autonym
                    const dn = new Intl.DisplayNames([lang], { type: 'language' });
                    return dn.of(lang) || lang;
                } catch (e) {
                    // Fallback capitalization
                    return lang.charAt(0).toUpperCase() + lang.slice(1);
                }
            };

            const getLanguageEnglish = (lang) => {
                try {
                    const dn = new Intl.DisplayNames(['en'], { type: 'language' });
                    return dn.of(lang) || lang;
                } catch (e) {
                    return lang.charAt(0).toUpperCase() + lang.slice(1);
                }
            };

            const getRegionEnglish = (region) => {
                if (!region) return '';
                try {
                    const dn = new Intl.DisplayNames(['en'], { type: 'region' });
                    return dn.of(region) || region;
                } catch (e) {
                    return region;
                }
            };

            // Helper to get full display name: autonym first, then English
            const getDisplayName = (t) => {
                const locale = (t.locale || '').replace('_', '-');
                const parts = locale.split('-');
                const langCode = (parts[0] || 'und').toLowerCase();
                const region = parts[1] ? parts[1].toUpperCase() : '';

                const auto = getLanguageAutonym(langCode);
                const eng = getLanguageEnglish(langCode);
                const regionEng = getRegionEnglish(region);

                let displayName = auto === eng ? auto : `${auto}  ${eng}`;
                if (regionEng) displayName += `, ${regionEng}`;

                return displayName;
            };

            // Process entries
            const usedSemantic = new Set(); // Deduplicate by semantic identity (locale+variant+grade+type+dots)

            for (const t of entries) {
                const file = t.file;
                if (!file || seen.has(file)) continue;
                seen.add(file);

                // Get base language name
                let baseName = getDisplayName(t);

                // Build description parts
                const parts = [];

                // Grade/contraction info
                if (t.grade === '2') {
                    parts.push('contracted');
                } else if (t.grade === '1') {
                    parts.push('uncontracted');
                } else if (t.grade === '0') {
                    parts.push('computer');
                }

                // Type info
                if (t.type === 'computer' && !parts.includes('computer')) {
                    if (t.dots === 8) {
                        parts.push('8-dot computer');
                    } else {
                        parts.push('computer');
                    }
                } else if (t.type === 'literary' && t.contraction === 'full') {
                    if (!parts.includes('contracted')) {
                        parts.push('literary');
                    }
                }

                // Variant info (UEB, EBAE, etc)
                if (t.variant) {
                    parts.push(t.variant);
                }

                // Special naming for specific files
                if (file === 'en-ueb-g2.ctb') {
                    baseName = 'English (UEB), United States';
                    parts.length = 0;
                    parts.push('contracted', 'grade 2');
                } else if (file === 'en-ueb-g1.ctb') {
                    baseName = 'English (UEB), United States';
                    parts.length = 0;
                    parts.push('uncontracted', 'grade 1');
                } else if (file === 'en-us-g2.ctb') {
                    baseName = 'English (EBAE), United States';
                    parts.length = 0;
                    parts.push('contracted', 'grade 2');
                } else if (file === 'en-us-g1.ctb') {
                    baseName = 'English (EBAE), United States';
                    parts.length = 0;
                    parts.push('uncontracted', 'grade 1');
                } else if (file.includes('-comp')) {
                    if (!parts.includes('computer') && !parts.includes('8-dot computer')) {
                        parts.push('computer braille');
                    }
                }

                // Build final label
                let label = baseName;
                if (parts.length > 0) {
                    label += ` (${parts.join(', ')})`;
                }

                // Deduplicate by semantic identity to avoid near-duplicate entries
                const semanticKey = [
                    (t.locale || '').toLowerCase(),
                    (t.variant || '').toLowerCase(),
                    (t.grade || '').toString().toLowerCase(),
                    (t.type || '').toLowerCase(),
                    (t.dots == null ? '' : String(t.dots))
                ].join('|');
                if (usedSemantic.has(semanticKey)) {
                    continue; // Skip duplicates
                }
                usedSemantic.add(semanticKey);

                const opt = document.createElement('option');
                opt.value = file;
                opt.textContent = label;
                otherGroup.appendChild(opt);
            }

            select.appendChild(otherGroup);

            // Default to UEB grade 1 unless user has a saved preference (business card-friendly)
            try {
                const saved = localStorage.getItem('braille_prefs_language_table');
                const hasSaved = saved && Array.from(select.options).some(o => o.value === saved);
                select.value = hasSaved ? saved : 'en-ueb-g1.ctb';
            } catch (e) {
                select.value = 'en-ueb-g1.ctb';
            }
        }

        // Kick off language options load ASAP
        loadLanguageOptions().then(() => {
            try {
                const select = document.getElementById('language-table');
                // Force default to English (UEB) uncontracted grade 1 if available
                try {
                    const desiredDefault = 'en-ueb-g1.ctb';
                    const hasDesired = Array.from(select.options).some(o => o.value === desiredDefault);
                    if (hasDesired) select.value = desiredDefault;
                } catch (e) {}
                select.addEventListener('change', () => {
                    try { localStorage.setItem('braille_prefs_language_table', select.value); } catch (e) {}
                    // Keep per-line language dropdowns in sync with available options
                    try { syncLineLanguageSelects(); } catch (e) {}
                });
                // Populate per-line selects once options are loaded
                try { syncLineLanguageSelects(); } catch (e) {}
            } catch (e) {}
        });


        // Declare 3D scene variables at module scope
        let renderer, scene, camera, mesh, controls;
        let lastSTLUrl = null;

        // Production logging - only log errors in production
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        const log = {
            debug: isProduction ? () => {} : console.log,
            info: isProduction ? () => {} : console.log,
            warn: isProduction ? () => {} : console.warn, // Warnings suppressed in production
            error: console.error // Always log errors
        };

        // Helper function to sync emboss cone params to counter cone params (module scope)
        function syncEmbossToCounterConeParams() {
            const embossBase = document.getElementById('emboss_dot_base_diameter');
            const embossHeight = document.getElementById('emboss_dot_height');
            const embossFlatHat = document.getElementById('emboss_dot_flat_hat');
            const counterBase = document.getElementById('cone_counter_dot_base_diameter');
            const counterHeight = document.getElementById('cone_counter_dot_height');
            const counterFlatHat = document.getElementById('cone_counter_dot_flat_hat');

            if (embossBase && counterBase) {
                counterBase.value = embossBase.value;
                log.debug('Synced cone_counter_dot_base_diameter to:', embossBase.value);
            }
            if (embossHeight && counterHeight) {
                counterHeight.value = embossHeight.value;
                log.debug('Synced cone_counter_dot_height to:', embossHeight.value);
            }
            if (embossFlatHat && counterFlatHat) {
                counterFlatHat.value = embossFlatHat.value;
                log.debug('Synced cone_counter_dot_flat_hat to:', embossFlatHat.value);
            }
        }

        // Theme switching functionality
        const themes = ['dark', 'high-contrast', 'light'];
        const themeIcons = {
            'dark': '',
            'high-contrast': '',
            'light': ''
        };
        const themeNames = {
            'dark': 'Dark',
            'high-contrast': 'High Contrast',
            'light': 'Light'
        };

        // 
        // CAMERA SETTINGS - Central configuration for STL preview camera positions
        // 
        // These settings control the initial camera position when STL models are generated.
        // Adjust these values to change the default viewing angle for each shape type.
        //
        // Coordinate System:
        //   - Cards: Y-axis is up, camera looks from +Z axis toward origin
        //   - Cylinders: Z-axis is up (cylinder axis), camera looks from XY plane toward origin
        //
        // To rotate the initial view:
        //   - For cylinders: Adjust CYLINDER.position.x and .y to rotate around the Z-axis
        //     Example: { x: -120, y: 0 } views from -X axis (opposite side)
        //     Example: { x: 0, y: 120 } views from +Y axis (90 rotation)
        //   - For cards: Adjust CARD.position values as needed
        //
        // Distance from origin determines zoom level (larger = more zoomed out)
        // 
        const CAMERA_SETTINGS = {
            // Card shape camera settings (standard flat plate)
            CARD: {
                position: { x: 0, y: 0, z: 120 },   // Camera on +Z axis, looking at origin
                up: { x: 0, y: 1, z: 0 },           // Y-axis is up
                target: { x: 0, y: 0, z: 0 },       // Look at origin
                fov: 45,                            // Field of view in degrees
                near: 0.1,                          // Near clipping plane
                far: 1000                           // Far clipping plane
            },
            // Cylinder shape camera settings (cylindrical surface)
            // Camera positioned to view the indicator shapes (triangle/rectangle) side
            CYLINDER: {
                position: { x: -120, y: 0, z: 0 },  // Camera on -X axis (views indicator side)
                up: { x: 0, y: 0, z: 1 },           // Z-axis is up (cylinder axis)
                target: { x: 0, y: 0, z: 0 },       // Look at origin
                fov: 45,                            // Field of view in degrees
                near: 0.1,                          // Near clipping plane
                far: 1000                           // Far clipping plane
            }
        };

        let currentThemeIndex = 0;
        // Always start in dark mode; do not persist theme
        applyTheme('dark');

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);

            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');

            // Find the next theme in the cycle
            const currentIndex = themes.indexOf(theme);
            const nextIndex = (currentIndex + 1) % themes.length;
            const nextTheme = themes[nextIndex];

            // Show the next theme that will be applied when clicked
            themeIcon.textContent = themeIcons[nextTheme];
            themeText.textContent = themeNames[nextTheme];

            // Update aria-label to show current theme and what will happen next
            themeToggle.setAttribute('aria-label', `Current theme: ${themeNames[theme]}. Click to switch to ${themeNames[nextTheme]} theme`);

            // Announce theme change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Theme changed to ${themeNames[theme]}`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);

            // Update 3D scene colors for new theme
            update3DSceneColors();
        }

        document.getElementById('theme-toggle').addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(themes[currentThemeIndex]);
        });

        // Function to update 3D scene colors when theme changes
        function update3DSceneColors() {
            if (typeof scene !== 'undefined' && scene && typeof renderer !== 'undefined' && renderer) {
                const styles = getComputedStyle(document.documentElement);
                const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
                const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
                const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
                const stlMeshColor = styles.getPropertyValue('--stl-mesh-color').trim() || '#6699cc';
                const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
                const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;

                // Update scene background
                scene.background = new THREE.Color(stlBackground);

                // Remove existing lights to rebuild them with proper configuration
                const sceneLightsToRemove = scene.children.filter(child =>
                    child instanceof THREE.DirectionalLight || child instanceof THREE.AmbientLight
                );
                sceneLightsToRemove.forEach(light => scene.remove(light));

                // Also remove camera-attached directional lights
                const cameraLightsToRemove = camera.children.filter(child =>
                    child instanceof THREE.DirectionalLight
                );
                cameraLightsToRemove.forEach(light => camera.remove(light));

                // Rebuild lighting based on current theme
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);

                if (currentTheme === 'high-contrast') {
                    // High contrast mode: conventional three-point lighting for better detail visibility
                    // Key light: 45 horizontal, 30 vertical (right side) - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);

                    // Fill light: 45 horizontal, 15 vertical (left side) for shadow softening - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                    fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                    camera.add(fillLight);

                    // Subtle back light for edge definition - camera-relative
                    const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                    backLight.position.set(0, 0.5, -0.866).normalize();
                    camera.add(backLight);
                } else {
                    // Standard lighting: conventional angle for optimal detail visibility
                    // Key light: 45 horizontal, 30 vertical - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);

                    // Add subtle fill light for standard modes too - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                    fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                    camera.add(fillLight);
                }

                // Add ambient light
                scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));

                // Update mesh color and material properties if mesh exists
                if (mesh && mesh.material) {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    mesh.material.color = new THREE.Color(stlMeshColor);

                    // Update specular properties for high contrast mode
                    if (currentTheme === 'high-contrast') {
                        mesh.material.specular = new THREE.Color(0xffffff); // White specular highlights
                        mesh.material.shininess = 300; // Higher shininess for sharper highlights
                    } else {
                        mesh.material.specular = new THREE.Color(0x111111); // Standard specular
                        mesh.material.shininess = 200; // Standard shininess
                    }

                    mesh.material.needsUpdate = true;
                }

                // Store original light intensities for brightness/contrast adjustments
                if (typeof storeOriginalLightIntensities === 'function') {
                    storeOriginalLightIntensities();
                }

                // Apply current brightness/contrast settings after rebuilding lights
                if (typeof updatePreviewDisplaySettings === 'function') {
                    updatePreviewDisplaySettings();
                }

                // Force a re-render
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }
        }

        // Theme initialization is handled above in the main theme logic

        // 
        // PREVIEW DISPLAY SETTINGS - Brightness and Contrast Controls
        // 
        // These controls adjust the visual appearance of the 3D STL preview only.
        // They do not affect the exported STL file or print results.
        // Stepper buttons adjust the level without cycling past the min/max.
        // 

        // Preview display settings state
        let previewBrightnessLevel = 3; // Default: Normal (1-5 scale)
        let previewContrastLevel = 3;   // Default: Normal (1-5 scale)

        // Brightness multipliers for each level (1-5)
        const BRIGHTNESS_MULTIPLIERS = {
            1: 0.6,   // Very dim
            2: 0.8,   // Dim
            3: 1.0,   // Normal (default)
            4: 1.2,   // Bright
            5: 1.4    // Very bright
        };

        // Contrast settings: [ambient_ratio, directional_ratio, specular_intensity, shininess_offset]
        // Lower ambient + higher directional = higher contrast
        const CONTRAST_SETTINGS = {
            1: { ambientRatio: 1.4, directionalRatio: 0.6, specularIntensity: 0.3, shininessOffset: -80 },  // Very low contrast
            2: { ambientRatio: 1.2, directionalRatio: 0.8, specularIntensity: 0.6, shininessOffset: -40 },  // Low contrast
            3: { ambientRatio: 1.0, directionalRatio: 1.0, specularIntensity: 1.0, shininessOffset: 0 },    // Normal (default)
            4: { ambientRatio: 0.8, directionalRatio: 1.2, specularIntensity: 1.3, shininessOffset: 40 },   // High contrast
            5: { ambientRatio: 0.6, directionalRatio: 1.4, specularIntensity: 1.6, shininessOffset: 80 }    // Very high contrast
        };

        // Brightness and Contrast level names
        const brightnessLevelNames = {
            1: 'Very Dim',
            2: 'Dim',
            3: 'Normal',
            4: 'Bright',
            5: 'Very Bright'
        };
        const contrastLevelNames = {
            1: 'Very Low',
            2: 'Low',
            3: 'Normal',
            4: 'High',
            5: 'Very High'
        };

        function clampPreviewLevel(level) {
            return Math.min(5, Math.max(1, parseInt(level, 10) || 3));
        }

        function getBrightnessMeta(level) {
            const clamped = clampPreviewLevel(level);
            const multiplier = BRIGHTNESS_MULTIPLIERS[clamped] || 1.0;
            return {
                level: clamped,
                name: brightnessLevelNames[clamped] || 'Normal',
                percent: Math.round(multiplier * 100)
            };
        }

        function getContrastMeta(level) {
            const clamped = clampPreviewLevel(level);
            const settings = CONTRAST_SETTINGS[clamped] || CONTRAST_SETTINGS[3];
            const ratioText = `${settings.ambientRatio.toFixed(1)} ambient / ${settings.directionalRatio.toFixed(1)} directional`;
            return {
                level: clamped,
                name: contrastLevelNames[clamped] || 'Normal',
                ratioText
            };
        }

        // Function to update the 3D preview with current brightness and contrast settings
        function updatePreviewDisplaySettings() {
            if (typeof scene === 'undefined' || !scene || typeof renderer === 'undefined' || !renderer) {
                return; // Scene not yet initialized
            }

            const brightnessMultiplier = BRIGHTNESS_MULTIPLIERS[previewBrightnessLevel] || 1.0;
            const contrastSettings = CONTRAST_SETTINGS[previewContrastLevel] || CONTRAST_SETTINGS[3];

            // Get theme-based lighting values
            const styles = getComputedStyle(document.documentElement);
            const baseAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
            const baseDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;

            // Calculate adjusted intensities
            const adjustedAmbientIntensity = baseAmbientIntensity * contrastSettings.ambientRatio * brightnessMultiplier;
            const adjustedDirectionalIntensity = baseDirectionalIntensity * contrastSettings.directionalRatio * brightnessMultiplier;

            // Update ambient lights in scene
            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.intensity = adjustedAmbientIntensity;
                }
            });

            // Update directional lights attached to camera
            if (camera && camera.children) {
                camera.children.forEach(child => {
                    if (child instanceof THREE.DirectionalLight) {
                        // Preserve relative intensity ratios for multi-light setups
                        const originalIntensity = child.userData.originalIntensity || baseDirectionalIntensity;
                        const ratio = originalIntensity / baseDirectionalIntensity;
                        child.intensity = adjustedDirectionalIntensity * ratio;
                    }
                });
            }

            // Also check scene for any directional lights not attached to camera
            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight) {
                    const originalIntensity = child.userData.originalIntensity || baseDirectionalIntensity;
                    const ratio = originalIntensity / baseDirectionalIntensity;
                    child.intensity = adjustedDirectionalIntensity * ratio;
                }
            });

            // Update mesh material properties for contrast
            if (mesh && mesh.material) {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const baseShininess = currentTheme === 'high-contrast' ? 300 : 200;
                const baseSpecular = currentTheme === 'high-contrast' ? 0xffffff : 0x111111;

                // Adjust specular for contrast
                const specularBrightness = Math.min(255, Math.floor(
                    (currentTheme === 'high-contrast' ? 255 : 17) * contrastSettings.specularIntensity
                ));
                mesh.material.specular = new THREE.Color(
                    specularBrightness << 16 | specularBrightness << 8 | specularBrightness
                );
                mesh.material.shininess = Math.max(50, baseShininess + contrastSettings.shininessOffset);
                mesh.material.needsUpdate = true;
            }

            // Force re-render
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Store original intensities when lights are created (used for brightness/contrast adjustments)
        function storeOriginalLightIntensities() {
            if (camera && camera.children) {
                camera.children.forEach(child => {
                    if (child instanceof THREE.DirectionalLight) {
                        child.userData.originalIntensity = child.intensity;
                    }
                });
            }
            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight || child instanceof THREE.AmbientLight) {
                    child.userData.originalIntensity = child.intensity;
                }
            });
        }

        // Apply brightness setting
        function applyPreviewBrightness(level) {
            previewBrightnessLevel = clampPreviewLevel(level);
            updatePreviewDisplaySettings();
            updateBrightnessStepper();
        }

        // Apply contrast setting
        function applyPreviewContrast(level) {
            previewContrastLevel = clampPreviewLevel(level);
            updatePreviewDisplaySettings();
            updateContrastStepper();
        }

        function updateBrightnessStepper() {
            const meta = getBrightnessMeta(previewBrightnessLevel);
            const valueEl = document.getElementById('brightness-value');
            if (valueEl) {
                valueEl.textContent = `${meta.name}`;
                valueEl.setAttribute('title', `${meta.percent}% of base lighting (${meta.name.toLowerCase()})`);
            }

            const decreaseBtn = document.getElementById('brightness-decrease');
            const increaseBtn = document.getElementById('brightness-increase');
            if (decreaseBtn) {
                decreaseBtn.disabled = meta.level <= 1;
                decreaseBtn.setAttribute('aria-label', `Decrease brightness (current ${meta.name})`);
            }
            if (increaseBtn) {
                increaseBtn.disabled = meta.level >= 5;
                increaseBtn.setAttribute('aria-label', `Increase brightness (current ${meta.name})`);
            }
        }

        function updateContrastStepper() {
            const meta = getContrastMeta(previewContrastLevel);
            const valueEl = document.getElementById('contrast-value');
            if (valueEl) {
                valueEl.textContent = `${meta.name}`;
                valueEl.setAttribute('title', meta.ratioText);
            }

            const decreaseBtn = document.getElementById('contrast-decrease');
            const increaseBtn = document.getElementById('contrast-increase');
            if (decreaseBtn) {
                decreaseBtn.disabled = meta.level <= 1;
                decreaseBtn.setAttribute('aria-label', `Decrease contrast (current ${meta.name})`);
            }
            if (increaseBtn) {
                increaseBtn.disabled = meta.level >= 5;
                increaseBtn.setAttribute('aria-label', `Increase contrast (current ${meta.name})`);
            }
        }

        const brightnessDecreaseBtn = document.getElementById('brightness-decrease');
        if (brightnessDecreaseBtn) {
            brightnessDecreaseBtn.addEventListener('click', () => {
                if (previewBrightnessLevel > 1) {
                    applyPreviewBrightness(previewBrightnessLevel - 1);
                }
            });
        }

        const brightnessIncreaseBtn = document.getElementById('brightness-increase');
        if (brightnessIncreaseBtn) {
            brightnessIncreaseBtn.addEventListener('click', () => {
                if (previewBrightnessLevel < 5) {
                    applyPreviewBrightness(previewBrightnessLevel + 1);
                }
            });
        }

        const contrastDecreaseBtn = document.getElementById('contrast-decrease');
        if (contrastDecreaseBtn) {
            contrastDecreaseBtn.addEventListener('click', () => {
                if (previewContrastLevel > 1) {
                    applyPreviewContrast(previewContrastLevel - 1);
                }
            });
        }

        const contrastIncreaseBtn = document.getElementById('contrast-increase');
        if (contrastIncreaseBtn) {
            contrastIncreaseBtn.addEventListener('click', () => {
                if (previewContrastLevel < 5) {
                    applyPreviewContrast(previewContrastLevel + 1);
                }
            });
        }

        // Initialize displays and clamp defaults
        previewBrightnessLevel = clampPreviewLevel(previewBrightnessLevel);
        previewContrastLevel = clampPreviewLevel(previewContrastLevel);
        updateBrightnessStepper();
        updateContrastStepper();

        // Font size adjustment functionality
        const fontSizes = [75, 87.5, 100, 112.5, 125, 150, 175, 200];
        let currentFontSizeIndex = 2; // Start at 100%

        // Check if mobile device
        const isMobile = window.innerWidth <= 768;

        // Always start at default 100%; do not persist font size
        currentFontSizeIndex = 2;

        function applyFontSize(sizeIndex) {
            const size = fontSizes[sizeIndex];
            document.documentElement.style.fontSize = size + '%';
            document.getElementById('current-font-size').textContent = size;
            currentFontSizeIndex = sizeIndex;

            // Announce font size change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Font size changed to ${size}%`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
        }

        // Initialize font size
        applyFontSize(currentFontSizeIndex);

        // Font size control event listeners
        document.getElementById('font-decrease').addEventListener('click', () => {
            if (currentFontSizeIndex > 0) {
                applyFontSize(currentFontSizeIndex - 1);
            }
        });

        document.getElementById('font-increase').addEventListener('click', () => {
            if (currentFontSizeIndex < fontSizes.length - 1) {
                applyFontSize(currentFontSizeIndex + 1);
            }
        });

        document.getElementById('font-reset').addEventListener('click', () => {
            applyFontSize(2); // Reset to 100%
        });

        const form = document.getElementById('braille-form');
        const viewer = document.getElementById('viewer');
        const actionBtn = document.getElementById('action-btn');
        let lastGeneratedSTLUrl = null;
        let lastGeneratedFilename = null;

        const previewBrailleBtn = document.getElementById('preview-braille-btn');
        const errorDiv = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');

        // Function to reset button to generate state
        function resetToGenerateState() {
            actionBtn.textContent = 'Generate STL';
            actionBtn.className = 'generate-state';
            actionBtn.setAttribute('data-state', 'generate');
            actionBtn.setAttribute('aria-label', 'Generate STL file from entered text');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }

        // Function to set button to download state
        function setToDownloadState() {
            actionBtn.textContent = 'Download STL';
            actionBtn.className = 'download-state';
            actionBtn.setAttribute('data-state', 'download');
            actionBtn.setAttribute('aria-label', 'Download generated STL file');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }

        // Store the current plate type for download naming
        let currentPlateType = 'positive';

        // Counter for Universal Counter Plate downloads (session-based, max 999)
        let counterPlateDownloadCounter = 0;
        const COUNTER_PLATE_MAX = 999;

        function getNextCounterPlateNumber() {
            // Increment counter (wraps at max to 1)
            counterPlateDownloadCounter = (counterPlateDownloadCounter % COUNTER_PLATE_MAX) + 1;
            return counterPlateDownloadCounter;
        }

        // Add event handler for the action button
        actionBtn.addEventListener('click', () => {
            if (actionBtn.getAttribute('data-state') === 'generate') {
                form.dispatchEvent(new Event('submit'));
            } else if (actionBtn.getAttribute('data-state') === 'download') {
                // Download the generated STL
                if (lastGeneratedSTLUrl) {
                    const a = document.createElement('a');
                    a.href = lastGeneratedSTLUrl;
                    // Use the filename generated on the frontend
                    if (lastGeneratedFilename) {
                        a.download = lastGeneratedFilename;
                    }
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }
        });
        const expertToggleBtn = document.getElementById('expert-toggle');
        const expertSettings = document.getElementById('expert-settings');
        const expertToggleText = document.getElementById('expert-toggle-text');
        const expertToggleIcon = document.getElementById('expert-toggle-icon');
        const braillePreview = document.getElementById('braille-preview');
        const previewContent = document.getElementById('preview-content');



        // Add event listeners to reset button state when inputs change
        function addInputChangeListeners() {
            // Dynamic text input fields
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                if (input) {
                    // Remove existing listener to prevent duplicates
                    input.removeEventListener('input', resetToGenerateState);
                    input.addEventListener('input', () => {
                        resetToGenerateState();
                        updateCapsWarning();
                    });
                }
            }

            // Language selection
            const languageSelect = document.getElementById('language-table');
            if (languageSelect) {
                languageSelect.addEventListener('change', function() {
                    resetToGenerateState();
                });
            }

            // Function to update grid columns based on plate type (promoted to top-level scope below)
            function updateGridColumnsForPlateType(preserveValue = false) {
                const plateType = document.querySelector('input[name="plate_type"]:checked').value;
                const gridColumnsInput = document.getElementById('grid_columns');
                const gridColumnsLabel = document.getElementById('grid_columns_label');
                const gridColumnsNote = document.getElementById('grid_columns_note');
                const indicatorOn = document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';

                // Store current value before update
                const currentValue = parseInt(gridColumnsInput.value);

                if (plateType === 'positive') {
                    // Embossing plate - available cells depend on indicator toggle
                    gridColumnsLabel.textContent = 'Number of Available Braille Cells:';
                    gridColumnsNote.style.display = 'block';
                    gridColumnsNote.textContent = indicatorOn
                        ? 'For embossing plates: 2 cells are reserved for row indicators (start/end markers).'
                        : 'Indicators off: all columns are available for text.';
                    // Always normalize the dial to the recommended default to avoid drift
                    gridColumnsInput.value = indicatorOn ? '13' : '15';
                } else {
                    // Counter plate - available cells depend on indicator toggle
                    gridColumnsLabel.textContent = 'Available Braille Cells for Text:';
                    gridColumnsNote.textContent = indicatorOn
                        ? 'For counter plates: 2 cells are reserved for row indicators (start/end markers), leaving 13 cells available for text.'
                        : 'Indicators off: all columns are available for text.';
                    gridColumnsNote.style.display = 'block';
                    // Always normalize the dial to the recommended default to avoid drift
                    gridColumnsInput.value = indicatorOn ? '13' : '15';
                }
            }
            // Expose for other handlers safely
            try { window.updateGridColumnsForPlateType = updateGridColumnsForPlateType; } catch (e) {}

            // Plate type radio buttons
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateGridColumnsForPlateType();
                    const combinedShapeSel = document.getElementById('combined-shape-selection');
                    if (combinedShapeSel) { combinedShapeSel.style.display = 'block'; }
                    const roundedGroup = document.getElementById('rounded_dot_group');
                    if (roundedGroup) roundedGroup.style.display = '';
                    if (document.querySelector('input[name="placement_mode"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                });
            });

            // Initialize grid columns on page load
            updateGridColumnsForPlateType();
            // Wire indicator toggle listeners
            document.querySelectorAll('input[name="indicator_shapes"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateGridColumnsForPlateType(true);
                    if (document.querySelector('input[name=\"placement_mode\"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                });
            });

            // Shape type radio buttons
            document.querySelectorAll('input[name="shape_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                    if (document.querySelector('input[name=\"placement_mode\"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                    // Do not persist shape selection; always reset on reload
                });
            });
            // Plate type radio buttons (update dependent UI; recess controls always visible)
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                });
            });

            // Counter plate controls
            const hemiCounterBase = document.getElementById('hemi_counter_dot_base_diameter');
            const bowlCounterBase = document.getElementById('bowl_counter_dot_base_diameter');
            const counterDotDepth = document.getElementById('counter_dot_depth');
            const coneCounterBase = document.getElementById('cone_counter_dot_base_diameter');
            const coneCounterHeight = document.getElementById('cone_counter_dot_height');
            const coneCounterHat = document.getElementById('cone_counter_dot_flat_hat');
            if (hemiCounterBase) hemiCounterBase.addEventListener('input', resetToGenerateState);
            if (bowlCounterBase) bowlCounterBase.addEventListener('input', resetToGenerateState);
            if (counterDotDepth) counterDotDepth.addEventListener('input', resetToGenerateState);
            if (coneCounterBase) coneCounterBase.addEventListener('input', resetToGenerateState);
            if (coneCounterHeight) coneCounterHeight.addEventListener('input', resetToGenerateState);
            if (coneCounterHat) coneCounterHat.addEventListener('input', resetToGenerateState);

            // Combined shape selection - sets both emboss and counter shapes
            document.querySelectorAll('input[name="combined_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    resetToGenerateState();
                    const combinedVal = document.querySelector('input[name="combined_shape"]:checked')?.value || 'cone';
                    const isRounded = combinedVal === 'rounded';
                    const isCone = combinedVal === 'cone';

                    console.log('Combined shape changed to:', combinedVal, 'isRounded:', isRounded, 'isCone:', isCone);

                    // Set emboss plate shape (dot_shape)
                    const dotShapeRadios = document.querySelectorAll('input[name="dot_shape"]');
                    dotShapeRadios.forEach(radio => {
                        if (isRounded && radio.value === 'rounded') {
                            radio.checked = true;
                            console.log('Set dot_shape to rounded');
                        }
                        if (isCone && radio.value === 'cone') {
                            radio.checked = true;
                            console.log('Set dot_shape to cone');
                        }
                    });

                    // Set counter plate shape (recess_shape)
                    const recessShapeRadios = document.querySelectorAll('input[name="recess_shape"]');
                    recessShapeRadios.forEach(radio => {
                        if (isRounded && radio.value === '1') {
                            radio.checked = true; // Bowl (rounded)
                            console.log('Set recess_shape to 1 (bowl)');
                        }
                        if (isCone && radio.value === '2') {
                            radio.checked = true; // Cone
                            console.log('Set recess_shape to 2 (cone)');
                        }
                    });

                    // NOTE: We intentionally do NOT call syncEmbossToCounterConeParams() here.
                    // The thickness presets define different (intentional) values for emboss and counter cone params.
                    // Syncing would overwrite the preset's counter cone values with emboss values, causing the bug
                    // where dimensions are incorrect on first shape switch after changing presets.
                    // The sync is only performed when user manually changes emboss params (see below).

                    // Update dimension groups visibility
                    const bowlGroup = document.getElementById('bowl_dimensions_group');
                    const coneGroup = document.getElementById('cone_dimensions_group');
                    if (bowlGroup) bowlGroup.style.display = '';
                    if (coneGroup) coneGroup.style.display = '';

                    // Debug: Log current values
                    const currentDotShape = document.querySelector('input[name="dot_shape"]:checked')?.value;
                    const currentRecessShape = document.querySelector('input[name="recess_shape"]:checked')?.value;
                    console.log('After sync - dot_shape:', currentDotShape, 'recess_shape:', currentRecessShape);
                });
            });

            // Add listeners to sync emboss cone params to counter cone params when changed
            ['emboss_dot_base_diameter', 'emboss_dot_height', 'emboss_dot_flat_hat'].forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        // Only sync if cone shape is selected
                        const isCone = document.querySelector('input[name="combined_shape"]:checked')?.value === 'cone';
                        if (isCone) {
                            syncEmbossToCounterConeParams();
                        }
                    });
                }
            });

            // Expert mode parametric dials
            const expertInputs = [
                'emboss_dot_base_diameter',
                'emboss_dot_height',
                'emboss_dot_flat_hat',
                'hemi_counter_dot_base_diameter',
                'bowl_counter_dot_base_diameter',
                'counter_dot_depth',
                'cone_counter_dot_base_diameter',
                'cone_counter_dot_height',
                'cone_counter_dot_flat_hat',
                // use_bowl_recess handled via radios
                'rounded_dot_base_diameter',
                'rounded_dot_cylinder_height',
                'rounded_dot_base_height',
                'rounded_dot_dome_diameter',
                'rounded_dot_dome_height',
                'grid_columns',
                'grid_rows',
                'cell_spacing',
                'line_spacing',
                'dot_spacing',
                'card_width',
                'card_height',
                'card_thickness',
                'braille_x_adjust',
                'braille_y_adjust',
                // Custom: indicator shapes toggle changes available cells view
                'indicator_shapes'
            ];

            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        if (inputId === 'indicator_shapes') {
                            updateGridColumnsForPlateType(true);
                        }
                    });
                }
            });

            // Cylinder parameter inputs
            const cylinderInputs = [
                'cylinder_diameter_mm',
                'cylinder_height_mm',
                'cylinder_polygonal_cutout_radius_mm',
                'cylinder_polygonal_cutout_sides',
                'seam_offset_deg'
            ];

            cylinderInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        checkCylinderOverflow();
                    });
                }
            });
        }

        // Function to show/hide cylinder settings based on shape selection
        function updateShapeSettings() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement) {
                console.warn('No shape type selected');
                return;
            }
            const shapeType = shapeTypeElement.value;
            const cylinderSettings = document.querySelector('.grade-selection:has(#cylinder_diameter_mm)');

            // Always show cylinder dimensions in expert mode
            if (cylinderSettings) {
                cylinderSettings.style.display = 'block';
            }
            // Recess controls always visible; toggle sub-groups by chosen recess
            const recessSel = document.getElementById('recess-shape-selection');
            const recessValInit = document.querySelector('input[name="recess_shape"]:checked')?.value || '2';
            const isBowl = recessValInit === '1';
            const isCone = recessValInit === '2';
            if (recessSel) recessSel.style.display = '';
            const bowlGroup = document.getElementById('bowl_dimensions_group');
            const hemiGroup = document.getElementById('hemisphere_dimensions_group');
            const coneGroup = document.getElementById('cone_dimensions_group');
            if (bowlGroup) bowlGroup.style.display = '';
            if (hemiGroup) hemiGroup.style.display = 'none';
            if (coneGroup) coneGroup.style.display = '';

            // Initialize cylinder height with current card height when cylinder is selected
            if (shapeType === 'cylinder') {
                const cardHeight = document.getElementById('card_height').value;
                const cylinderHeightInput = document.getElementById('cylinder_height_mm');
                if (cylinderHeightInput) {
                    cylinderHeightInput.value = cardHeight;
                }
                checkCylinderOverflow();
            }
        }

        // Function to check cylinder text overflow
        function checkCylinderOverflow() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement || shapeTypeElement.value !== 'cylinder') return;
            const shapeType = shapeTypeElement.value;

            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const dotSpacing = parseFloat(document.getElementById('dot_spacing').value) || 2.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;

            // Calculate how many cells fit around circumference
            // cellSpacing is the center-to-center distance between cells
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);

            // Calculate how many rows fit on cylinder
            const rowsOnCylinder = Math.floor(height / lineSpacing);

            // Get total cells needed from text
            const lines = getDynamicLineValues();
            let totalCellsNeeded = 0;
            lines.forEach(line => {
                if (line.trim()) {
                    totalCellsNeeded += line.trim().length;
                }
            });

            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;

            const warningDiv = document.getElementById('cylinder-overflow-warning');
            const warningMessage = document.getElementById('cylinder-overflow-message');

            if (totalCellsNeeded > totalCellsAvailable) {
                warningMessage.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        }

        // Function to create dynamic line inputs based on grid_rows value
        function createDynamicLineInputs(numLines) {
            const container = document.getElementById('dynamic-line-inputs');
            container.innerHTML = ''; // Clear existing inputs

            for (let i = 1; i <= numLines; i++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'line-input';
                lineDiv.innerHTML = `
                    <div class="line-translation-row">
                        <label for="line_lang_${i}" class="line-label">Line ${i} Translation</label>
                        <select id="line_lang_${i}" name="line_lang_${i}" class="language-select line-language-select" aria-describedby="line${i}-lang-help"></select>
                        <span id="line${i}-lang-help" class="sr-only">Select translation language for line ${i}</span>
                    </div>
                    <div class="line-text-row">
                        <label for="line${i}" class="line-label">Line ${i}</label>
                        <input type="text" id="line${i}" name="line${i}" placeholder="Enter English text here..." maxlength="50" aria-describedby="line${i}-help" autocomplete="off">
                        <span id="line${i}-help" class="sr-only">Maximum 50 characters for line ${i}</span>
                    </div>
                `;
                container.appendChild(lineDiv);
            }

            // Populate per-line language selects with available options
            syncLineLanguageSelects();

            // Re-add event listeners for the new inputs
            addInputChangeListeners();
        }

        // Populate all per-line language selects from the master language-table options
        function syncLineLanguageSelects() {
            const master = document.getElementById('language-table');
            if (!master) return;
            const optionsHTML = master.innerHTML;
            const masterValue = master.value;
            document.querySelectorAll('.line-language-select').forEach(sel => {
                const previous = sel.value;
                sel.innerHTML = optionsHTML;
                // Prefer keeping prior choice; otherwise prefer English UEB Grade 1; otherwise fallback to master
                const hasPrev = previous && Array.from(sel.options).some(o => o.value === previous);
                const desiredDefault = 'en-ueb-g1.ctb';
                const hasDesired = Array.from(sel.options).some(o => o.value === desiredDefault);
                sel.value = hasPrev ? previous : (hasDesired ? desiredDefault : masterValue);
            });
        }

        // Function to collect all dynamic line values
        function getDynamicLineValues() {
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            const lines = [];
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                lines.push(input ? input.value : '');
            }
            return lines;
        }

        // When in auto mode, show overall overflow for cylinders too
        const cylinderOverflowDiv = document.getElementById('cylinder-overflow-warning');
        const cylinderOverflowMsg = document.getElementById('cylinder-overflow-message');
        const originalCheckCylinderOverflow = checkCylinderOverflow;
        checkCylinderOverflow = function() {
            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            if (placementMode === 'manual') {
                return originalCheckCylinderOverflow();
            }
            // Auto mode: compute based on auto text
            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);
            const rowsOnCylinder = Math.floor(height / lineSpacing);
            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;
            const src = (document.getElementById('auto-text')?.value || '').trim();
            if (!src) {
                cylinderOverflowDiv.style.display = 'none';
                return;
            }
            // Translate then compare
            translateWithLiblouis(src, 'g2', document.getElementById('language-table')?.value || 'en-ueb-g1.ctb')
                .then(braille => {
                    const totalCellsNeeded = braille.length;
                    if (totalCellsNeeded > totalCellsAvailable) {
                        cylinderOverflowMsg.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                        cylinderOverflowDiv.style.display = 'block';
                    } else {
                        cylinderOverflowDiv.style.display = 'none';
                    }
                })
                .catch(() => {
                    // Ignore
                });
        };

        // Function to add listener for grid_rows changes
        function addGridRowsListener() {
            const gridRowsInput = document.getElementById('grid_rows');
            if (gridRowsInput) {
                gridRowsInput.addEventListener('input', () => {
                    const numLines = parseInt(gridRowsInput.value) || 4;
                    // Enforce only a minimum of 1 line; no artificial upper bound
                    const safeLines = Math.max(1, numLines);
                    if (safeLines !== numLines) {
                        gridRowsInput.value = safeLines;
                    }
                    createDynamicLineInputs(safeLines);
                    resetToGenerateState();
                });
            }
        }

        // Helper function to apply capitalization setting to text before translation
        function applyCapitalizationSetting(text) {
            const capsEnabled = document.querySelector('input[name="capitalize_letters"]:checked')?.value === 'enabled';
            return capsEnabled ? text : text.toLowerCase();
        }

        // Update the capitalization warning visibility based on toggle state and input content
        function updateCapsWarning() {
            const capsDisabled = document.querySelector('input[name="capitalize_letters"]:checked')?.value !== 'enabled';
            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';

            let hasUppercase = false;
            if (placementMode === 'manual') {
                const lines = getDynamicLineValues();
                hasUppercase = lines.some(line => line !== line.toLowerCase());
            } else {
                const autoTextValue = document.getElementById('auto-text')?.value || '';
                hasUppercase = autoTextValue !== autoTextValue.toLowerCase();
            }

            const warning = document.getElementById('caps-warning');
            if (warning) {
                warning.style.display = (capsDisabled && hasUppercase) ? 'block' : 'none';
            }
        }

        // Initialize dynamic line inputs and listeners (force default 4 on first load)
        const gridRowsEl = document.getElementById('grid_rows');
        if (gridRowsEl) gridRowsEl.value = '4';
        createDynamicLineInputs(4);
        addInputChangeListeners();
        addGridRowsListener();

        // Placement mode logic
        const placementRadios = document.querySelectorAll('input[name="placement_mode"]');
        const autoContainer = document.getElementById('auto-input-container');
        const dynamicContainer = document.getElementById('dynamic-line-inputs');
        const autoText = document.getElementById('auto-text');
        const autoWarning = document.getElementById('auto-overflow-warning');
        const autoWarningMsg = document.getElementById('auto-overflow-message');

        function isIndicatorsOn() {
            return document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';
        }

        function getAvailableColumns() {
            const gridColumnsValue = parseInt(document.getElementById('grid_columns').value) || 11;
            // The UI dial shows usable text cells; use it directly for wrapping
            return gridColumnsValue;
        }

        function getTotalCellsAvailable() {
            const rows = parseInt(document.getElementById('grid_rows').value) || 4;
            const cols = getAvailableColumns();
            return rows * cols;
        }

        // BANA-compliant-ish auto wrapping for braille rows
        // Policy:
        // - Prefer not to divide words across lines
        // - Hyphenated words may break after a hyphen (hyphen remains at end of line)
        // - If a single non-hyphenated word exceeds the row width in braille cells,
        //   we attempt a simple syllable-like split; if none found, we warn and abort
        async function banaAutoWrap(src, cols, rows, tableName) {
            const warnings = [];
            const textLines = [];
            const brailleLines = [];

            const normalizeSpaces = (s) => s.replace(/\s+/g, ' ').trim();
            const isHyphenChar = (ch) => /[-\u2010\u2011\u2012\u2013\u2014\u2212]/.test(ch);
            const isEmailBreakChar = (ch) => ch === '@' || ch === '.';

            // Preferred in-word break positions (rightmost-first) for overlong tokens
            // - After hyphen-like chars
            // - After '@' or '.' (email/URLs)
            function findPreferredBreakPositions(word) {
                const positions = [];
                for (let i = 0; i < word.length; i++) {
                    const ch = word[i];
                    if (isHyphenChar(ch) || isEmailBreakChar(ch)) {
                        // break AFTER this char
                        if (i + 1 < word.length) positions.push(i);
                    }
                }
                return positions;
            }

            // Find potential syllable break indices using a simple vowel-based heuristic.
            // This is a fallback when no hyphen is present; not perfect, but avoids arbitrary splits.
            function findHeuristicSyllableBreaks(word) {
                const breaks = [];
                const vowels = /[aeiouyAEIOUY]/;
                for (let i = 1; i < word.length - 1; i++) {
                    const prev = word[i - 1];
                    const cur = word[i];
                    const next = word[i + 1];
                    if (vowels.test(prev) && !vowels.test(cur)) {
                        // Vowel  consonant boundary; prefer breaking here if needed
                        breaks.push(i);
                    } else if (vowels.test(cur) && !vowels.test(next)) {
                        // After a vowel when next is consonant
                        breaks.push(i + 1);
                    }
                }
                // Deduplicate and sort ascending
                return Array.from(new Set(breaks)).filter(b => b > 0 && b < word.length).sort((a,b)=>a-b);
            }

            async function translateLen(text) {
                const b = await translateWithLiblouis(applyCapitalizationSetting(text), 'g2', tableName);
                return b.length;
            }

            async function translateText(text) {
                return await translateWithLiblouis(applyCapitalizationSetting(text), 'g2', tableName);
            }

            let remaining = normalizeSpaces(src);
            if (!remaining) {
                // Return empty lines matching requested rows
                for (let r = 0; r < rows; r++) { textLines.push(''); brailleLines.push(''); }
                return { textLines, brailleLines, warnings };
            }

            const words = remaining.split(' ');
            let currentText = '';
            let currentBraille = '';

            // Helper to finalize current line
            async function pushCurrent() {
                const text = currentText.trim();
                const braille = text ? await translateText(text) : '';
                textLines.push(text);
                brailleLines.push(braille);
                currentText = '';
                currentBraille = '';
            }

            // Process each word greedily with lookahead via translation
            let i = 0;
            while (i < words.length && textLines.length < rows) {
                let word = words[i];
                if (!word) { i++; continue; }

                // Try to append word to current line (with a space if needed)
                const candidate = currentText ? `${currentText} ${word}` : word;
                const candidateBrailleLen = await translateLen(candidate);
                if (candidateBrailleLen <= cols) {
                    currentText = candidate;
                    currentBraille = null; // invalidate cache
                    i++;
                    continue;
                }

                // Would overflow. If current line has content, finalize it and retry word on next line
                if (currentText) {
                    await pushCurrent();
                    continue; // Retry same word on new line
                }

                // Single word longer than a line. Try preferred break opportunities first.
                const pref = findPreferredBreakPositions(word);
                let didSplitPreferred = false;
                for (let k = pref.length - 1; k >= 0; k--) {
                    const pos = pref[k];
                    const head = word.slice(0, pos + 1); // include break char at end of line
                    const headLen = await translateLen(head);
                    if (headLen <= cols) {
                        currentText = head;
                        await pushCurrent();
                        // Remainder becomes current word for next iteration
                        const tail = word.slice(pos + 1);
                        words[i] = tail || '';
                        if (!words[i]) { i++; }
                        didSplitPreferred = true;
                        break;
                    }
                }
                if (didSplitPreferred) {
                    continue; // continue outer while loop on possibly updated words[i]
                }

                // Try heuristic syllable-like breaks (do NOT insert a hyphen)
                const syllableBreaks = findHeuristicSyllableBreaks(word);
                if (syllableBreaks.length > 0) {
                    // Choose the largest prefix that fits
                    let chosen = -1;
                    for (const b of syllableBreaks) {
                        const head = word.slice(0, b);
                        const headLen = await translateLen(head);
                        if (headLen <= cols) chosen = b; else break;
                    }
                    if (chosen > 0) {
                        const head = word.slice(0, chosen);
                        currentText = head;
                        await pushCurrent();
                        const tail = word.slice(chosen);
                        words[i] = tail || '';
                        if (!words[i]) { i++; }
                        continue;
                    }
                }

                // Monosyllabic or no safe split found: cannot divide per BANA
                const wordBrailleLen = await translateLen(word);
                warnings.push(`Word "${word}" requires ${wordBrailleLen} cells but only ${cols} fit per row. It cannot be divided per BANA; increase columns/rows or use Manual Placement.`);
                return { error: true, warnings };
            }

            // Push the last line if any and if we still have space for lines
            if (currentText && textLines.length < rows) {
                await pushCurrent();
            }

            // If content remains beyond rows, warn
            if (i < words.length) {
                warnings.push('Text exceeds available rows after word-aware wrapping; extra content was not placed.');
            }

            // Ensure we return exactly "rows" lines for downstream consumers
            while (textLines.length < rows) { textLines.push(''); brailleLines.push(''); }
            if (textLines.length > rows) {
                textLines.length = rows; brailleLines.length = rows;
            }

            return { textLines, brailleLines, warnings };
        }

        function updatePlacementUI() {
            const mode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            if (mode === 'auto') {
                autoContainer.style.display = '';
                dynamicContainer.style.display = 'none';
            } else {
                autoContainer.style.display = 'none';
                dynamicContainer.style.display = '';
                // Ensure per-line language selects are populated when switching to manual
                syncLineLanguageSelects();
            }
            resetToGenerateState();
        }

        placementRadios.forEach(r => r.addEventListener('change', () => {
            updatePlacementUI();
            updateCapsWarning();
        }));

        // Update UI on relevant changes to show/compute warnings
        ['grid_rows','grid_columns','cell_spacing','line_spacing','cylinder_diameter_mm','cylinder_height_mm','indicator_shapes']
            .forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        if (document.querySelector('input[name="placement_mode"]:checked')?.value === 'auto') {
                            computeAutoOverflow();
                        }
                    });
                }
            });

        async function computeAutoOverflow() {
            autoWarning.style.display = 'none';
            autoWarningMsg.textContent = '';
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect?.value || 'en-ueb-g1.ctb';
            const src = (autoText?.value || '').trim();
            if (!src) return;
            try {
                const braille = await translateWithLiblouis(applyCapitalizationSetting(src), 'g2', tableName);
                const totalCellsNeeded = braille.length;
                const totalCellsAvailable = getTotalCellsAvailable();
                if (totalCellsNeeded > totalCellsAvailable) {
                    const over = totalCellsNeeded - totalCellsAvailable;
                    autoWarningMsg.textContent = `Your text exceeds the number of available braille cells by ${over} cells.`;
                    autoWarning.style.display = 'block';
                }
            } catch (e) {
                // Ignore preview warning if translation not available
            }
        }

        if (autoText) {
            autoText.addEventListener('input', () => {
                resetToGenerateState();
                computeAutoOverflow();
                updateCapsWarning();
            });
        }

        // Initialize placement UI
        updatePlacementUI();

        // Persistence: save and restore user settings
        function persistValue(key, value) {
            try { localStorage.setItem(key, value); } catch (e) {}
        }
        function readPersisted(key) {
            try { return localStorage.getItem(key); } catch (e) { return null; }
        }
        function clearAllPersistence() {
            const keys = [
                'braille_prefs_language_table',
                'braille_prefs_plate_type',
                'braille_prefs_shape_type',
                'braille_prefs_dot_shape',
                'braille_prefs_combined_shape',
                'braille_prefs_placement_mode',
                'braille_prefs_indicator_shapes',
                'braille_prefs_capitalize_letters',
                'braille_prefs_expert_visible',
                'braille_prefs_grid_columns',
                'braille_prefs_grid_rows',
                'braille_prefs_cell_spacing',
                'braille_prefs_line_spacing',
                'braille_prefs_dot_spacing',
                'braille_prefs_card_width',
                'braille_prefs_card_height',
                'braille_prefs_card_thickness',
                'braille_prefs_braille_x_adjust',
                'braille_prefs_braille_y_adjust',
                'braille_prefs_emboss_dot_base_diameter',
                'braille_prefs_emboss_dot_height',
                'braille_prefs_emboss_dot_flat_hat',
                'braille_prefs_hemi_counter_dot_base_diameter',
                'braille_prefs_bowl_counter_dot_base_diameter',
                'braille_prefs_counter_dot_depth',
                'braille_prefs_use_bowl_recess', // legacy
                'braille_prefs_recess_shape',
                'braille_prefs_cone_counter_dot_base_diameter',
                'braille_prefs_cone_counter_dot_height',
                'braille_prefs_cone_counter_dot_flat_hat',
                'braille_prefs_rounded_dot_base_diameter',
                'braille_prefs_rounded_dot_base_height',
                'braille_prefs_rounded_dot_dome_diameter',
                'braille_prefs_rounded_dot_dome_height',
                'braille_prefs_cylinder_diameter_mm',
                'braille_prefs_cylinder_height_mm',
                'braille_prefs_cylinder_polygonal_cutout_radius_mm',
                'braille_prefs_cylinder_polygonal_cutout_sides',
                'braille_prefs_seam_offset_deg'
            ];
            keys.forEach(k => { try { localStorage.removeItem(k); } catch (e) {} });
        }

        function applyPersistedSettings() {
            // Placement mode (auto/manual)
            const savedPlacement = readPersisted('braille_prefs_placement_mode');
            if (savedPlacement === 'auto' || savedPlacement === 'manual') {
                const radio = document.querySelector(`input[name="placement_mode"][value="${savedPlacement}"]`);
                if (radio) radio.checked = true;
            }
            // Plate type
            const savedPlate = readPersisted('braille_prefs_plate_type');
            if (savedPlate === 'positive' || savedPlate === 'negative') {
                const radio = document.querySelector(`input[name="plate_type"][value="${savedPlate}"]`);
                if (radio) radio.checked = true;
            }
            // Indicator shapes (on/off)
            const savedIndicator = readPersisted('braille_prefs_indicator_shapes');
            if (savedIndicator === '1' || savedIndicator === '0') {
                const radio = document.querySelector(`input[name="indicator_shapes"][value="${savedIndicator}"]`);
                if (radio) radio.checked = true;
            }
            // Capitalized Letters setting
            const savedCaps = readPersisted('braille_prefs_capitalize_letters');
            if (savedCaps === 'enabled' || savedCaps === 'disabled') {
                const radio = document.querySelector(`input[name="capitalize_letters"][value="${savedCaps}"]`);
                if (radio) radio.checked = true;
            }
            // Shape type
            const savedShape = readPersisted('braille_prefs_shape_type');
            if (savedShape === 'card' || savedShape === 'cylinder') {
                const radio = document.querySelector(`input[name="shape_type"][value="${savedShape}"]`);
                if (radio) radio.checked = true;
            }
            // Dot shape
            const savedDot = readPersisted('braille_prefs_dot_shape');
            if (savedDot === 'cone' || savedDot === 'rounded') {
                const radio = document.querySelector(`input[name="dot_shape"][value="${savedDot}"]`);
                if (radio) radio.checked = true;
            }
            // Combined shape - initialize based on saved dot shape or default to rounded
            const savedCombined = readPersisted('braille_prefs_combined_shape') || savedDot || 'cone';
            if (savedCombined === 'cone' || savedCombined === 'rounded') {
                const radio = document.querySelector(`input[name="combined_shape"][value="${savedCombined}"]`);
                if (radio) radio.checked = true;

                console.log('Initializing combined shape to:', savedCombined);

                // Sync individual values for backend compatibility
                const dotShapeRadios = document.querySelectorAll('input[name="dot_shape"]');
                const recessShapeRadios = document.querySelectorAll('input[name="recess_shape"]');

                if (savedCombined === 'rounded') {
                    dotShapeRadios.forEach(r => { if (r.value === 'rounded') r.checked = true; });
                    recessShapeRadios.forEach(r => { if (r.value === '1') r.checked = true; }); // Bowl
                    console.log('Initialized to rounded - dot_shape: rounded, recess_shape: 1');
                } else if (savedCombined === 'cone') {
                    dotShapeRadios.forEach(r => { if (r.value === 'cone') r.checked = true; });
                    recessShapeRadios.forEach(r => { if (r.value === '2') r.checked = true; }); // Cone
                    // NOTE: We intentionally do NOT call syncEmbossToCounterConeParams() here.
                    // The thickness preset (applied before this) already sets correct values for both
                    // emboss and counter cone params. Syncing would overwrite the preset's counter values.
                    console.log('Initialized to cone - dot_shape: cone, recess_shape: 2');
                }
            }
            // Expert visibility
            const savedExpert = readPersisted('braille_prefs_expert_visible');
            if (savedExpert === 'true' || savedExpert === 'false') {
                const visible = savedExpert === 'true';
                expertSettings.style.display = visible ? 'block' : 'none';
                expertToggleText.textContent = visible ? 'Hide Expert Mode' : 'Show Expert Mode';
                expertToggleIcon.textContent = visible ? '' : '';
                expertToggleBtn.classList.toggle('active', visible);
            }
            // Numeric/text inputs
            const map = [
                ['grid_rows','braille_prefs_grid_rows'],
                ['cell_spacing','braille_prefs_cell_spacing'],
                ['line_spacing','braille_prefs_line_spacing'],
                ['dot_spacing','braille_prefs_dot_spacing'],
                ['card_width','braille_prefs_card_width'],
                ['card_height','braille_prefs_card_height'],
                ['card_thickness','braille_prefs_card_thickness'],
                ['braille_x_adjust','braille_prefs_braille_x_adjust'],
                ['braille_y_adjust','braille_prefs_braille_y_adjust'],
                ['emboss_dot_base_diameter','braille_prefs_emboss_dot_base_diameter'],
                ['emboss_dot_height','braille_prefs_emboss_dot_height'],
                ['emboss_dot_flat_hat','braille_prefs_emboss_dot_flat_hat'],
                ['hemi_counter_dot_base_diameter','braille_prefs_hemi_counter_dot_base_diameter'],
                ['bowl_counter_dot_base_diameter','braille_prefs_bowl_counter_dot_base_diameter'],
                ['counter_dot_depth','braille_prefs_counter_dot_depth'],
                ['cone_counter_dot_base_diameter','braille_prefs_cone_counter_dot_base_diameter'],
                ['cone_counter_dot_height','braille_prefs_cone_counter_dot_height'],
                ['cone_counter_dot_flat_hat','braille_prefs_cone_counter_dot_flat_hat'],
                ['recess_shape','braille_prefs_recess_shape'],
                ['rounded_dot_base_diameter','braille_prefs_rounded_dot_base_diameter'],
                ['rounded_dot_base_height','braille_prefs_rounded_dot_base_height'],
                ['rounded_dot_dome_diameter','braille_prefs_rounded_dot_dome_diameter'],
                ['rounded_dot_dome_height','braille_prefs_rounded_dot_dome_height'],
                ['cylinder_diameter_mm','braille_prefs_cylinder_diameter_mm'],
                ['cylinder_height_mm','braille_prefs_cylinder_height_mm'],
                ['cylinder_polygonal_cutout_radius_mm','braille_prefs_cylinder_polygonal_cutout_radius_mm'],
                ['cylinder_polygonal_cutout_sides','braille_prefs_cylinder_polygonal_cutout_sides'],
                ['seam_offset_deg','braille_prefs_seam_offset_deg']
            ];
            map.forEach(([id,key]) => {
                const v = readPersisted(key);
                if (v !== null && v !== undefined) {
                    const el = document.getElementById(id);
                    if (el) el.value = v;
                }
            });
            // Restore recess shape selection (default to Bowl when no saved value)
            const savedRecessShape = readPersisted('braille_prefs_recess_shape');
            if (savedRecessShape === '0' || savedRecessShape === '1' || savedRecessShape === '2') {
                const r = document.querySelector(`input[name="recess_shape"][value="${savedRecessShape}"]`);
                if (r) r.checked = true;
            } else {
                const r = document.querySelector('input[name="recess_shape"][value="1"]');
                if (r) r.checked = true;
            }
            // grid_columns handled last to avoid preserve conversion
            const savedCols = readPersisted('braille_prefs_grid_columns');
            updateShapeSettings();
            updateGridColumnsForPlateType(true);
            if (savedCols !== null && savedCols !== undefined) {
                const gridColsEl = document.getElementById('grid_columns');
                if (gridColsEl) gridColsEl.value = savedCols;
            }
            // Recreate dynamic line inputs in case grid_rows changed
            const numLines = parseInt(document.getElementById('grid_rows').value) || 4;
            createDynamicLineInputs(numLines);
        }

        function wirePersistenceListeners() {
            // Placement mode (auto/manual)
            document.querySelectorAll('input[name="placement_mode"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_placement_mode', document.querySelector('input[name="placement_mode"]:checked').value));
            });
            // Plate type
            document.querySelectorAll('input[name="plate_type"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_plate_type', document.querySelector('input[name="plate_type"]:checked').value));
            });
            // Indicator shapes (on/off)
            document.querySelectorAll('input[name="indicator_shapes"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_indicator_shapes', document.querySelector('input[name="indicator_shapes"]:checked').value));
            });
            // Capitalized Letters toggle
            document.querySelectorAll('input[name="capitalize_letters"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    persistValue('braille_prefs_capitalize_letters', document.querySelector('input[name="capitalize_letters"]:checked').value);
                    resetToGenerateState();
                    updateCapsWarning();
                    // Recalculate overflow if in auto mode (caps affect cell count)
                    if (document.querySelector('input[name="placement_mode"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                });
            });
            // Shape type
            document.querySelectorAll('input[name="shape_type"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_shape_type', document.querySelector('input[name="shape_type"]:checked').value));
            });
            // Dot shape (now handled by combined shape)
            document.querySelectorAll('input[name="dot_shape"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_dot_shape', document.querySelector('input[name="dot_shape"]:checked').value));
            });
            // Combined shape (new primary control)
            document.querySelectorAll('input[name="combined_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    const val = document.querySelector('input[name="combined_shape"]:checked')?.value || 'cone';
                    persistValue('braille_prefs_combined_shape', val);
                    // Also persist the individual values for backend compatibility
                    persistValue('braille_prefs_dot_shape', val);
                    persistValue('braille_prefs_recess_shape', val === 'rounded' ? '1' : '2');
                });
            });
            // Expert visibility
            expertToggleBtn.addEventListener('click', () => {
                const isVisible = expertSettings.style.display !== 'none';
                // After toggle above, visibility will invert; persist the next state
                const nextVisible = !isVisible;
                persistValue('braille_prefs_expert_visible', String(nextVisible));
            });
            // Numeric/text inputs
            const map = [
                ['grid_columns','braille_prefs_grid_columns'],
                ['grid_rows','braille_prefs_grid_rows'],
                ['cell_spacing','braille_prefs_cell_spacing'],
                ['line_spacing','braille_prefs_line_spacing'],
                ['dot_spacing','braille_prefs_dot_spacing'],
                ['card_width','braille_prefs_card_width'],
                ['card_height','braille_prefs_card_height'],
                ['card_thickness','braille_prefs_card_thickness'],
                ['braille_x_adjust','braille_prefs_braille_x_adjust'],
                ['braille_y_adjust','braille_prefs_braille_y_adjust'],
                ['emboss_dot_base_diameter','braille_prefs_emboss_dot_base_diameter'],
                ['emboss_dot_height','braille_prefs_emboss_dot_height'],
                ['emboss_dot_flat_hat','braille_prefs_emboss_dot_flat_hat'],
                ['hemi_counter_dot_base_diameter','braille_prefs_hemi_counter_dot_base_diameter'],
                ['bowl_counter_dot_base_diameter','braille_prefs_bowl_counter_dot_base_diameter'],
                ['counter_dot_depth','braille_prefs_counter_dot_depth'],
                ['cone_counter_dot_base_diameter','braille_prefs_cone_counter_dot_base_diameter'],
                ['cone_counter_dot_height','braille_prefs_cone_counter_dot_height'],
                ['cone_counter_dot_flat_hat','braille_prefs_cone_counter_dot_flat_hat'],
                ['recess_shape','braille_prefs_recess_shape'],
                ['rounded_dot_base_diameter','braille_prefs_rounded_dot_base_diameter'],
                ['rounded_dot_base_height','braille_prefs_rounded_dot_base_height'],
                ['rounded_dot_dome_diameter','braille_prefs_rounded_dot_dome_diameter'],
                ['rounded_dot_dome_height','braille_prefs_rounded_dot_dome_height'],
                ['cylinder_diameter_mm','braille_prefs_cylinder_diameter_mm'],
                ['cylinder_height_mm','braille_prefs_cylinder_height_mm'],
                ['cylinder_polygonal_cutout_radius_mm','braille_prefs_cylinder_polygonal_cutout_radius_mm'],
                ['cylinder_polygonal_cutout_sides','braille_prefs_cylinder_polygonal_cutout_sides'],
                ['seam_offset_deg','braille_prefs_seam_offset_deg']
            ];
            map.forEach(([id,key]) => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => persistValue(key, el.value));
                }
            });
            // Recess shape radio persistence (now handled by combined shape)
            document.querySelectorAll('input[name="recess_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    const val = document.querySelector('input[name="recess_shape"]:checked')?.value || '2';
                    persistValue('braille_prefs_recess_shape', val);
                });
            });
        }

        // On load, restore persisted settings, then wire listeners
        try { applyPersistedSettings(); } catch (e) {}
        try { wirePersistenceListeners(); } catch (e) {}
        // After restoring persisted settings, update placement UI to reflect restored mode
        try { updatePlacementUI(); } catch (e) {}

        // Reset to defaults button
        const resetBtn = document.getElementById('reset-defaults-btn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                clearAllPersistence();
                // Reset selects to their default option values
                const selectEls = Array.from(document.querySelectorAll('select'));
                selectEls.forEach(sel => { sel.value = sel.options[0]?.value || sel.defaultValue; });
                // Ensure language resets to UEB Grade 1
                try {
                    const langSelect = document.getElementById('language-table');
                    if (langSelect) {
                        langSelect.value = 'en-ueb-g1.ctb';
                        try { localStorage.setItem('braille_prefs_language_table', 'en-ueb-g1.ctb'); } catch (e) {}
                    }
                } catch (e) {}
                // Reset thickness preset to default (0.4mm)
                try {
                    localStorage.setItem('braille_prefs_thickness_preset', '0.4');
                    const thicknessRadio = document.querySelector('input[name="card_thickness_preset"][value="0.4"]');
                    if (thicknessRadio) thicknessRadio.checked = true;
                } catch (e) {}
                // Reset radio groups to defaultChecked
                const radioGroups = new Map();
                document.querySelectorAll('input[type="radio"]').forEach(r => {
                    if (!radioGroups.has(r.name)) radioGroups.set(r.name, []);
                    radioGroups.get(r.name).push(r);
                });
                radioGroups.forEach(group => {
                    const def = group.find(r => r.defaultChecked);
                    if (def) def.checked = true;
                });
                // Reset all inputs to their defaultValue
                document.querySelectorAll('input[type="number"], input[type="text"]').forEach(inp => {
                    if (inp.defaultValue !== undefined) inp.value = inp.defaultValue;
                });
                // Expert visibility default (hidden)
                expertSettings.style.display = 'none';
                expertToggleText.textContent = 'Show Expert Mode';
                expertToggleIcon.textContent = '';
                expertToggleBtn.classList.remove('active');
                updateShapeSettings();
                updateGridColumnsForPlateType();
                checkCylinderOverflow();
                resetToGenerateState();

                // Inform the user to refresh the page to fully reset preview and state
                try {
                    errorText.textContent = 'Settings reset to defaults. Please refresh the page to fully reset and clear the preview.';
                    errorDiv.style.display = 'flex';
                    errorDiv.className = 'error-message info';
                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                        errorDiv.className = 'error-message';
                    }, 5000);
                } catch (e) { /* ignore */ }
            });
        }

        // ======================================================================
        // Card Thickness Preset System
        // ======================================================================
        // Define presets for each thickness option (0.4mm and 0.3mm layer heights)
        // These presets set all numeric inputs to optimized values for each thickness.
        // Note: Text inputs (line1, line2, etc.) are NOT affected by presets.
        const THICKNESS_PRESETS = {
            '0.4': {
                // Braille Spacing (11 text cells + 2 indicator reserved = 13 total)
                grid_columns: 11,
                grid_rows: 4,
                cell_spacing: 6.5,
                line_spacing: 10.0,
                dot_spacing: 2.5,
                braille_x_adjust: 0.0,
                braille_y_adjust: 0.0,
                // Emboss Dot (Rounded)
                rounded_dot_base_diameter: 1.5,
                rounded_dot_base_height: 0.5,
                rounded_dot_dome_diameter: 1.0,
                rounded_dot_dome_height: 0.5,
                // Emboss Dot (Cone)
                emboss_dot_base_diameter: 1.5,
                emboss_dot_height: 0.8,
                emboss_dot_flat_hat: 0.4,
                // Counter Dot (Bowl/Rounded)
                bowl_counter_dot_base_diameter: 1.8,
                counter_dot_depth: 0.8,
                // Counter Dot (Cone)
                cone_counter_dot_base_diameter: 1.9,
                cone_counter_dot_height: 0.7,
                cone_counter_dot_flat_hat: 1.0,
                // Cylinder Dimensions
                cylinder_diameter_mm: 30.8,
                cylinder_height_mm: 52,
                cylinder_polygonal_cutout_radius_mm: 13,
                cylinder_polygonal_cutout_sides: 12,
                seam_offset_deg: 0,
                // Card/Plate Dimensions
                card_width: 90,
                card_height: 52,
                card_thickness: 2.0
            },
            '0.3': {
                // Braille Spacing (11 text cells + 2 indicator reserved = 13 total for 90mm card)
                grid_columns: 11,
                grid_rows: 4,
                cell_spacing: 6.5,
                line_spacing: 10.0,
                dot_spacing: 2.5,
                braille_x_adjust: 0.0,
                braille_y_adjust: 0.0,
                // Emboss Dot (Rounded) - optimized for 0.3mm layer
                rounded_dot_base_diameter: 1.2,
                rounded_dot_base_height: 0.4,
                rounded_dot_dome_diameter: 0.8,
                rounded_dot_dome_height: 0.4,
                // Emboss Dot (Cone) - optimized for 0.3mm layer
                emboss_dot_base_diameter: 1.2,
                emboss_dot_height: 0.6,
                emboss_dot_flat_hat: 0.2,
                // Counter Dot (Bowl/Rounded) - optimized for 0.3mm layer
                bowl_counter_dot_base_diameter: 1.5,
                counter_dot_depth: 0.5,
                // Counter Dot (Cone) - optimized for 0.3mm layer
                cone_counter_dot_base_diameter: 1.5,
                cone_counter_dot_height: 0.5,
                cone_counter_dot_flat_hat: 0.8,
                // Cylinder Dimensions
                cylinder_diameter_mm: 30.8,
                cylinder_height_mm: 52,
                cylinder_polygonal_cutout_radius_mm: 13,
                cylinder_polygonal_cutout_sides: 12,
                seam_offset_deg: 0,
                // Card/Plate Dimensions
                card_width: 90,
                card_height: 52,
                card_thickness: 2.0
            }
        };

        /**
         * Check if current input values match a specific preset.
         * @param {string} presetKey - '0.4' or '0.3'
         * @returns {boolean} - true if all values match the preset
         */
        function checkPresetMatch(presetKey) {
            const preset = THICKNESS_PRESETS[presetKey];
            if (!preset) return false;

            for (const [inputId, expectedValue] of Object.entries(preset)) {
                const input = document.getElementById(inputId);
                if (input) {
                    // Compare as numbers to handle floating point formatting differences
                    const currentValue = parseFloat(input.value);
                    const presetValue = parseFloat(expectedValue);
                    if (isNaN(currentValue) || Math.abs(currentValue - presetValue) > 0.0001) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * Determine which preset (if any) matches current values, or 'custom' if none match.
         * @returns {string} - '0.4', '0.3', or 'custom'
         */
        function detectCurrentPreset() {
            if (checkPresetMatch('0.4')) return '0.4';
            if (checkPresetMatch('0.3')) return '0.3';
            return 'custom';
        }

        /**
         * Update the preset radio button selection based on current input values.
         * Called when any preset-controlled input changes.
         */
        function updatePresetSelection() {
            const detectedPreset = detectCurrentPreset();
            const radio = document.querySelector(`input[name="card_thickness_preset"][value="${detectedPreset}"]`);
            if (radio && !radio.checked) {
                radio.checked = true;
                // Persist the detected preset state
                try { localStorage.setItem('braille_prefs_thickness_preset', detectedPreset); } catch (e) {}
                log.debug('Preset auto-switched to:', detectedPreset);
            }
        }

        /**
         * Apply a thickness preset by setting all input values to the preset values.
         * Does NOT affect text inputs (line1, line2, etc.)
         * @param {string} presetKey - '0.4' or '0.3'
         */
        function applyThicknessPreset(presetKey) {
            const preset = THICKNESS_PRESETS[presetKey];
            if (!preset) {
                log.debug('Unknown thickness preset:', presetKey);
                return;
            }

            log.debug('Applying thickness preset:', presetKey);

            // Apply each preset value to the corresponding input
            Object.entries(preset).forEach(([inputId, value]) => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.value = value;
                    log.debug(`Set ${inputId} = ${value}`);

                    // Also persist the value to localStorage
                    const persistKey = `braille_prefs_${inputId}`;
                    try { localStorage.setItem(persistKey, value); } catch (e) {}
                }
            });

            // Persist the selected preset
            try { localStorage.setItem('braille_prefs_thickness_preset', presetKey); } catch (e) {}

            // Update related UI elements
            try { updateGridColumnsForPlateType(); } catch (e) {}
            try { checkCylinderOverflow(); } catch (e) {}
            try { resetToGenerateState(); } catch (e) {}

            // Show confirmation message
            try {
                errorText.textContent = `Card Thickness preset "${presetKey}mm" applied. All parameters updated.`;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message info';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                    errorDiv.className = 'error-message';
                }, 3000);
            } catch (e) { /* ignore */ }
        }

        // Wire up thickness preset radio buttons
        // Use both 'change' and 'click' events to handle switching and re-applying
        document.querySelectorAll('input[name="card_thickness_preset"]').forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked && this.value !== 'custom') {
                    // Only apply preset for 0.4 and 0.3, not for custom
                    applyThicknessPreset(this.value);
                }
            });
            // Add click listener to allow re-applying the currently selected preset
            radio.addEventListener('click', function() {
                if (this.checked && this.value !== 'custom') {
                    // Only apply preset for 0.4 and 0.3, not for custom
                    applyThicknessPreset(this.value);
                }
            });
        });

        // Wire up change detection on all preset-controlled inputs
        // When any of these inputs change, check if we should switch to "Custom"
        (function setupPresetChangeDetection() {
            // Get all parameter IDs from both presets (they have the same keys)
            const presetParamIds = Object.keys(THICKNESS_PRESETS['0.4']);

            presetParamIds.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    // Listen for input events (real-time) and change events (on blur)
                    input.addEventListener('input', updatePresetSelection);
                    input.addEventListener('change', updatePresetSelection);
                }
            });

            log.debug('Preset change detection set up for', presetParamIds.length, 'inputs');
        })();

        // Restore persisted thickness preset on load and apply it
        (function restoreThicknessPreset() {
            try {
                const savedPreset = localStorage.getItem('braille_prefs_thickness_preset');

                // If saved preset is 'custom', just set the radio and don't apply any preset values
                if (savedPreset === 'custom') {
                    const customRadio = document.querySelector('input[name="card_thickness_preset"][value="custom"]');
                    if (customRadio) {
                        customRadio.checked = true;
                    }
                    log.debug('Restored custom preset selection (no values applied)');
                    return;
                }

                // For 0.4 or 0.3, apply the preset
                const presetToApply = (savedPreset && THICKNESS_PRESETS[savedPreset]) ? savedPreset : '0.4';

                // Set the radio button
                const radio = document.querySelector(`input[name="card_thickness_preset"][value="${presetToApply}"]`);
                if (radio) {
                    radio.checked = true;
                }

                // Apply the preset to ensure all values are consistent
                // This fixes the issue where HTML defaults don't match preset values
                applyThicknessPreset(presetToApply);
                log.debug('Applied thickness preset on load:', presetToApply);
            } catch (e) {
                log.debug('Error restoring thickness preset:', e);
            }
        })();
        // ======================================================================
        // End Card Thickness Preset System
        // ======================================================================

        // Initialize shape settings to show/hide cylinder parameters correctly
        updateShapeSettings();

        expertToggleBtn.addEventListener('click', () => {
            const isVisible = expertSettings.style.display !== 'none';
            expertSettings.style.display = isVisible ? 'none' : 'block';
            expertToggleText.textContent = isVisible ? 'Show Expert Mode' : 'Hide Expert Mode';
            expertToggleIcon.textContent = isVisible ? '' : '';
            expertToggleBtn.classList.toggle('active', !isVisible);
            expertToggleBtn.setAttribute('aria-expanded', String(!isVisible));

            // Optional: Focus management when opening
            if (!isVisible) {
                const firstFocusable = expertSettings.querySelector(
                    'input, select, button, textarea, [tabindex]:not([tabindex="-1"])'
                );
                if (firstFocusable) {
                    setTimeout(() => firstFocusable.focus(), 100);
                }
            }
        });

        // Dot shape radio buttons
        document.querySelectorAll('input[name="dot_shape"]').forEach(radio => {
            radio.addEventListener('change', function() {
                resetToGenerateState();
            });
        });

        // Removed redundant toggle-dot-shape button
        // Info dropdown has been removed (replaced by Help modal)

        // Wire Expert submenus (expand/collapse)
        (function initExpertSubmenus() {
            const submenuToggles = Array.from(document.querySelectorAll('.expert-submenu-toggle'));
            submenuToggles.forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const content = toggle.nextElementSibling;
                    if (!content) return;
                    const isOpen = toggle.getAttribute('aria-expanded') === 'true';

                    if (isOpen) {
                        content.style.display = 'none';
                    } else {
                        content.style.display = 'block';
                        // Move focus to first input when opening
                        const firstFocusable = content.querySelector('input, select, button, textarea, [tabindex]:not([tabindex="-1"])');
                        if (firstFocusable) {
                            setTimeout(() => firstFocusable.focus(), 100);
                        }
                    }
                    toggle.setAttribute('aria-expanded', String(!isOpen));
                    toggle.classList.toggle('active', !isOpen);
                    const icon = toggle.querySelector('.expert-submenu-icon');
                    if (icon) icon.textContent = isOpen ? '' : '';
                });
            });
        })();

        // Add real-time debugging for Expert Mode parametric dials
        const expertInputs = [
            'emboss_dot_base_diameter',
            'emboss_dot_height',
            'emboss_dot_flat_hat',
            'hemi_counter_dot_base_diameter',
            'bowl_counter_dot_base_diameter',
            'counter_dot_depth',
            'grid_columns',
            'grid_rows',
            'cell_spacing',
            'line_spacing',
            'dot_spacing',
            'card_width',
            'card_height',
            'card_thickness',
            'braille_x_adjust',
            'braille_y_adjust',
            'cylinder_diameter_mm',
            'cylinder_height_mm',
            'cylinder_polygonal_cutout_radius_mm',
            'cylinder_polygonal_cutout_sides',
            'seam_offset_deg'
        ];

        expertInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', (e) => {
                    log.debug(`Expert Mode Input Changed: ${inputId} = ${e.target.value}`);

                    // If grid_columns changed, update the label/note but preserve the value
                    if (inputId === 'grid_columns') {
                        updateGridColumnsForPlateType(true);
                    }
                });

                // Also log the initial values
                log.debug(`Initial value for ${inputId}: ${input.value}`);
            }
        });
        // Log initial recess shape radio value too
        (function logInitialRecessShape() {
            const v = document.querySelector('input[name="use_bowl_recess"]:checked')?.value;
            if (v !== undefined) {
                log.debug('Initial value for use_bowl_recess:', v);
            }
        })();

        // Function to get current Expert Mode values
        window.getCurrentExpertModeValues = function() {
            const values = {};
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    values[inputId] = input.value;
                }
            });
            return values;
        };

        // Convert a unicode braille string to computer shorthand tokens with brief indicators
        function brailleToComputerShorthand(brailleStr) {
            // Common UEB contractions and indicators
            const contractionMap = {
                '': 'ch',
                '': 'sh',
                '': 'th',
                '': 'wh',
                '': 'ed',
                '': 'er',
                '': 'ou',
                '': 'ow',
                '': 'ar',
                '': 'ing',
                '': 'en',
                '': 'in',
                '': 'st',
                '': 'the',
                '': 'and',
                '': 'of',
                '': 'for',
                '': 'with'
            };

            const indicatorMap = {
                '': '[Capital Symbol]',
                '': '[Number Symbol]'
            };

            const punctuationMap = {
                '': ',',
                '': ';',
                '': ':',
                '': '.',
                '': '!',
                '': '?',
                '': '-',
                '': '\''
            };

            const letterMap = {
                '':'a','':'b','':'c','':'d','':'e','':'f','':'g','':'h','':'i','':'j',
                '':'k','':'l','':'m','':'n','':'o','':'p','':'q','':'r','':'s','':'t',
                '':'u','':'v','':'w','':'x','':'y','':'z'
            };

            const digitMap = {
                '':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'
            };

            let result = '';
            let numericMode = false;
            let pendingWordGap = false;

            for (const ch of brailleStr) {
                if (ch === ' ') {
                    // Word boundary
                    numericMode = false;
                    pendingWordGap = true;
                    continue;
                }

                if (indicatorMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += indicatorMap[ch];
                    pendingWordGap = false;
                    if (ch === '') numericMode = true;
                    continue;
                }

                if (contractionMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += `[${contractionMap[ch]}]`;
                    pendingWordGap = false;
                    // contractions end numeric mode
                    numericMode = false;
                    continue;
                }

                if (numericMode && digitMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += digitMap[ch];
                    pendingWordGap = false;
                    continue;
                }

                if (letterMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += letterMap[ch];
                    pendingWordGap = false;
                    // letters in numeric mode that are not digits will end numeric mode
                    numericMode = false;
                    continue;
                }

                if (punctuationMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += punctuationMap[ch];
                    pendingWordGap = false;
                    numericMode = false;
                    continue;
                }

                // Fallback: show the braille cell itself
                if (result.length > 0) {
                    result += pendingWordGap ? '  ' : ' ';
                }
                result += ch;
                pendingWordGap = false;
                numericMode = false;
            }

            return result;
        }

        // Preview braille translation using real liblouis (supports manual and auto placement)
        previewBrailleBtn.addEventListener('click', async () => {
            // Reset button state when previewing (user is making changes)
            resetToGenerateState();

            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect.value;

            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            errorDiv.style.display = 'none';
            let previewHTML = '';

            if (placementMode === 'manual') {
                const lines = getDynamicLineValues();
                if (lines.every(line => !line.trim())) {
                    errorText.textContent = 'Please enter text in at least one line.';
                    errorDiv.style.display = 'flex';
                    return;
                }
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        try {
                            const perLineTable = (document.getElementById(`line_lang_${i+1}`)?.value) || tableName;
                            const braille = await translateWithLiblouis(applyCapitalizationSetting(lines[i].trim()), 'g2', perLineTable);
                            const shorthand = brailleToComputerShorthand(braille);
                            previewHTML += `<div class="preview-line-success">
                                <div><strong>Line ${i + 1}:</strong> "${lines[i].trim()}"  "${braille}"</div>
                                <div class="preview-subline">Computer shorthand: "${shorthand}"</div>
                            </div>`;
                        } catch (error) {
                            log.error('Translation failed for line', i + 1, ':', error);
                            previewHTML += `<div class="preview-line-error">
                                <strong>Line ${i + 1}:</strong> "${lines[i].trim()}"  Error: ${error.message}
                            </div>`;
                        }
                    }
                }
            } else {
                // Auto mode: BANA-aware word wrapping for preview
                const src = (document.getElementById('auto-text')?.value || '').trim();
                if (!src) {
                    errorText.textContent = 'Please enter text in the Auto Placement field.';
                    errorDiv.style.display = 'flex';
                    return;
                }
                try {
                    const shapeTypeEl = document.querySelector('input[name="shape_type"]:checked');
                    const shapeTypeVal = shapeTypeEl ? shapeTypeEl.value : 'card';
                    // Use unified available columns helper
                    const cols = getAvailableColumns();
                    const rows = parseInt(document.getElementById('grid_rows').value) || 4;
                    const wrap = await banaAutoWrap(src, cols, rows, tableName);
                    if (wrap.error) {
                        errorText.textContent = wrap.warnings && wrap.warnings.length ? wrap.warnings.join(' ') : 'Unable to wrap text per BANA rules.';
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        // Still show whatever lines we have (empty)
                    }
                    const linesForPreview = wrap.brailleLines || [];
                    for (let r = 0; r < rows; r++) {
                        const slice = linesForPreview[r] || '';
                        const shorthand = slice ? brailleToComputerShorthand(slice) : '';
                        previewHTML += `<div class="preview-line-success">
                            <div><strong>Row ${r + 1}:</strong> "${slice}"</div>
                            <div class="preview-subline">${shorthand ? `Computer shorthand: "${shorthand}"` : ''}</div>
                        </div>`;
                    }
                    if (wrap.warnings && wrap.warnings.length) {
                        errorText.textContent = wrap.warnings.join(' ');
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'grade-note';
                    }
                } catch (error) {
                    log.error('BANA wrap failed for auto text:', error);
                    previewHTML += `<div class="preview-line-error">
                        <strong>Auto Placement:</strong> Error: ${error.message}
                    </div>`;
                }
            }

            previewContent.innerHTML = previewHTML;
            braillePreview.style.display = 'block';
        });

        // WebGL feature detection
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                return !!context;
            } catch (e) {
                return false;
            }
        }

        function init3D() {
            // Check WebGL support before initializing
            if (!checkWebGLSupport()) {
                viewer.innerHTML = `
                    <div class="webgl-error" role="alert">
                        <strong>WebGL Not Available</strong>
                        <p>Your browser does not support WebGL, which is required for the 3D preview.
                        You can still generate and download STL files.</p>
                        <p>Try updating your browser or enabling hardware acceleration in your browser settings.</p>
                    </div>
                `;
                return; // Skip rest of init3D
            }

            // Mobile-optimized renderer settings
            const isMobile = window.innerWidth <= 768;
            renderer = new THREE.WebGLRenderer({
                antialias: !isMobile, // Disable antialiasing on mobile for performance
                powerPreference: isMobile ? "low-power" : "high-performance"
            });
            const initW = viewer.clientWidth;
            const initH = viewer.clientHeight || 420;
            renderer.setSize(initW, initH, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
            // Preserve overlay children inside #viewer; only remove previous canvas if present
            const existingCanvas = viewer.querySelector('canvas');
            if (existingCanvas) viewer.removeChild(existingCanvas);
            viewer.appendChild(renderer.domElement);

            // WebGL context loss/recovery handlers (Safari/iOS stability)
            renderer.domElement.addEventListener('webglcontextlost', (event) => {
                event.preventDefault(); // Allow recovery
                console.warn('WebGL context lost');

                // Show user-friendly message
                if (!document.getElementById('webgl-recovery-msg')) {
                    const msg = document.createElement('div');
                    msg.id = 'webgl-recovery-msg';
                    msg.className = 'webgl-recovery';
                    msg.setAttribute('role', 'alert');
                    msg.innerHTML = `
                        <strong>3D Preview Paused</strong>
                        <p>The 3D viewer was interrupted. It will automatically recover.</p>
                    `;
                    viewer.appendChild(msg);
                }
            }, false);

            renderer.domElement.addEventListener('webglcontextrestored', () => {
                console.log('WebGL context restored');

                // Remove recovery message
                const msg = document.getElementById('webgl-recovery-msg');
                if (msg) msg.remove();

                // Re-initialize scene
                reinitialize3DScene();

                // Reload last STL if available
                if (lastGeneratedSTLUrl) {
                    const loader = new STLLoader();
                    loader.load(lastGeneratedSTLUrl, (geometry) => {
                        if (mesh) scene.remove(mesh);
                        const material = new THREE.MeshPhongMaterial({
                            color: 0xaaaaaa,
                            specular: 0x111111,
                            shininess: 30
                        });
                        mesh = new THREE.Mesh(geometry, material);
                        scene.add(mesh);
                    });
                }
            }, false);

            // Get theme-appropriate colors with proper fallbacks
            const styles = getComputedStyle(document.documentElement);
            const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
            const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
            const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
            const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
            const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(stlBackground);

            // Initialize camera using CAMERA_SETTINGS.CARD as default (cards are default shape)
            const defaultCam = CAMERA_SETTINGS.CARD;
            camera = new THREE.PerspectiveCamera(defaultCam.fov, initW / initH, defaultCam.near, defaultCam.far);
            camera.position.set(defaultCam.position.x, defaultCam.position.y, defaultCam.position.z);
            camera.up.set(defaultCam.up.x, defaultCam.up.y, defaultCam.up.z);
            camera.lookAt(defaultCam.target.x, defaultCam.target.y, defaultCam.target.z);

            // Add camera to scene so attached lights will work
            scene.add(camera);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(defaultCam.target.x, defaultCam.target.y, defaultCam.target.z);

            // Mobile-optimized controls
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = isMobile ? 0.5 : 1.0;
            controls.zoomSpeed = isMobile ? 0.8 : 1.2;
            controls.panSpeed = isMobile ? 0.5 : 0.8;

            // Touch-specific settings
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            controls.update();

            // Theme-appropriate lighting with intensity control
            const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);

            // Position the directional light for optimal detail visibility
            // Use conventional 3D modeling lighting angles
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'high-contrast') {
                // High contrast mode: conventional three-point lighting for better detail visibility
                // Key light: 45 horizontal, 30 vertical (right side) - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);

                // Fill light: 45 horizontal, 15 vertical (left side) for shadow softening - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                camera.add(fillLight);

                // Subtle back light for edge definition - camera-relative
                const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                backLight.position.set(0, 0.5, -0.866).normalize();
                camera.add(backLight);
            } else {
                // Standard lighting: conventional angle for optimal detail visibility
                // Key light: 45 horizontal, 30 vertical - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);

                // Add subtle fill light for standard modes too - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                camera.add(fillLight);
            }

            scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));

            // Store original light intensities for brightness/contrast controls
            if (typeof storeOriginalLightIntensities === 'function') {
                storeOriginalLightIntensities();
            }

            // Apply current brightness/contrast settings
            if (typeof updatePreviewDisplaySettings === 'function') {
                updatePreviewDisplaySettings();
            }

            // Handle window resize for mobile orientation changes
            window.addEventListener('resize', onWindowResize, false);
        }

        function reinitialize3DScene() {
            // Rebuild lights and materials after context restore
            update3DSceneColors();
        }

        function onWindowResize() {
            const targetW = viewer.clientWidth;
            const targetH = viewer.clientHeight || 420;
            camera.aspect = targetW / targetH;
            camera.updateProjectionMatrix();
            renderer.setSize(targetW, targetH, false);
            render();
        }

        function render() {
            // Guard: only render if renderer is initialized
            if (!renderer) return;
            renderer.render(scene, camera);
        }

        form.onsubmit = async (e) => {
            e.preventDefault();
            errorDiv.style.display = 'none';
            errorText.textContent = '';
            const errorSubtext = document.getElementById('error-subtext');
            if (errorSubtext) {
                errorSubtext.textContent = '';
                errorSubtext.style.display = 'none';
            }

            // Collect input depending on placement mode
            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            let lines = [];
            let originalLines = [];
            if (placementMode === 'manual') {
                lines = getDynamicLineValues();
                originalLines = [...lines];
            } else {
                const src = (document.getElementById('auto-text')?.value || '').trim();
                originalLines = [src];
                // We'll translate the whole text, then wrap to rows based on available cells
            }

            const plateTypeEl = document.querySelector('input[name="plate_type"]:checked');
            const plateType = plateTypeEl ? plateTypeEl.value : 'positive';
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect?.value || 'en-ueb-g1.ctb';

            // Translate text to braille only for positive plates
            let translatedLines = [];
            let perLineLanguageTables = [];
            let translationErrors = [];
            if (plateType === 'positive') {
                if (placementMode === 'manual') {
                    // Per-line translation
                    perLineLanguageTables = new Array(lines.length).fill(tableName);
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line) {
                            try {
                                const perLineTable = (document.getElementById(`line_lang_${i+1}`)?.value) || tableName;
                                perLineLanguageTables[i] = perLineTable;
                                log.debug(`Translating line ${i + 1}: '${line}' to braille using table: ${perLineTable}...`);
                                const brailleText = await translateWithLiblouis(applyCapitalizationSetting(line), 'g2', perLineTable);
                                log.debug(`Line ${i + 1} translated: '${line}'  '${brailleText}'`);
                                translatedLines.push(brailleText);
                            } catch (error) {
                                log.error(`Failed to translate line ${i + 1}:`, error);
                                translationErrors.push({ line: i + 1, text: line, error: error.toString() });
                                translatedLines.push('');
                            }
                        } else {
                            translatedLines.push('');
                        }
                    }
                } else {
                    // Auto mode: BANA-aware wrapping
                    const src = (document.getElementById('auto-text')?.value || '').trim();
                    if (!src) {
                        translatedLines = Array(parseInt(document.getElementById('grid_rows').value) || 4).fill('');
                    } else {
                        try {
                            const shapeTypeEl = document.querySelector('input[name="shape_type"]:checked');
                            const shapeTypeVal = shapeTypeEl ? shapeTypeEl.value : 'card';
                            const cols = getAvailableColumns();
                            const rows = parseInt(document.getElementById('grid_rows').value) || 4;
                            const wrap = await banaAutoWrap(src, cols, rows, tableName);
                            if (wrap.error) {
                                const msg = wrap.warnings && wrap.warnings.length ? wrap.warnings.join(' ') : 'Unable to wrap text per BANA rules.';
                                errorText.textContent = msg;
                                errorDiv.style.display = 'flex';
                                errorDiv.className = 'error-message';
                                // Stop submission
                                resetToGenerateState();
                                return;
                            }
                            translatedLines = wrap.brailleLines;
                            // Provide per-line language tables (single table for all lines in auto mode)
                            perLineLanguageTables = new Array(rows).fill(tableName);
                            // Update originalLines to reflect the per-line source segments
                            originalLines = wrap.textLines;
                            if (wrap.warnings && wrap.warnings.length) {
                                errorText.textContent = wrap.warnings.join(' ');
                                errorDiv.style.display = 'flex';
                                errorDiv.className = 'grade-note';
                            }
                        } catch (error) {
                            log.error('Failed to wrap auto text (BANA):', error);
                            translationErrors.push({ line: 1, text: src, error: error.toString() });
                            translatedLines = Array(parseInt(document.getElementById('grid_rows').value) || 4).fill('');
                        }
                    }
                }
                log.debug('Original lines:', lines);
                log.debug('Translated lines:', translatedLines);

                // Check if any translation errors occurred
                if (translationErrors.length > 0) {
                    // SECURITY: Use safe DOM building instead of innerHTML to prevent XSS
                    // User text (err.text) could contain malicious HTML
                    errorText.textContent = ''; // Clear existing content

                    // Header
                    const header = document.createElement('strong');
                    header.textContent = 'Translation failed for the following lines:';
                    errorText.appendChild(header);
                    errorText.appendChild(document.createElement('br'));
                    errorText.appendChild(document.createElement('br'));

                    // Error details - use textContent to escape any HTML in user input
                    translationErrors.forEach(err => {
                        const lineText = document.createTextNode(`Line ${err.line}: "${err.text}"`);
                        errorText.appendChild(lineText);
                        errorText.appendChild(document.createElement('br'));
                    });

                    errorText.appendChild(document.createElement('br'));

                    // Instruction text
                    const instruction = document.createElement('strong');
                    instruction.textContent = 'Please check your text and try again.';
                    errorText.appendChild(instruction);
                    errorText.appendChild(document.createElement('br'));
                    errorText.appendChild(document.createElement('br'));

                    // Common issues list
                    errorText.appendChild(document.createTextNode('Common issues include:'));
                    errorText.appendChild(document.createElement('br'));
                    errorText.appendChild(document.createTextNode(' Special characters that cannot be translated'));
                    errorText.appendChild(document.createElement('br'));
                    errorText.appendChild(document.createTextNode(' Text that is incompatible with the selected braille table'));
                    errorText.appendChild(document.createElement('br'));
                    errorText.appendChild(document.createTextNode(' System errors during translation'));
                    errorText.appendChild(document.createElement('br'));
                    errorText.appendChild(document.createElement('br'));

                    // Footer note
                    const footer = document.createElement('em');
                    footer.textContent = 'The STL file was not generated to prevent producing incorrect braille.';
                    errorText.appendChild(footer);

                    errorDiv.style.display = 'flex';
                    errorDiv.className = 'error-message';

                    // Re-enable button and reset to generate state
                    resetToGenerateState();
                    return;
                }
            } else {
                // Counter plates don't need text - just pass empty lines
                translatedLines = ['', '', '', ''];
                log.debug('Counter plate selected - no text translation needed');
            }
            const settings = {
                // Add 2 only if indicator shapes are ON; otherwise send exact cells
                grid_columns: (document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1')
                    ? String(parseInt(document.getElementById('grid_columns').value) + 2)
                    : String(parseInt(document.getElementById('grid_columns').value)),
                grid_rows: document.getElementById('grid_rows').value,
                cell_spacing: document.getElementById('cell_spacing').value,
                line_spacing: document.getElementById('line_spacing').value,
                dot_spacing: document.getElementById('dot_spacing').value,
                emboss_dot_base_diameter: document.getElementById('emboss_dot_base_diameter').value,
                emboss_dot_height: document.getElementById('emboss_dot_height').value,
                emboss_dot_flat_hat: document.getElementById('emboss_dot_flat_hat').value,
                // Back-compat: if backend expects offset, compute from difference
                // but we also send independent counter base diameter explicitly
                // Separate diameters per recess shape
                hemi_counter_dot_base_diameter: document.getElementById('hemi_counter_dot_base_diameter')?.value || '1.6',
                bowl_counter_dot_base_diameter: document.getElementById('bowl_counter_dot_base_diameter')?.value || '1.6',
                // Back-compat: provide unified base diameter reflecting current recess selection
                counter_dot_base_diameter: (() => {
                    const recessVal = document.querySelector('input[name="recess_shape"]:checked')?.value || '2';
                    if (recessVal === '1') return (document.getElementById('bowl_counter_dot_base_diameter')?.value || '1.6');
                    if (recessVal === '0') return (document.getElementById('hemi_counter_dot_base_diameter')?.value || '1.6');
                    return (document.getElementById('cone_counter_dot_base_diameter')?.value || '1.6');
                })(),
                counter_dot_depth: document.getElementById('counter_dot_depth')?.value || '0.6',
                use_bowl_recess: (document.querySelector('input[name="recess_shape"]:checked')?.value === '1') ? 1 : 0,
                recess_shape: parseInt(document.querySelector('input[name="recess_shape"]:checked')?.value || '2'),
                // Cone parameters
                cone_counter_dot_base_diameter: document.getElementById('cone_counter_dot_base_diameter')?.value || '1.6',
                cone_counter_dot_height: document.getElementById('cone_counter_dot_height')?.value || '0.8',
                cone_counter_dot_flat_hat: document.getElementById('cone_counter_dot_flat_hat')?.value || '0.4',
                card_width: document.getElementById('card_width').value,
                card_height: document.getElementById('card_height').value,
                card_thickness: document.getElementById('card_thickness').value,
                braille_x_adjust: document.getElementById('braille_x_adjust').value,
                braille_y_adjust: document.getElementById('braille_y_adjust').value,
                // Rounded dome settings (optional)
                use_rounded_dots: (document.querySelector('input[name="dot_shape"]:checked')?.value === 'rounded') ? 1 : 0,
                dot_shape: document.querySelector('input[name="dot_shape"]:checked')?.value || 'cone',
                // Legacy fallbacks retained for backend compatibility
                rounded_dot_diameter: document.getElementById('rounded_dot_dome_diameter')?.value || '1.5',
                rounded_dot_height: document.getElementById('rounded_dot_dome_height')?.value || '0.6',
                // New explicit params
                rounded_dot_base_diameter: document.getElementById('rounded_dot_base_diameter')?.value || '2.0',
                rounded_dot_base_height: document.getElementById('rounded_dot_base_height')?.value || document.getElementById('rounded_dot_cylinder_height')?.value || '0.2',
                rounded_dot_cylinder_height: document.getElementById('rounded_dot_base_height')?.value || document.getElementById('rounded_dot_cylinder_height')?.value || '0.2',
                rounded_dot_dome_diameter: document.getElementById('rounded_dot_dome_diameter')?.value || '1.5',
                rounded_dot_dome_height: document.getElementById('rounded_dot_dome_height')?.value || '0.6',
                // New: indicator shapes toggle
                indicator_shapes: (document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1') ? 1 : 0
            };

            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Settings object keys:', Object.keys(settings));
            log.debug('Settings object values:', Object.values(settings));

            // Debug shape values specifically
            const currentDotShape = document.querySelector('input[name="dot_shape"]:checked')?.value;
            const currentRecessShape = document.querySelector('input[name="recess_shape"]:checked')?.value;
            const currentCombinedShape = document.querySelector('input[name="combined_shape"]:checked')?.value;
            log.debug('Shape values - combined:', currentCombinedShape, 'dot_shape:', currentDotShape, 'recess_shape:', currentRecessShape, 'use_rounded_dots:', settings.use_rounded_dots);
            // Rounded-dome inputs are always visible for embossing plate; no dynamic toggle

            // Check if at least one line has content (only for positive plates)
            const hasContent = placementMode === 'manual' ? lines.some(l => l && l.trim()) : ((originalLines[0] || '').trim().length > 0);
            if (plateType === 'positive' && !hasContent) {
                errorText.textContent = 'Please enter text in at least one line.';
                errorDiv.style.display = 'flex';
                return;
            }

            // Validate braille character limits AFTER translation
            const gridColumnsValue = parseInt(document.getElementById('grid_columns').value);
            const indicatorsOn = document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';
            if (plateType === 'positive') {
                const availableColumns = gridColumnsValue;
                // In auto mode, we already wrapped by row capacity; skip line-specific error.
                if (placementMode === 'manual') {
                    for (let i = 0; i < translatedLines.length; i++) {
                        const brailleLine = translatedLines[i];
                        if (brailleLine && brailleLine.length > availableColumns) {
                            const over = brailleLine.length - availableColumns;
                            errorText.textContent = `Line ${i + 1} exceeds ${availableColumns} available braille cells by ${over} cells after translation. Please shorten your text.`;
                            errorDiv.style.display = 'flex';
                            errorDiv.className = 'error-message';
                            return;
                        }
                    }
                }
            } else {
                // For counter plates, all grid columns are available
                for (let i = 0; i < translatedLines.length; i++) {
                    const brailleLine = translatedLines[i];
                    if (brailleLine && brailleLine.length > gridColumnsValue) {
                        const over = brailleLine.length - gridColumnsValue;
                        errorText.textContent = `Line ${i + 1} exceeds ${gridColumnsValue} braille cells by ${over} cells after translation. Please shorten your text.`;
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        return;
                    }
                }
            }

            // Show loading message
            errorText.textContent = plateType === 'positive' ? 'Translating text to braille...' : 'Generating counter plate...';
            errorDiv.style.display = 'flex';
            errorDiv.className = 'error-message info';

            // Get shape type and recess shape to determine if we need the long-wait warning
            const shapeTypeElGen = document.querySelector('input[name="shape_type"]:checked');
            const shapeType = shapeTypeElGen ? shapeTypeElGen.value : 'card';
            const recessShapeEl = document.querySelector('input[name="recess_shape"]:checked');
            const recessShape = recessShapeEl ? recessShapeEl.value : '1';
            const isConeRecess = recessShape === '2';

            // Show special warning for counter plate + cone recess (takes 1-2 minutes)
            if (plateType === 'negative' && isConeRecess) {
                errorSubtext.textContent = 'This may take 12 minutes. Leaving or refreshing this page will cancel the process.';
                errorSubtext.style.display = 'block';
            } else {
                errorSubtext.textContent = '';
                errorSubtext.style.display = 'none';
            }

            // Update button to show loading state
            actionBtn.disabled = true;
            actionBtn.textContent = 'Generating...';
            actionBtn.style.opacity = '0.7';
            let cylinderParams = {};

            if (shapeType === 'cylinder') {
                cylinderParams = {
                    diameter_mm: document.getElementById('cylinder_diameter_mm')?.value || '30.75',
                    height_mm: document.getElementById('cylinder_height_mm')?.value || '52',
                    polygonal_cutout_radius_mm: document.getElementById('cylinder_polygonal_cutout_radius_mm')?.value || '13',
                    polygonal_cutout_sides: document.getElementById('cylinder_polygonal_cutout_sides')?.value || '12',
                    seam_offset_deg: document.getElementById('seam_offset_deg')?.value || '355'
                };
            }

            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Shape Type:', shapeType);
            log.debug('Cylinder Params:', cylinderParams);

            // Build original_lines for indicators
            let originalForIndicators = null;
            if (placementMode === 'manual') {
                originalForIndicators = lines;
            } else {
                const srcAuto = (document.getElementById('auto-text')?.value || '').trim();
                const tokens = srcAuto.split(/\s+/).filter(Boolean);
                const rowsCount = parseInt(document.getElementById('grid_rows').value) || 4;
                // Derive per-row indicator from first alphanumeric of each token
                const indicators = tokens.map(tok => {
                    const m = tok.match(/[A-Za-z0-9]/);
                    return m ? m[0] : '';
                });
                // Map indicators to rows cyclically or truncated
                originalForIndicators = new Array(rowsCount).fill('');
                for (let r = 0; r < rowsCount; r++) {
                    originalForIndicators[r] = indicators[r] || '';
                }
            }

            // =====================================================================
            // CLIENT-SIDE CSG GENERATION (PRIMARY AND ONLY METHOD - NO FALLBACK)
            // =====================================================================
            // Per specification: Use CSG worker for all STL generation.
            // This calls /geometry_spec to get the JSON spec, then sends it to
            // the CSG worker for boolean operations and STL export.
            // =====================================================================

            try {
                // Update loading message for client-side generation
                errorText.textContent = 'Generating 3D model (client-side CSG)...';
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message info';

                // Generate STL using client-side CSG worker
                const stlData = await generateSTLClientSide({
                    lines: translatedLines,
                    originalLines: originalForIndicators,
                    placementMode: placementMode,
                    plateType: plateType,
                    shapeType: shapeType,
                    cylinderParams: cylinderParams,
                    perLineLanguageTables: perLineLanguageTables,
                    settings: settings
                });

                // Hide loading message
                errorDiv.style.display = 'none';
                if (errorSubtext) {
                    errorSubtext.textContent = '';
                    errorSubtext.style.display = 'none';
                }

                // Create blob and URL from the ArrayBuffer
                const blob = new Blob([stlData], { type: 'application/octet-stream' });
                if (lastSTLUrl) URL.revokeObjectURL(lastSTLUrl);
                lastSTLUrl = URL.createObjectURL(blob);

                // Generate filename based on plate type
                const currentPlateType = document.querySelector('input[name="plate_type"]:checked').value;
                let filename = 'Embossing_Plate_untitled';

                if (currentPlateType === 'positive') {
                    // Get the current lines from the form
                    const placementModeNow = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
                    let formLines = [];
                    if (placementModeNow === 'manual') {
                        const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
                        for (let i = 1; i <= gridRows; i++) {
                            const input = document.getElementById(`line${i}`);
                            formLines.push(input ? input.value : '');
                        }
                    } else {
                        formLines = [document.getElementById('auto-text')?.value || ''];
                    }

                    // Find first non-empty line and extract the first word
                    for (let i = 0; i < formLines.length; i++) {
                        if (formLines[i].trim()) {
                            const firstWord = formLines[i].trim().split(/\s+/)[0];
                            let sanitized = firstWord.substring(0, 30);
                            sanitized = sanitized.replace(/[^\w\s-]/g, '');
                            sanitized = sanitized.replace(/[-\s]+/g, '_').replace(/^_+|_+$/g, '');

                            if (sanitized) {
                                filename = `Embossing_Plate_${sanitized}`;
                                break;
                            }
                        }
                    }
                } else {
                    // For counter plates, use sequential counter
                    filename = `Universal_Counter_Plate_${getNextCounterPlateNumber()}`;
                }

                // Store the generated STL URL and filename for download
                lastGeneratedSTLUrl = lastSTLUrl;
                lastGeneratedFilename = `${filename}.stl`;
                loadSTL(lastSTLUrl);

                // Change button to download state after successful generation
                actionBtn.disabled = false;
                setToDownloadState();

                log.debug('Client-side CSG generation complete:', filename);

            } catch (csgError) {
                log.error('Client-side CSG generation failed:', csgError);

                // Hide loading message
                errorDiv.style.display = 'none';
                if (errorSubtext) {
                    errorSubtext.textContent = '';
                    errorSubtext.style.display = 'none';
                }

                // Show error - NO FALLBACK TO SERVER
                errorText.textContent = 'STL generation failed: ' + csgError.message;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message';

                // Re-enable button and reset to generate state
                resetToGenerateState();
            }
        };



        function loadSTL(url) {
            init3D();
            const loader = new STLLoader();
            loader.load(url, function (geometry) {
                if (mesh) scene.remove(mesh);

                // Center the geometry first
                geometry.center();

                // Compute bounding box after centering to detect object type
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const width = bbox.max.x - bbox.min.x;
                const height = bbox.max.y - bbox.min.y;
                const depth = bbox.max.z - bbox.min.z;

                // Check if this is a cylinder
                const shapeType = document.querySelector('input[name="shape_type"]:checked')?.value;
                const isCylinder = shapeType === 'cylinder' || height > Math.max(width, depth) * 1.5;

                // Get theme-appropriate mesh color with proper fallback
                const styles = getComputedStyle(document.documentElement);
                const meshColorVar = styles.getPropertyValue('--stl-mesh-color').trim();
                const meshColor = meshColorVar || '#6699cc';
                // Enhanced material for high contrast mode
                const currentTheme = document.documentElement.getAttribute('data-theme');
                let material;

                if (currentTheme === 'high-contrast') {
                    // High contrast material with enhanced specular highlights
                    material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(meshColor),
                        specular: 0xffffff, // White specular highlights for maximum contrast
                        shininess: 300, // Higher shininess for sharper highlights
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                } else {
                    // Standard material for other themes
                    material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(meshColor),
                        specular: 0x111111,
                        shininess: 200,
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                }
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = 0;
                scene.add(mesh);

                // Adjust camera position based on object type using CAMERA_SETTINGS
                if (isCylinder) {
                    // For cylinders: use CAMERA_SETTINGS.CYLINDER configuration
                    // The cylinder's axis is along the Z-direction, centered at origin
                    const cylCam = CAMERA_SETTINGS.CYLINDER;

                    // Ensure camera up vector is correct for upright viewing BEFORE lookAt
                    camera.up.set(cylCam.up.x, cylCam.up.y, cylCam.up.z);

                    // Position camera using CAMERA_SETTINGS (views indicator shapes side)
                    camera.position.set(cylCam.position.x, cylCam.position.y, cylCam.position.z);
                    controls.target.set(cylCam.target.x, cylCam.target.y, cylCam.target.z);
                    camera.lookAt(cylCam.target.x, cylCam.target.y, cylCam.target.z);

                    // Recreate controls so internal up-vector transform matches camera.up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(cylCam.target.x, cylCam.target.y, cylCam.target.z);
                    // Reapply standard control settings
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    // Panning orthogonal to world up for Z-up scenes
                    controls.screenSpacePanning = false;

                    camera.updateProjectionMatrix();
                } else {
                    // For cards: use CAMERA_SETTINGS.CARD configuration
                    const cardCam = CAMERA_SETTINGS.CARD;

                    camera.position.set(cardCam.position.x, cardCam.position.y, cardCam.position.z);
                    camera.up.set(cardCam.up.x, cardCam.up.y, cardCam.up.z);
                    camera.lookAt(cardCam.target.x, cardCam.target.y, cardCam.target.z);
                    // Recreate controls to ensure correct up-vector mapping when switching back to Y-up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(cardCam.target.x, cardCam.target.y, cardCam.target.z);
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    controls.screenSpacePanning = true;
                    camera.updateProjectionMatrix();
                }

                // Force controls to update with new camera settings
                controls.update();
                controls.saveState(); // Save the new camera state as default

                animate();
            }, undefined, function (error) {
                errorText.textContent = 'Failed to load STL: ' + error;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message';
            });
        }

        // Check reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
        let animationEnabled = !prefersReducedMotion.matches;

        function animate() {
            // Guard: don't animate if renderer not initialized
            if (!renderer) return;
            if (animationEnabled) {
                requestAnimationFrame(animate);
            }
            controls && controls.update();
            render();
        }

        function updateRenderingMode() {
            animationEnabled = !prefersReducedMotion.matches;
            if (!animationEnabled && controls) {
                // Stop continuous animation loop, render on demand only
                controls.addEventListener('change', () => {
                    render();
                });
            } else if (animationEnabled) {
                // Resume continuous animation
                animate();
            }
        }

        prefersReducedMotion.addEventListener('change', updateRenderingMode);
        updateRenderingMode();

        // Initialize liblouis web worker and 3D viewer on page load
        let liblouisWorker = null;
        let liblouisReady = false;
        let workerMessageId = 0;
        let pendingWorkerMessages = new Map();

        // CSG Worker for client-side STL generation (standard three-bvh-csg for cards)
        let csgWorker = null;
        let csgWorkerReady = false;
        let csgRequestId = 0;
        let pendingCsgRequests = new Map();

        // Manifold CSG Worker for cylinders (guarantees watertight/manifold output)
        let manifoldWorker = null;
        let manifoldWorkerReady = false;
        let manifoldRequestId = 0;
        let pendingManifoldRequests = new Map();

        // Function to send message to worker and get response
        function sendWorkerMessage(type, data = {}) {
            return new Promise((resolve, reject) => {
                if (!liblouisWorker) {
                    reject(new Error('Worker not initialized'));
                    return;
                }

                const id = ++workerMessageId;
                pendingWorkerMessages.set(id, { resolve, reject });

                liblouisWorker.postMessage({ id, type, data });

                // Timeout after 10 seconds
                setTimeout(() => {
                    if (pendingWorkerMessages.has(id)) {
                        pendingWorkerMessages.delete(id);
                        reject(new Error('Worker message timeout'));
                    }
                }, 10000);
            });
        }

        // Mobile-specific utilities
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Prevent double-tap zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });

        // Handle mobile keyboard visibility and orientation changes
        if (isMobileDevice()) {
            const inputs = document.querySelectorAll('input[type="text"], input[type="number"], select');
            inputs.forEach(input => {
                input.addEventListener('focus', () => {
                    // Scroll input into view when keyboard appears
                    setTimeout(() => {
                        const scrollParent = input.closest('.preview-section, .form-section') || document.scrollingElement;
                        if (scrollParent && scrollParent !== document.scrollingElement) {
                            const parentRect = scrollParent.getBoundingClientRect();
                            const inputRect = input.getBoundingClientRect();
                            const offset = (inputRect.top + inputRect.height / 2) - (parentRect.top + parentRect.height / 2);
                            scrollParent.scrollBy({ top: offset, behavior: 'smooth' });
                        } else {
                            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 300);
                });
            });

            // Handle orientation changes to maintain 200% zoom
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (window.innerWidth <= 768) {
                        applyFontSize(6); // Reset to 200% on orientation change
                    }
                }, 100);
            });
        }

        window.addEventListener('load', async () => {
            try {
                // Initialize liblouis web worker
                log.debug('Initializing liblouis web worker...');

                // Test if worker file is accessible first
                try {
                    const workerResponse = await fetch('/static/liblouis-worker.js');
                    if (!workerResponse.ok) {
                        throw new Error(`Worker file not accessible: ${workerResponse.status}`);
                    }
                    log.debug('Worker file is accessible');
                } catch (fetchError) {
                    log.error('Worker file test failed:', fetchError);
                    throw new Error('Cannot access worker file: ' + fetchError.message);
                }

                liblouisWorker = new Worker('/static/liblouis-worker.js');

                // Handle worker messages
                liblouisWorker.onmessage = function(e) {
                    const { id, type, result } = e.data;

                    if (pendingWorkerMessages.has(id)) {
                        const { resolve, reject } = pendingWorkerMessages.get(id);
                        pendingWorkerMessages.delete(id);

                        if (result.success) {
                            resolve(result);
                        } else {
                            reject(new Error(result.error));
                        }
                    }
                };

                liblouisWorker.onerror = function(error) {
                    log.error('Worker error:', error);
                };

                // Initialize liblouis in the worker
                const initResult = await sendWorkerMessage('init');
                if (initResult.success) {
                    liblouisReady = true;
                    log.debug('Liblouis web worker initialized successfully');
                } else {
                    throw new Error('Failed to initialize liblouis worker: ' + initResult.error);
                }

            } catch (error) {
                log.error('Failed to initialize liblouis worker:', error);
                // Fallback: disable liblouis and show error message
                log.debug('Web worker failed - disabling liblouis translation');
                liblouisReady = false;
                liblouisWorker = null;

                // Show user that translation is disabled
                const errorDiv = document.getElementById('error-message');
                const errorText = document.getElementById('error-text');
                if (errorDiv && errorText) {
                    errorText.textContent = 'Web worker failed to initialize. Braille translation preview is disabled on this deployment.';
                    errorDiv.style.display = 'flex';
                }
            }

            // Initialize CSG Worker for client-side STL generation
            try {
                log.debug('Initializing CSG worker...');

                // Test if CSG worker file is accessible
                const csgWorkerResponse = await fetch('/static/workers/csg-worker.js');
                if (!csgWorkerResponse.ok) {
                    throw new Error(`CSG Worker file not accessible: ${csgWorkerResponse.status}`);
                }
                log.debug('CSG Worker file is accessible');

                // Create module worker
                csgWorker = new Worker('/static/workers/csg-worker.js', { type: 'module' });

                // Set up message handler
                csgWorker.onmessage = function(e) {
                    const { type, requestId, error, stack, geometry, stl } = e.data;

                    if (type === 'ready') {
                        csgWorkerReady = true;
                        log.debug('CSG Worker initialized and ready');
                    } else if (type === 'init_error') {
                        log.error('CSG Worker initialization error:', error, stack);
                        csgWorkerReady = false;
                    } else if (type === 'success' || type === 'error') {
                        // Handle pending request responses
                        if (pendingCsgRequests.has(requestId)) {
                            const { resolve, reject } = pendingCsgRequests.get(requestId);
                            pendingCsgRequests.delete(requestId);

                            if (type === 'success') {
                                resolve({ geometry, stl });
                            } else {
                                reject(new Error(error || 'CSG operation failed'));
                            }
                        }
                    } else if (type === 'pong') {
                        // Health check response
                        if (pendingCsgRequests.has(requestId)) {
                            const { resolve } = pendingCsgRequests.get(requestId);
                            pendingCsgRequests.delete(requestId);
                            resolve({ pong: true });
                        }
                    }
                };

                csgWorker.onerror = function(error) {
                    log.error('CSG Worker error:', error);
                    csgWorkerReady = false;
                };

                // Wait for ready signal with timeout
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        if (!csgWorkerReady) {
                            reject(new Error('CSG Worker initialization timeout'));
                        }
                    }, 10000);

                    const checkReady = setInterval(() => {
                        if (csgWorkerReady) {
                            clearTimeout(timeout);
                            clearInterval(checkReady);
                            resolve();
                        }
                    }, 100);
                });

                log.debug('CSG Worker ready for client-side STL generation');

            } catch (csgError) {
                log.error('Failed to initialize CSG worker:', csgError);
                csgWorkerReady = false;
                csgWorker = null;
                // Don't show error to user yet - will show when they try to generate
            }

            // Initialize Manifold CSG Worker for cylinder generation (guarantees manifold output)
            // MOBILE FIX (2024-12-08): Worker now uses lazy WASM loading to improve mobile compatibility.
            // The worker signals 'ready' immediately, and WASM loads on-demand during first generation.
            try {
                log.debug('Initializing Manifold CSG worker for cylinders...');

                // Test if Manifold worker file is accessible
                const manifoldWorkerResponse = await fetch('/static/workers/csg-worker-manifold.js');
                if (!manifoldWorkerResponse.ok) {
                    throw new Error(`Manifold Worker file not accessible: ${manifoldWorkerResponse.status}`);
                }
                log.debug('Manifold Worker file is accessible');

                // Create module worker
                manifoldWorker = new Worker('/static/workers/csg-worker-manifold.js', { type: 'module' });

                // Set up message handler
                manifoldWorker.onmessage = function(e) {
                    const { type, requestId, error, stack, geometry, stl, wasmLoading } = e.data;

                    if (type === 'ready') {
                        manifoldWorkerReady = true;
                        if (wasmLoading) {
                            log.debug('Manifold CSG Worker ready (WASM loading in background)');
                        } else {
                            log.debug('Manifold CSG Worker initialized with WASM ready');
                        }
                    } else if (type === 'init_error') {
                        // Non-fatal during init - WASM will load on-demand
                        log.warn('Manifold CSG Worker WASM pre-load warning:', error);
                    } else if (type === 'init_status') {
                        // Response to init_check message
                        if (pendingManifoldRequests.has(requestId)) {
                            const { resolve, reject } = pendingManifoldRequests.get(requestId);
                            pendingManifoldRequests.delete(requestId);
                            resolve(e.data);
                        }
                    } else if (type === 'success' || type === 'error') {
                        // Handle pending request responses
                        if (pendingManifoldRequests.has(requestId)) {
                            const { resolve, reject } = pendingManifoldRequests.get(requestId);
                            pendingManifoldRequests.delete(requestId);

                            if (type === 'success') {
                                resolve({ geometry, stl });
                            } else {
                                reject(new Error(error || 'Manifold CSG operation failed'));
                            }
                        }
                    } else if (type === 'pong') {
                        // Health check response
                        if (pendingManifoldRequests.has(requestId)) {
                            const { resolve } = pendingManifoldRequests.get(requestId);
                            pendingManifoldRequests.delete(requestId);
                            resolve({ pong: true });
                        }
                    }
                };

                manifoldWorker.onerror = function(error) {
                    log.error('Manifold CSG Worker error:', error);
                    // Don't set manifoldWorkerReady to false here - worker may recover on retry
                    // The worker handles WASM loading on-demand
                };

                // Wait for ready signal - now much faster since WASM loads lazily
                // Short timeout (5 seconds) just for worker file to load
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        if (!manifoldWorkerReady) {
                            reject(new Error('Manifold CSG Worker failed to load. Your browser may not support module workers.'));
                        }
                    }, 5000); // 5 seconds for worker script (not WASM)

                    const checkReady = setInterval(() => {
                        if (manifoldWorkerReady) {
                            clearTimeout(timeout);
                            clearInterval(checkReady);
                            resolve();
                        }
                    }, 100);
                });

                log.debug('Manifold CSG Worker ready for cylinder STL generation (WASM loads on first use)');

            } catch (manifoldError) {
                log.error('Failed to initialize Manifold CSG worker:', manifoldError);
                log.error('Cylinder generation requires the Manifold worker. Please refresh and try again.');
                manifoldWorkerReady = false;
                manifoldWorker = null;
                // Per specification: NO FALLBACK - cylinder generation requires Manifold worker
                // Users will see an error when attempting to generate cylinders
            }

            // Always default to cylinder on load (card is temporarily disabled)
            const cylinder = document.querySelector('input[name="shape_type"][value="cylinder"]');
            if (cylinder) cylinder.checked = true;

            init3D();
            animate();
        });

        // Function to translate text using liblouis web worker
        async function translateWithLiblouis(text, grade, tableName = null) {
            if (!liblouisReady || !liblouisWorker) {
                throw new Error('Liblouis worker not initialized - translation preview unavailable on this deployment');
            }

            try {
                log.debug('Sending translation request to worker:', text, 'grade:', grade, 'table:', tableName);
                const result = await sendWorkerMessage('translate', { text, grade, tableName });

                if (result.success && result.translation) {
                    log.debug('Translation successful:', result.translation);
                    return result.translation;
                } else {
                    throw new Error('Translation failed: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                log.error('Worker translation failed:', error);
                throw error;
            }
        }

        /**
         * Generate STL using client-side CSG worker.
         * This is the PRIMARY and ONLY method for STL generation.
         * NO FALLBACK to server-side generation.
         *
         * Worker Selection:
         * - Cylinders: Use Manifold worker (guarantees watertight manifold output)
         * - Cards: Use standard three-bvh-csg worker (faster, smaller bundle)
         *
         * See MANIFOLD_CYLINDER_FIX.md for details on why cylinders need Manifold.
         *
         * @param {Object} params - Generation parameters
         * @returns {Promise<ArrayBuffer>} Binary STL data
         */
        async function generateSTLClientSide(params) {
            const { lines, originalLines, placementMode, plateType, shapeType, cylinderParams, perLineLanguageTables, settings } = params;

            // Determine which worker to use based on shape type
            // Per specification: NO FALLBACK between workers
            // - Cylinders MUST use Manifold worker (guarantees watertight manifold output)
            // - Cards use standard three-bvh-csg worker
            // See CLIENT_SIDE_CSG_DOCUMENTATION.md and MANIFOLD_CYLINDER_FIX.md
            let useManifolWorker = false;
            let useStandardWorker = false;

            if (shapeType === 'cylinder') {
                // Cylinders require Manifold worker - NO FALLBACK to standard worker
                // Standard worker produces non-manifold edges on curved surfaces
                if (!manifoldWorkerReady || !manifoldWorker) {
                    // Provide mobile-friendly error message
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    let errorMsg = 'Cylinder generation requires the Manifold 3D engine which failed to load.';
                    if (isMobile) {
                        errorMsg += ' On mobile devices, please ensure you have a stable internet connection and try refreshing the page. If the problem persists, try using a desktop browser.';
                    } else {
                        errorMsg += ' Please refresh the page and try again. If this persists, check your internet connection.';
                    }
                    throw new Error(errorMsg);
                }
                useManifolWorker = true;
                log.debug('Using Manifold CSG worker for cylinder generation (guarantees manifold output)');
            } else {
                // Cards use standard CSG worker
                if (!csgWorkerReady || !csgWorker) {
                    throw new Error('CSG Worker not initialized. Please refresh the page and try again.');
                }
                useStandardWorker = true;
                log.debug('Using standard CSG worker for card generation');
            }

            log.debug('Starting client-side CSG generation...');
            log.debug('Parameters:', { shapeType, plateType, lines: lines?.length, settings, worker: useManifolWorker ? 'manifold' : 'standard' });

            // Step 1: Get geometry specification from server
            log.debug('Fetching geometry specification from /geometry_spec...');
            const specResponse = await fetch('/geometry_spec', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    lines: lines,
                    original_lines: originalLines,
                    placement_mode: placementMode,
                    grade: 'g2',
                    plate_type: plateType,
                    shape_type: shapeType,
                    cylinder_params: cylinderParams,
                    per_line_language_tables: perLineLanguageTables,
                    settings: settings
                })
            });

            if (!specResponse.ok) {
                let errorMsg = 'Failed to get geometry specification';
                try {
                    const errorData = await specResponse.json();
                    if (errorData.error) errorMsg = errorData.error;
                } catch (e) {
                    errorMsg = `Server error: ${specResponse.status} ${specResponse.statusText}`;
                }
                throw new Error(errorMsg);
            }

            const geometrySpec = await specResponse.json();
            log.debug('Received geometry specification:', geometrySpec);
            log.debug(`Geometry spec contains: ${geometrySpec.dots?.length || 0} dots, ${geometrySpec.markers?.length || 0} markers`);

            // Step 2: Send spec to appropriate CSG worker for boolean operations
            // Select worker and tracking map based on shape type
            const selectedWorker = useManifolWorker ? manifoldWorker : csgWorker;
            const pendingRequests = useManifolWorker ? pendingManifoldRequests : pendingCsgRequests;
            const requestId = useManifolWorker ? ++manifoldRequestId : ++csgRequestId;
            const workerName = useManifolWorker ? 'Manifold CSG' : 'Standard CSG';

            log.debug(`Sending geometry spec to ${workerName} worker...`);

            const csgResult = await new Promise((resolve, reject) => {
                // Store the pending request
                pendingRequests.set(requestId, { resolve, reject });

                // Set timeout (2 minutes for complex models)
                const timeout = setTimeout(() => {
                    if (pendingRequests.has(requestId)) {
                        pendingRequests.delete(requestId);
                        reject(new Error(`${workerName} Worker timeout - model may be too complex. Please try with simpler text.`));
                    }
                }, 120000);

                // Clear timeout on completion
                const originalResolve = resolve;
                const originalReject = reject;

                pendingRequests.set(requestId, {
                    resolve: (result) => {
                        clearTimeout(timeout);
                        originalResolve(result);
                    },
                    reject: (error) => {
                        clearTimeout(timeout);
                        originalReject(error);
                    }
                });

                // Send message to selected worker
                selectedWorker.postMessage({
                    type: 'generate',
                    spec: geometrySpec,
                    requestId: requestId
                });
            });

            log.debug(`${workerName} Worker completed successfully`);
            log.debug('Result contains STL data:', csgResult.stl instanceof ArrayBuffer);

            // Return the STL binary data
            return csgResult.stl;
        }


        // ============================================
        // HELP MODAL FUNCTIONALITY
        // ============================================

        /**
         * Help Modal Manager
         * Handles opening, closing, focus trapping, and tab navigation
         */
        (function initHelpModal() {
            const modal = document.getElementById('helpModal');
            const openBtn = document.getElementById('helpModalBtn');
            const closeBtn = document.getElementById('helpModalClose');
            const overlay = document.getElementById('helpModalOverlay');
            const tabs = document.querySelectorAll('.help-tab');
            const panels = document.querySelectorAll('.help-panel');
            
            let previouslyFocusedElement = null;

            // Open modal
            function openHelpModal(initialTab = 'quickstart') {
                if (!modal) return;
                
                previouslyFocusedElement = document.activeElement;
                modal.classList.remove('hidden');
                document.body.style.overflow = 'hidden'; // Prevent background scroll
                
                // Switch to requested tab
                switchHelpTab(`tab-${initialTab}`);
                
                // Focus first tab or close button
                const firstTab = document.getElementById(`tab-${initialTab}`);
                if (firstTab) {
                    setTimeout(() => firstTab.focus(), 50);
                } else if (closeBtn) {
                    closeBtn.focus();
                }
            }

            // Close modal
            function closeHelpModal() {
                if (!modal) return;
                
                modal.classList.add('hidden');
                document.body.style.overflow = '';
                
                // Restore focus to trigger element
                if (previouslyFocusedElement) {
                    previouslyFocusedElement.focus();
                }
            }

            // Tab switching
            function switchHelpTab(tabId) {
                tabs.forEach(tab => {
                    const isActive = tab.id === tabId;
                    tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    tab.setAttribute('tabindex', isActive ? '0' : '-1');
                });

                panels.forEach(panel => {
                    const associatedTab = document.querySelector(`[aria-controls="${panel.id}"]`);
                    if (associatedTab && associatedTab.id === tabId) {
                        panel.hidden = false;
                    } else {
                        panel.hidden = true;
                    }
                });
            }

            // Focus trap - keep focus inside modal
            function trapFocus(event) {
                if (!modal || modal.classList.contains('hidden')) return;
                
                const focusableElements = modal.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                if (event.key === 'Tab') {
                    if (event.shiftKey) {
                        // Shift+Tab: if on first element, go to last
                        if (document.activeElement === firstElement) {
                            event.preventDefault();
                            lastElement.focus();
                        }
                    } else {
                        // Tab: if on last element, go to first
                        if (document.activeElement === lastElement) {
                            event.preventDefault();
                            firstElement.focus();
                        }
                    }
                }
            }

            // Keyboard navigation for tabs (arrow keys)
            function handleTabKeyboard(event) {
                const currentTab = event.target;
                if (!currentTab.classList.contains('help-tab')) return;

                const tabArray = Array.from(tabs);
                const currentIndex = tabArray.indexOf(currentTab);
                let newIndex;

                switch (event.key) {
                    case 'ArrowRight':
                    case 'ArrowDown':
                        event.preventDefault();
                        newIndex = (currentIndex + 1) % tabArray.length;
                        break;
                    case 'ArrowLeft':
                    case 'ArrowUp':
                        event.preventDefault();
                        newIndex = (currentIndex - 1 + tabArray.length) % tabArray.length;
                        break;
                    case 'Home':
                        event.preventDefault();
                        newIndex = 0;
                        break;
                    case 'End':
                        event.preventDefault();
                        newIndex = tabArray.length - 1;
                        break;
                    default:
                        return;
                }

                const newTab = tabArray[newIndex];
                switchHelpTab(newTab.id);
                newTab.focus();
            }

            // Event listeners
            if (openBtn) {
                openBtn.addEventListener('click', () => openHelpModal());
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', closeHelpModal);
            }

            if (overlay) {
                overlay.addEventListener('click', closeHelpModal);
            }

            // Escape key to close
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
                    closeHelpModal();
                }
            });

            // Focus trap
            document.addEventListener('keydown', trapFocus);

            // Tab clicks
            tabs.forEach(tab => {
                tab.addEventListener('click', () => switchHelpTab(tab.id));
                tab.addEventListener('keydown', handleTabKeyboard);
            });

            // Expose for other scripts (e.g., info panel "Learn more" link, inline tab switching)
            window.openHelpModal = openHelpModal;
            window.switchHelpTab = switchHelpTab;
        })();

    </script>

    <!-- Help Modal -->
    <div class="modal hidden" id="helpModal" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
        <div class="modal-overlay" id="helpModalOverlay"></div>
        <div class="modal-content modal-large">
            <div class="modal-header">
                <h2 id="helpModalTitle">Help & Guide</h2>
                <button type="button" class="modal-close" id="helpModalClose" aria-label="Close help guide">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="modal-body help-modal-body">
                <!-- Tab Navigation -->
                <div class="help-tabs" role="tablist" aria-label="Help sections">
                    <button class="help-tab" role="tab" aria-selected="true" aria-controls="helpPanelQuickStart" id="tab-quickstart" tabindex="0">Quick Start</button>
                    <button class="help-tab" role="tab" aria-selected="false" aria-controls="helpPanelBusinessCard" id="tab-businesscard" tabindex="-1">Business Card Choices</button>
                    <button class="help-tab" role="tab" aria-selected="false" aria-controls="helpPanelFormatting" id="tab-formatting" tabindex="-1">Formatting Rules</button>
                    <button class="help-tab" role="tab" aria-selected="false" aria-controls="helpPanelExamples" id="tab-examples" tabindex="-1">Examples</button>
                    <button class="help-tab" role="tab" aria-selected="false" aria-controls="helpPanelResources" id="tab-resources" tabindex="-1">Resources</button>
                </div>

                <!-- Tab Panels -->
                <div class="help-panels">
                    <!-- Quick Start Panel -->
                    <div class="help-panel" role="tabpanel" aria-labelledby="tab-quickstart" id="helpPanelQuickStart">
                        <h3>Making a Braille Business Card</h3>
                        
                        <h4>Quick Start Steps</h4>
                        <ol>
                            <li>Type your info under <strong>Enter Text for Braille Translation</strong>.</li>
                            <li>Set <strong>Placement Mode</strong> to <strong>Auto Placement</strong> (recommended).</li>
                            <li>Click <strong>Preview Braille Translation</strong>. Fix any warnings.</li>
                            <li>Click <strong>Generate STL</strong>, review the 3D preview, then <strong>Download STL</strong>.</li>
                            <li>Switch <strong>Select Plate to Generate</strong> to <strong>Universal Counter Plate</strong> and <strong>Download STL</strong> again.</li>
                        </ol>

                        <h4>What to Include</h4>
                        <p>Standard business cards fit <strong>~4 lines of braille with ~13-14 cells per line</strong>. Suggested layout:</p>
                        <ul>
                            <li><strong>Line 1:</strong> Your name</li>
                            <li><strong>Line 2:</strong> Organization/company (optional if clear in email)</li>
                            <li><strong>Line 3:</strong> Phone number</li>
                            <li><strong>Line 4:</strong> Email address</li>
                        </ul>
                        
                        <p><button type="button" class="btn-link" onclick="window.switchHelpTab('tab-businesscard')">Learn more about choosing what to include </button></p>
                    </div>

                    <!-- Business Card Choices Panel -->
                    <div class="help-panel" role="tabpanel" aria-labelledby="tab-businesscard" id="helpPanelBusinessCard" hidden>
                        <h3>Choosing What to Include</h3>
                        
                        <p>Braille takes more space than print. A standard business card can only fit about <strong>4 lines with 13-14 braille cells each</strong>. You'll need to prioritize.</p>

                        <h4>Priority Guide</h4>
                        <table class="help-table">
                            <thead>
                                <tr><th>Element</th><th>Priority</th><th>Notes</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>Name</td><td>Essential</td><td>Almost always include</td></tr>
                                <tr><td>Organization</td><td>High</td><td>Can omit if in email/web address</td></tr>
                                <tr><td>Phone</td><td>High</td><td>Pick phone OR email if space tight</td></tr>
                                <tr><td>Email</td><td>High</td><td>Often most useful contact method</td></tr>
                                <tr><td>Website</td><td>Medium</td><td>Include if essential; can omit</td></tr>
                                <tr><td>Job Title</td><td>Low</td><td>Usually omitted for space</td></tr>
                                <tr><td>Mailing Address</td><td>Low</td><td>Usually omitted  too long</td></tr>
                                <tr><td>Fax</td><td>Low</td><td>Usually omitted</td></tr>
                            </tbody>
                        </table>

                        <h4>If It Doesn't Fit</h4>
                        <p>Try these strategies in order (from BANA guidelines):</p>
                        <ol>
                            <li><strong>Remove capitalization indicators</strong>  Type in lowercase to save ~1 cell per capital</li>
                            <li><strong>Remove middle initial</strong> from your name</li>
                            <li><strong>Use first initial only</strong>  "J. Smith" instead of "Jane Smith"</li>
                            <li><strong>Abbreviate common words</strong>  "Lib" for Library, "Amer" for American, "Nat" for National</li>
                            <li><strong>Omit organization</strong> if it appears in your email/web address</li>
                            <li><strong>Use fold-over card stock</strong> for more space (doubles available area)</li>
                        </ol>

                        <h4>Final Check</h4>
                        <p>Ask yourself: <em>"Can someone identify me and contact me with just this information?"</em> If yes, you're done!</p>
                        
                        <p><a href="https://github.com/BrennenJohnston/braille-card-and-cylinder-stl-generator/blob/main/docs/guides/BUSINESS_CARD_TRANSLATION_GUIDE.md" target="_blank" rel="noopener noreferrer">Read the full guide (opens in new tab) </a></p>
                    </div>

                    <!-- Formatting Rules Panel -->
                    <div class="help-panel" role="tabpanel" aria-labelledby="tab-formatting" id="helpPanelFormatting" hidden>
                        <h3>Formatting for Maximum Space</h3>

                        <h4>Phone Numbers</h4>
                        <p><strong>Best practice:</strong> Use periods as separators: <code>123.456.7890</code></p>
                        <ul>
                            <li>Periods preserve number groupings without extra braille markers</li>
                            <li>Remove parentheses  they waste space</li>
                            <li>The numeric indicator (#) is kept at the start</li>
                        </ul>
                        <p><strong>Example:</strong> <code>(123) 456-7890</code>  Enter as <code>123.456.7890</code></p>

                        <h4>Email Addresses</h4>
                        <p>If an email must wrap to a second line:</p>
                        <ol>
                            <li><strong>Best:</strong> Split after punctuation (@, period, hyphen)</li>
                            <li><strong>OK:</strong> Split between syllables</li>
                            <li><strong>Avoid:</strong> Splitting in the middle of a syllable</li>
                        </ol>
                        <p>The continuation indicator (dot 5) should appear at the end of the first line. Start the continuation at cell 1.</p>

                        <h4>Web Addresses</h4>
                        <p>Same rules as email. Split after punctuation first (colon, period, slash).</p>
                        <p><strong>Tip:</strong> Omit "https://" or "www." if the domain is clear without it.</p>

                        <h4>Capitalization</h4>
                        <p>Each capital letter in braille adds a capitalization indicator (1 extra cell). To save space:</p>
                        <ul>
                            <li>Type in lowercase: "jane smith" instead of "Jane Smith"</li>
                            <li>Braille readers understand this is for space efficiency</li>
                        </ul>
                    </div>

                    <!-- Examples Panel -->
                    <div class="help-panel" role="tabpanel" aria-labelledby="tab-examples" id="helpPanelExamples" hidden>
                        <h3>Real-World Examples</h3>
                        <p>These examples are from BANA guidelines, showing common scenarios and solutions.</p>

                        <h4>Example 1: Organization in Email</h4>
                        <div class="example-box">
                            <p><strong>Print card:</strong></p>
                            <pre>Harry Potter
Hogwarts School
harry@hogwarts.edu</pre>
                            <p><strong>Strategy:</strong> Omit capitals from organization (it's in the email). Wrap email after @.</p>
                            <p><strong>Result:</strong> 4 lines, fits perfectly.</p>
                        </div>

                        <h4>Example 2: Long Name</h4>
                        <div class="example-box">
                            <p><strong>Print card:</strong></p>
                            <pre>Liesel A. Schimmelfennig
US Army Corps of Engineers</pre>
                            <p><strong>Strategy:</strong> Name spans 2 lines. Omit organization (it's in email). Omit phone if needed.</p>
                        </div>

                        <h4>Example 3: Nickname Option</h4>
                        <div class="example-box">
                            <p><strong>Print card:</strong></p>
                            <pre>Francine (Fran) Rikard
Albuquerque AC</pre>
                            <p><strong>Strategy:</strong> Client chose nickname "Fran" to preserve capital indicators on name.</p>
                        </div>

                        <p><a href="https://github.com/BrennenJohnston/braille-card-and-cylinder-stl-generator/blob/main/docs/guides/BUSINESS_CARD_TRANSLATION_GUIDE.md#examples" target="_blank" rel="noopener noreferrer">See more examples in the full guide </a></p>
                    </div>

                    <!-- Resources Panel -->
                    <div class="help-panel" role="tabpanel" aria-labelledby="tab-resources" id="helpPanelResources" hidden>
                        <h3>Resources & Credits</h3>

                        <h4>Official Standards</h4>
                        <ul>
                            <li><a href="https://www.brailleauthority.org/braille-signage-guidelines" target="_blank" rel="noopener noreferrer">BANA Braille Signage Guidelines</a></li>
                            <li><a href="https://www.brailleauthority.org/size-and-spacing-braille-characters" target="_blank" rel="noopener noreferrer">BANA Size and Spacing of Braille Characters</a></li>
                            <li><a href="https://iceb.org/ueb.html" target="_blank" rel="noopener noreferrer">The Rules of Unified English Braille (ICEB)</a></li>
                        </ul>

                        <h4>This Application</h4>
                        <ul>
                            <li><a href="https://github.com/BrennenJohnston/braille-card-and-cylinder-stl-generator" target="_blank" rel="noopener noreferrer">GitHub Repository</a></li>
                            <li><a href="https://github.com/BrennenJohnston/braille-card-and-cylinder-stl-generator/blob/main/docs/guides/BUSINESS_CARD_TRANSLATION_GUIDE.md" target="_blank" rel="noopener noreferrer">Full Business Card Translation Guide</a></li>
                            <li><a href="https://github.com/BrennenJohnston/braille-card-and-cylinder-stl-generator/blob/main/README.md" target="_blank" rel="noopener noreferrer">Project Documentation</a></li>
                        </ul>

                        <h4>For Complex Cases</h4>
                        <p>For professional or complex business cards, consider working with a <strong>UEB-certified transcriber</strong>. They can help with:</p>
                        <ul>
                            <li>International phone numbers</li>
                            <li>Multiple languages</li>
                            <li>Technical credentials or post-nominal letters</li>
                            <li>Large organizations with formal naming requirements</li>
                        </ul>

                        <h4>Acknowledgments</h4>
                        <p>Business card guidance is based on the <em>Guidelines for Brailling Business Cards</em> published by the Braille Authority of North America (BANA).</p>
                        <p>Braille translation powered by <a href="http://liblouis.org/" target="_blank" rel="noopener noreferrer">liblouis</a>.</p>
                        <p>Extra thanks to <strong>Tobi Weinberg</strong> for the substantial time and effort he volunteered to help start this project and see it through.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
