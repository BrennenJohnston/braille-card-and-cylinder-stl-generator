

# ================================================================================

# create_cylinder_shell (lines 1152-1253, 101 lines)
# ================================================================================

def create_cylinder_shell(
    diameter_mm, height_mm, polygonal_cutout_radius_mm, polygonal_cutout_sides=12, align_vertex_theta_rad=None
):
    """
    Create a cylinder with an N-point polygonal cutout along its length.

    Args:
        diameter_mm: Outer diameter of the cylinder
        height_mm: Height of the cylinder
        polygonal_cutout_radius_mm: Inscribed radius of the polygonal cutout
        polygonal_cutout_sides: Number of sides/points of the polygonal cutout (>= 3)
        align_vertex_theta_rad: Optional absolute angle (radians) around Z to rotate
            the polygonal cutout so that one of its vertices aligns with this angle.
            Useful to align a cutout vertex with the triangle indicator column
            (including seam offset) on the cylinder surface.
    """
    outer_radius = diameter_mm / 2

    # Create the main solid cylinder
    main_cylinder = trimesh.creation.cylinder(radius=outer_radius, height=height_mm, sections=64)

    # If no cutout is specified, return the solid cylinder
    if polygonal_cutout_radius_mm <= 0:
        return main_cylinder

    # Create an N-point polygonal prism for the cutout
    # The prism extends the full height of the cylinder
    # Calculate the circumscribed radius from the inscribed radius
    # For a regular N-gon: circumscribed_radius = inscribed_radius / cos(pi/N)
    # Clamp the number of sides for safety
    polygonal_cutout_sides = max(3, int(polygonal_cutout_sides))
    circumscribed_radius = polygonal_cutout_radius_mm / np.cos(np.pi / polygonal_cutout_sides)

    # Create the polygon vertices
    angles = np.linspace(0, 2 * np.pi, polygonal_cutout_sides, endpoint=False)
    vertices_2d = []
    for angle in angles:
        x = circumscribed_radius * np.cos(angle)
        y = circumscribed_radius * np.sin(angle)
        vertices_2d.append([x, y])

    # Create the polygonal prism by extruding the polygon along the Z-axis
    # The prism should be slightly longer than the cylinder to ensure complete cutting
    prism_height = height_mm + 2.0  # Add 1mm on each end

    # Create the polygonal prism using trimesh
    # We'll create it by making a 3D mesh from the 2D polygon
    # Create the polygon using shapely
    from shapely.geometry import Polygon as ShapelyPolygon
    from trimesh.creation import extrude_polygon

    polygon = ShapelyPolygon(vertices_2d)

    # Extrude the polygon to create the prism
    cutout_prism = extrude_polygon(polygon, height=prism_height)

    # Center the prism vertically at origin (extrude_polygon creates it from Z=0 to Z=height)
    prism_center_z = cutout_prism.bounds[1][2] / 2.0  # Get center of prism's Z bounds
    cutout_prism.apply_translation([0, 0, -prism_center_z])

    # Optionally rotate the cutout so a vertex aligns with a target angle around Z
    # By construction, one vertex initially lies along +X (theta = 0). Rotating by
    # align_vertex_theta_rad moves that vertex to the desired absolute angle.
    if align_vertex_theta_rad is not None:
        Rz = trimesh.transformations.rotation_matrix(align_vertex_theta_rad, [0.0, 0.0, 1.0])
        cutout_prism.apply_transform(Rz)

    # Debug: Print prism and cylinder dimensions
    print(f'DEBUG: Cylinder height: {height_mm}mm, extends from Z={-height_mm / 2:.2f} to Z={height_mm / 2:.2f}')
    print(
        f'DEBUG: Prism height: {prism_height}mm, after centering extends from Z={-prism_height / 2:.2f} to Z={prism_height / 2:.2f}'
    )
    print(f'DEBUG: Prism bounds after centering: {cutout_prism.bounds}')

    # Center the prism at the origin - no translation needed
    # Both the cylinder and prism are already centered at origin
    # The prism extends from -prism_height/2 to +prism_height/2
    # The cylinder extends from -height_mm/2 to +height_mm/2
    # Since prism_height > height_mm, the prism will cut through the entire cylinder

    # Perform boolean subtraction to create the cutout
    try:
        result = trimesh.boolean.difference([main_cylinder, cutout_prism], engine='manifold')
        if result.is_watertight:
            return result
    except Exception as e:
        print(f'Warning: Boolean operation failed with manifold engine: {e}')

    # Fallback: try with default engine
    try:
        result = trimesh.boolean.difference([main_cylinder, cutout_prism])
        if result.is_watertight:
            return result
    except Exception as e:
        print(f'Warning: Boolean operation failed with default engine: {e}')

    # Final fallback: return the original cylinder if all boolean operations fail
    print('Warning: Could not create polygonal cutout, returning solid cylinder')
    return main_cylinder




# create_cylinder_triangle_marker (lines 1253-1356, 103 lines)
# ================================================================================

def create_cylinder_triangle_marker(
    x_arc,
    y_local,
    settings: CardSettings,
    cylinder_diameter_mm,
    seam_offset_deg=0,
    height_mm=0.6,
    for_subtraction=True,
    point_left=False,
):
    """
    Create a triangular prism for cylinder surface marking.

    Args:
        x_arc: Arc length position along circumference (same units as mm on the card)
        y_local: Z position relative to cylinder center (card Y minus height/2)
        settings: CardSettings object
        cylinder_diameter_mm: Cylinder diameter
        seam_offset_deg: Rotation offset for seam
        height_mm: Depth/height of the triangle marker (default 0.6mm)
        for_subtraction: If True, creates a tool for boolean subtraction to make recesses
        point_left: If True, mirror triangle so apex points toward negative tangent (left in unrolled view)
    """
    r_hat, t_hat, z_hat, radius, circumference, theta = _compute_cylinder_frame(
        x_arc, cylinder_diameter_mm, seam_offset_deg
    )

    # Triangle dimensions - standard guide triangle shape
    base_height = 2.0 * settings.dot_spacing  # Vertical extent
    triangle_width = settings.dot_spacing  # Horizontal extent (pointing right in tangent direction)

    # Build 2D triangle in local tangent (X=t) and vertical (Y=z) plane
    # Vertices: base on left, apex pointing right
    from shapely.geometry import Polygon as ShapelyPolygon

    if point_left:
        # Mirror along vertical axis so apex points left (negative tangent)
        tri_2d = ShapelyPolygon(
            [
                (0.0, -settings.dot_spacing),  # Bottom of base (right side)
                (0.0, settings.dot_spacing),  # Top of base (right side)
                (-triangle_width, 0.0),  # Apex (pointing left)
            ]
        )
    else:
        tri_2d = ShapelyPolygon(
            [
                (0.0, -settings.dot_spacing),  # Bottom of base
                (0.0, settings.dot_spacing),  # Top of base
                (triangle_width, 0.0),  # Apex (pointing right/tangentially)
            ]
        )

    # For subtraction tool, we need to extend beyond the surface
    if for_subtraction:
        # Extrude to create cutting tool that extends from outside to inside the cylinder
        extrude_height = height_mm + 1.0  # Total extrusion depth
        tri_prism_local = trimesh.creation.extrude_polygon(tri_2d, height=extrude_height)

        # The prism is created with Z from 0 to extrude_height
        # We need to center it so it extends from -0.5 to (height_mm + 0.5)
        tri_prism_local.apply_translation([0, 0, -0.5])

        # Build transform: map local coords to cylinder coords
        T = np.eye(4)
        T[:3, 0] = t_hat  # X axis (tangential)
        T[:3, 1] = z_hat  # Y axis (vertical)
        T[:3, 2] = r_hat  # Z axis (radial outward)

        # Position so the prism starts outside the cylinder and cuts inward
        # The prism's Z=0 should be at radius (cylinder surface)
        center_pos = r_hat * radius + z_hat * y_local
        T[:3, 3] = center_pos

        # Apply the transform
        tri_prism_local.apply_transform(T)

        # Debug output - only print for first triangle to avoid spam
        if abs(y_local) < settings.line_spacing:  # First row
            print(f'DEBUG: Triangle at theta={np.degrees(theta):.1f}Â°, y_local={y_local:.1f}mm')
            print(f'DEBUG: Triangle bounds after transform: {tri_prism_local.bounds}')
            print(f'DEBUG: Cylinder radius: {radius}mm')
    else:
        # For extruded triangle (outward from cylinder surface)
        tri_prism_local = trimesh.creation.extrude_polygon(tri_2d, height=height_mm)

        # Build transform for outward extrusion
        T = np.eye(4)
        T[:3, 0] = t_hat  # X axis (tangential)
        T[:3, 1] = z_hat  # Y axis (vertical)
        T[:3, 2] = r_hat  # Z axis (radial outward)

        # Slightly embed the triangle into the cylinder so union attaches robustly
        embed = max(getattr(settings, 'epsilon', 0.001), 0.05)
        # Place the base of the prism just inside the surface (radius - embed), extruding outward
        center_pos = r_hat * (radius - embed) + z_hat * y_local
        T[:3, 3] = center_pos

        tri_prism_local.apply_transform(T)

    return tri_prism_local




# create_cylinder_line_end_marker (lines 1356-1441, 85 lines)
# ================================================================================

def create_cylinder_line_end_marker(
    x_arc, y_local, settings: CardSettings, cylinder_diameter_mm, seam_offset_deg=0, height_mm=0.5, for_subtraction=True
):
    """
    Create a line (rectangular prism) for end of row marking on cylinder surface.

    Args:
        x_arc: Arc length position along circumference (same units as mm on the card)
        y_local: Z position relative to cylinder center (card Y minus height/2)
        settings: CardSettings object
        cylinder_diameter_mm: Cylinder diameter
        seam_offset_deg: Rotation offset for seam
        height_mm: Depth/height of the line marker (default 0.5mm)
        for_subtraction: If True, creates a tool for boolean subtraction to make recesses
    """
    radius = cylinder_diameter_mm / 2.0
    circumference = np.pi * cylinder_diameter_mm

    # Angle around cylinder for planar x position
    theta = (x_arc / circumference) * 2.0 * np.pi + np.radians(seam_offset_deg)

    # Local orthonormal frame at theta
    r_hat = np.array([np.cos(theta), np.sin(theta), 0.0])  # radial outward
    t_hat = np.array([-np.sin(theta), np.cos(theta), 0.0])  # tangential
    z_hat = np.array([0.0, 0.0, 1.0])  # cylinder axis

    # Line dimensions - vertical line at end of row
    line_height = 2.0 * settings.dot_spacing  # Vertical extent (same as cell height)
    line_width = settings.dot_spacing  # Horizontal extent in tangent direction

    # Build 2D rectangle in local tangent (X=t) and vertical (Y=z) plane
    # Rectangle centered at origin, extending in both directions
    from shapely.geometry import Polygon as ShapelyPolygon

    line_2d = ShapelyPolygon(
        [
            (-line_width / 2, -settings.dot_spacing),  # Bottom left
            (line_width / 2, -settings.dot_spacing),  # Bottom right
            (line_width / 2, settings.dot_spacing),  # Top right
            (-line_width / 2, settings.dot_spacing),  # Top left
        ]
    )

    # For subtraction tool, we need to extend beyond the surface
    if for_subtraction:
        # Extrude to create cutting tool that extends from outside to inside the cylinder
        extrude_height = height_mm + 1.0  # Total extrusion depth
        line_prism_local = trimesh.creation.extrude_polygon(line_2d, height=extrude_height)

        # The prism is created with Z from 0 to extrude_height
        # We need to center it so it extends from -0.5 to (height_mm + 0.5)
        line_prism_local.apply_translation([0, 0, -0.5])

        # Build transform: map local coords to cylinder coords
        T = np.eye(4)
        T[:3, 0] = t_hat  # X axis (tangential)
        T[:3, 1] = z_hat  # Y axis (vertical)
        T[:3, 2] = r_hat  # Z axis (radial outward)

        # Position so the prism starts outside the cylinder and cuts inward
        # The prism's Z=0 should be at radius (cylinder surface)
        center_pos = r_hat * radius + z_hat * y_local
        T[:3, 3] = center_pos

        # Apply the transform
        line_prism_local.apply_transform(T)
    else:
        # For direct recessed line (not used currently)
        line_prism_local = trimesh.creation.extrude_polygon(line_2d, height=height_mm)

        # Build transform for inward extrusion
        T = np.eye(4)
        T[:3, 0] = t_hat  # X axis
        T[:3, 1] = z_hat  # Y axis
        T[:3, 2] = -r_hat  # Z axis (inward)

        # Position recessed into surface
        center_pos = r_hat * (radius - height_mm / 2.0) + z_hat * y_local
        T[:3, 3] = center_pos

        line_prism_local.apply_transform(T)

    return line_prism_local




# create_cylinder_character_shape (lines 1441-1566, 125 lines)
# ================================================================================

def create_cylinder_character_shape(
    character,
    x_arc,
    y_local,
    settings: CardSettings,
    cylinder_diameter_mm,
    seam_offset_deg=0,
    height_mm=1.0,
    for_subtraction=True,
):
    """
    Create a 3D character shape (capital letter A-Z or number 0-9) for end of row marking on cylinder surface.
    Uses matplotlib's TextPath for proper font rendering.

    Args:
        character: Single character (A-Z or 0-9)
        x_arc: Arc length position along circumference (same units as mm on the card)
        y_local: Z position relative to cylinder center (card Y minus height/2)
        settings: CardSettings object
        cylinder_diameter_mm: Cylinder diameter
        seam_offset_deg: Seam rotation offset in degrees
        height_mm: Depth of the character recess (default 1.0mm)
        for_subtraction: If True, creates a tool for boolean subtraction

    Returns:
        Trimesh object representing the 3D character marker transformed to cylinder
    """
    # Debug: cylinder character marker generation

    radius = cylinder_diameter_mm / 2.0
    circumference = np.pi * cylinder_diameter_mm

    # Angle around cylinder for planar x position
    theta = (x_arc / circumference) * 2.0 * np.pi + np.radians(seam_offset_deg)

    # Local orthonormal frame at theta
    r_hat = np.array([np.cos(theta), np.sin(theta), 0.0])  # radial outward
    t_hat = np.array([-np.sin(theta), np.cos(theta), 0.0])  # tangential
    z_hat = np.array([0.0, 0.0, 1.0])  # cylinder axis

    # Define character size based on braille cell dimensions (scaled 56.25% bigger than original)
    char_height = 2 * settings.dot_spacing + 4.375  # 9.375mm for default 2.5mm dot spacing
    char_width = settings.dot_spacing * 0.8 + 2.6875  # 4.6875mm for default 2.5mm dot spacing

    # Get the character definition
    char_upper = character.upper()
    if not (char_upper.isalpha() or char_upper.isdigit()):
        # Fall back to rectangle for undefined characters
        return create_cylinder_line_end_marker(
            x_arc, y_local, settings, cylinder_diameter_mm, seam_offset_deg, height_mm, for_subtraction
        )

    try:
        # Build character polygon using shared helper
        char_2d = _build_character_polygon(char_upper, char_width, char_height)
        if char_2d is None:
            return create_cylinder_line_end_marker(
                x_arc, y_local, settings, cylinder_diameter_mm, seam_offset_deg, height_mm, for_subtraction
            )

    except Exception as e:
        print(f'WARNING: Failed to create character shape using matplotlib: {e}')
        print('Falling back to rectangle marker')
        return create_cylinder_line_end_marker(
            x_arc, y_local, settings, cylinder_diameter_mm, seam_offset_deg, height_mm, for_subtraction
        )

    # For subtraction tool, we need to extend beyond the surface
    try:
        if for_subtraction:
            # Extrude to create cutting tool that extends from outside to inside the cylinder
            extrude_height = height_mm + 1.0  # Total extrusion depth
            char_prism_local = trimesh.creation.extrude_polygon(char_2d, height=extrude_height)

            # Ensure the mesh is valid
            if not char_prism_local.is_volume:
                char_prism_local.fix_normals()
                if not char_prism_local.is_volume:
                    print('WARNING: Character mesh is not a valid volume')
                    return create_cylinder_line_end_marker(
                        x_arc, y_local, settings, cylinder_diameter_mm, seam_offset_deg, height_mm, for_subtraction
                    )

            # The prism is created with Z from 0 to extrude_height
            # We need to center it so it extends from -0.5 to (height_mm + 0.5)
            char_prism_local.apply_translation([0, 0, -0.5])

            # Build transform: map local coords to cylinder coords
            T = np.eye(4)
            T[:3, 0] = t_hat  # X axis (tangential)
            T[:3, 1] = z_hat  # Y axis (vertical)
            T[:3, 2] = r_hat  # Z axis (radial outward)

            # Position so the prism starts outside the cylinder and cuts inward
            # The prism's Z=0 should be at radius (cylinder surface)
            center_pos = r_hat * radius + z_hat * y_local
            T[:3, 3] = center_pos

            # Apply the transform
            char_prism_local.apply_transform(T)
        else:
            # For direct recessed character (not used currently)
            char_prism_local = trimesh.creation.extrude_polygon(char_2d, height=height_mm)

            # Build transform for inward extrusion
            T = np.eye(4)
            T[:3, 0] = t_hat  # X axis
            T[:3, 1] = z_hat  # Y axis
            T[:3, 2] = -r_hat  # Z axis (inward)

            # Position recessed into surface
            center_pos = r_hat * (radius - height_mm / 2.0) + z_hat * y_local
            T[:3, 3] = center_pos

            char_prism_local.apply_transform(T)
    except Exception as e:
        print(f'WARNING: Failed to extrude character shape: {e}')
        return create_cylinder_line_end_marker(
            x_arc, y_local, settings, cylinder_diameter_mm, seam_offset_deg, height_mm, for_subtraction
        )

    # Debug: cylinder character marker generated
    return char_prism_local




# create_cylinder_braille_dot (lines 1566-1598, 32 lines)
# ================================================================================

def create_cylinder_braille_dot(x, y, z, settings: CardSettings, cylinder_diameter_mm, seam_offset_deg=0):
    """
    Create a braille dot transformed to cylinder surface.
    """
    # Create the dot at origin (axis along +Z)
    dot = create_braille_dot(0, 0, 0, settings)

    # Cylinder geometry
    radius = cylinder_diameter_mm / 2.0
    circumference = np.pi * cylinder_diameter_mm

    # Angle around cylinder for planar x-position
    theta = (x / circumference) * 2.0 * np.pi + np.radians(seam_offset_deg)

    # Unit vectors at this theta
    r_hat = np.array([np.cos(theta), np.sin(theta), 0.0])
    t_axis = np.array([-np.sin(theta), np.cos(theta), 0.0])  # tangent axis used for rotation

    # Rotate dot so its +Z axis aligns with radial outward direction (r_hat)
    rot_to_radial = trimesh.transformations.rotation_matrix(np.pi / 2.0, t_axis)
    dot.apply_transform(rot_to_radial)

    # Place the dot so its base is flush with the cylinder outer surface
    # Use active height (cone or rounded)
    dot_height = settings.active_dot_height
    center_radial_distance = radius + (dot_height / 2.0)
    center_position = r_hat * center_radial_distance + np.array([0.0, 0.0, y])
    dot.apply_translation(center_position)

    return dot




# generate_cylinder_stl (lines 1598-1840, 242 lines)
# ================================================================================

def generate_cylinder_stl(lines, grade='g1', settings=None, cylinder_params=None, original_lines=None):
    """
    Generate a cylinder-shaped braille card with dots on the outer surface.

    Args:
        lines: List of text lines (braille Unicode)
        grade: Braille grade
        settings: CardSettings object
        cylinder_params: Dictionary with cylinder-specific parameters:
            - diameter_mm: Cylinder diameter
            - height_mm: Cylinder height
            - polygonal_cutout_radius_mm: Inscribed radius of polygonal cutout (0 = no cutout)
            - polygonal_cutout_sides: Number of sides for polygonal cutout (>=3)
            - seam_offset_deg: Rotation offset for seam
        original_lines: List of original text lines (before braille conversion) for character indicators
    """
    if settings is None:
        settings = CardSettings()

    if cylinder_params is None:
        cylinder_params = {
            'diameter_mm': 31.35,
            'height_mm': settings.card_height,
            'polygonal_cutout_radius_mm': 13,
            'polygonal_cutout_sides': 12,
            'seam_offset_deg': 355,
        }

    diameter = float(cylinder_params.get('diameter_mm', 31.35))
    height = float(cylinder_params.get('height_mm', settings.card_height))
    polygonal_cutout_radius = float(cylinder_params.get('polygonal_cutout_radius_mm', 0))
    polygonal_cutout_sides = int(cylinder_params.get('polygonal_cutout_sides', 12) or 12)
    seam_offset = float(cylinder_params.get('seam_offset_deg', 355))

    print(
        f'Creating cylinder mesh - Diameter: {diameter}mm, Height: {height}mm, Cutout Radius: {polygonal_cutout_radius}mm'
    )

    # Print grid and angular spacing information
    radius = diameter / 2
    grid_width = (settings.grid_columns - 1) * settings.cell_spacing
    grid_angle_deg = np.degrees(grid_width / radius)
    cell_spacing_angle_deg = np.degrees(settings.cell_spacing / radius)
    dot_spacing_angle_deg = np.degrees(settings.dot_spacing / radius)

    print('Grid configuration:')
    print(f'  - Grid: {settings.grid_columns} columns Ã {settings.grid_rows} rows')
    print(f'  - Grid width: {grid_width:.1f}mm â {grid_angle_deg:.1f}Â° arc on cylinder')
    print('Angular spacing calculations:')
    print(f'  - Cell spacing: {settings.cell_spacing}mm â {cell_spacing_angle_deg:.2f}Â° on cylinder')
    print(f'  - Dot spacing: {settings.dot_spacing}mm â {dot_spacing_angle_deg:.2f}Â° on cylinder')

    # Compute triangle column absolute angle (including seam) to align polygon cutout vertex
    seam_offset_rad = np.radians(seam_offset)
    grid_angle = grid_width / radius
    start_angle = -grid_angle / 2
    triangle_angle = start_angle + ((settings.grid_columns - 1) * settings.cell_spacing / radius)
    cutout_align_theta = triangle_angle + seam_offset_rad

    # Create cylinder shell with polygon cutout aligned to triangle marker column
    cylinder_shell = create_cylinder_shell(
        diameter, height, polygonal_cutout_radius, polygonal_cutout_sides, align_vertex_theta_rad=cutout_align_theta
    )
    meshes = [cylinder_shell]

    # Layout braille cells on cylinder
    cells, cells_per_row = layout_cylindrical_cells(lines, settings, diameter, height)

    # Calculate vertical centering for markers
    # The braille content spans from the top dot of the first row to the bottom dot of the last row
    # Each cell has dots at offsets [+dot_spacing, 0, -dot_spacing] from cell center
    # So a cell spans 2 * dot_spacing vertically

    # Total content height calculation:
    # - Distance between first and last row centers: (grid_rows - 1) * line_spacing
    # - Half cell height above first row center: dot_spacing
    # - Half cell height below last row center: dot_spacing
    braille_content_height = (settings.grid_rows - 1) * settings.line_spacing + 2 * settings.dot_spacing

    # Calculate where to position the first row's center
    # We want the content centered, so:
    # - Space above content = space below content = (cylinder_height - content_height) / 2
    # - First row center = cylinder_height - space_above - dot_spacing
    space_above = (height - braille_content_height) / 2.0
    first_row_center_y = height - space_above - settings.dot_spacing

    # Add end-of-row text/number indicators and triangle recess markers for ALL rows (not just those with content)
    text_number_meshes = []
    triangle_meshes = []
    for row_num in range(settings.grid_rows):
        # Calculate Y position for this row with vertical centering
        y_pos = first_row_center_y - (row_num * settings.line_spacing) + settings.braille_y_adjust

        # The grid is centered, so start angle is -grid_angle/2
        grid_width = (settings.grid_columns - 1) * settings.cell_spacing
        grid_angle = grid_width / radius
        start_angle = -grid_angle / 2

        # Y position in local cylinder coordinates
        y_local = y_pos - (height / 2.0)

        if getattr(settings, 'indicator_shapes', 1):
            # Add end-of-row text/number indicator at the first cell position (column 0)
            text_number_x = start_angle * radius

            # Determine which character to use for end-of-row indicator
            if original_lines and row_num < len(original_lines):
                original_text = original_lines[row_num].strip()
                if original_text:
                    # Get the first character (letter or number)
                    first_char = original_text[0]
                    if first_char.isalpha() or first_char.isdigit():
                        # Create character shape for end-of-row indicator (1.0mm deep)
                        text_number_mesh = create_cylinder_character_shape(
                            first_char,
                            text_number_x,
                            y_local,
                            settings,
                            diameter,
                            seam_offset,
                            height_mm=1.0,
                            for_subtraction=True,
                        )
                    else:
                        # Fall back to rectangle for non-alphanumeric first characters
                        text_number_mesh = create_cylinder_line_end_marker(
                            text_number_x, y_local, settings, diameter, seam_offset, height_mm=0.5, for_subtraction=True
                        )
                else:
                    # Empty line, use rectangle
                    text_number_mesh = create_cylinder_line_end_marker(
                        text_number_x, y_local, settings, diameter, seam_offset, height_mm=0.5, for_subtraction=True
                    )
            else:
                # No original text provided, use rectangle as fallback
                text_number_mesh = create_cylinder_line_end_marker(
                    text_number_x, y_local, settings, diameter, seam_offset, height_mm=0.5, for_subtraction=True
                )

            text_number_meshes.append(text_number_mesh)

            # Add triangle marker at the last cell position (grid_columns - 1)
            # Calculate X position for the last column
            triangle_angle = start_angle + ((settings.grid_columns - 1) * settings.cell_spacing / radius)
            triangle_x = triangle_angle * radius

            # Create triangle marker for subtraction (will create recess)
            triangle_mesh = create_cylinder_triangle_marker(
                triangle_x, y_local, settings, diameter, seam_offset, height_mm=0.6, for_subtraction=True
            )
            triangle_meshes.append(triangle_mesh)

    # Subtract text/number indicators and triangle markers to recess them into the surface
    print(
        f'DEBUG: Creating {len(text_number_meshes)} text/number recesses and {len(triangle_meshes)} triangle recesses on emboss cylinder'
    )

    # Combine all markers (text/number indicators and triangles) for efficient boolean operations
    all_markers = (text_number_meshes + triangle_meshes) if getattr(settings, 'indicator_shapes', 1) else []

    if all_markers:
        try:
            # Union all markers first
            if len(all_markers) == 1:
                union_markers = all_markers[0]
            else:
                union_markers = trimesh.boolean.union(all_markers, engine='manifold')

            print('DEBUG: Marker union successful, subtracting from cylinder shell...')
            # Subtract from shell to recess
            cylinder_shell = trimesh.boolean.difference([cylinder_shell, union_markers], engine='manifold')
            print('DEBUG: Marker subtraction successful')
        except Exception as e:
            print(f'ERROR: Could not create marker cutouts: {e}')
            # Try fallback with default engine
            try:
                print('DEBUG: Trying marker subtraction with default engine...')
                if len(all_markers) == 1:
                    union_markers = all_markers[0]
                else:
                    union_markers = trimesh.boolean.union(all_markers)
                cylinder_shell = trimesh.boolean.difference([cylinder_shell, union_markers])
                print('DEBUG: Marker subtraction successful with default engine')
            except Exception as e2:
                print(f'ERROR: Marker subtraction failed with all engines: {e2}')

    meshes = [cylinder_shell]

    # Check for overflow based on grid dimensions (accounting for reserved columns when indicators enabled)
    total_cells_needed = sum(len(line.strip()) for line in lines if line.strip())
    reserved = 2 if getattr(settings, 'indicator_shapes', 1) else 0
    total_cells_available = (settings.grid_columns - reserved) * settings.grid_rows

    if total_cells_needed > total_cells_available:
        print(
            f'Warning: Text requires {total_cells_needed} cells but grid has {total_cells_available} cells ({settings.grid_columns - reserved}Ã{settings.grid_rows} after row markers)'
        )

    # Check if grid wraps too far around cylinder
    if grid_angle_deg > 360:
        print(f'Warning: Grid width ({grid_angle_deg:.1f}Â°) exceeds cylinder circumference (360Â°)')

    # Convert dot spacing to angular measurements for cylinder
    radius = diameter / 2
    dot_spacing_angle = settings.dot_spacing / radius  # Convert linear to angular

    # Dot positioning with angular offsets for columns, linear for rows
    dot_col_angle_offsets = [-dot_spacing_angle / 2, dot_spacing_angle / 2]
    dot_row_offsets = [settings.dot_spacing, 0, -settings.dot_spacing]  # Vertical stays linear
    dot_positions = [[0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]]

    # Create dots for each cell
    for braille_char, cell_x, cell_y in cells:
        dots = braille_to_dots(braille_char)

        for i, dot_val in enumerate(dots):
            if dot_val == 1:
                dot_pos = dot_positions[i]
                # Use angular offset for horizontal spacing, converted back to arc length
                dot_x = cell_x + (dot_col_angle_offsets[dot_pos[1]] * radius)
                dot_y = cell_y + dot_row_offsets[dot_pos[0]]
                # Map absolute card Y to cylinder's local Z (centered at 0)
                dot_z_local = dot_y - (height / 2.0)
                z = polygonal_cutout_radius + settings.active_dot_height / 2  # unused in transform now

                dot_mesh = create_cylinder_braille_dot(dot_x, dot_z_local, z, settings, diameter, seam_offset)
                meshes.append(dot_mesh)

    print(f'Created cylinder with {len(meshes) - 1} braille dots')

    # Combine all meshes
    final_mesh = trimesh.util.concatenate(meshes)

    # The cylinder is already created with vertical axis (along Z)
    # No rotation needed - it should stand upright
    # Just ensure the base is at Z=0
    min_z = final_mesh.bounds[0][2]
    final_mesh.apply_translation([0, 0, -min_z])

    return final_mesh




# generate_cylinder_counter_plate (lines 1840-2282, 442 lines)
# ================================================================================

def generate_cylinder_counter_plate(lines, settings: CardSettings, cylinder_params=None):
    """
    Generate a cylinder-shaped counter plate with hemispherical recesses on the OUTER surface.
    Similar to the card counter plate, it creates recesses at ALL possible dot positions.

    Args:
        lines: List of text lines
        settings: CardSettings object
        cylinder_params: Dictionary with cylinder-specific parameters:
            - diameter_mm: Cylinder diameter
            - height_mm: Cylinder height
            - polygonal_cutout_radius_mm: Inscribed radius of polygonal cutout (0 = no cutout)
            - polygonal_cutout_sides: Number of sides for polygonal cutout (>=3)
            - seam_offset_deg: Rotation offset for seam
    """
    if cylinder_params is None:
        cylinder_params = {
            'diameter_mm': 31.35,
            'height_mm': settings.card_height,
            'polygonal_cutout_radius_mm': 13,
            'polygonal_cutout_sides': 12,
            'seam_offset_deg': 355,
        }

    diameter = float(cylinder_params.get('diameter_mm', 31.35))
    height = float(cylinder_params.get('height_mm', settings.card_height))
    polygonal_cutout_radius = float(cylinder_params.get('polygonal_cutout_radius_mm', 0))
    polygonal_cutout_sides = int(cylinder_params.get('polygonal_cutout_sides', 12) or 12)
    seam_offset = float(cylinder_params.get('seam_offset_deg', 355))

    print(
        f'Creating cylinder counter plate - Diameter: {diameter}mm, Height: {height}mm, Cutout Radius: {polygonal_cutout_radius}mm'
    )

    # Use grid dimensions from settings (same as card)
    radius = diameter / 2
    circumference = np.pi * diameter

    # Calculate the total grid width (same as card)
    grid_width = (settings.grid_columns - 1) * settings.cell_spacing

    # Convert grid width to angular width
    grid_angle = grid_width / radius

    # Center the grid around the cylinder (calculate start angle)
    start_angle = -grid_angle / 2

    # Convert cell_spacing from linear to angular
    cell_spacing_angle = settings.cell_spacing / radius

    # Compute first-column triangle absolute angle (including seam) to align polygon cutout vertex
    # Counter plate uses triangle at the first column
    seam_offset_rad = np.radians(seam_offset)
    first_col_angle = start_angle
    cutout_align_theta = first_col_angle + seam_offset_rad

    # Create cylinder shell with polygon cutout aligned to triangle marker column
    cylinder_shell = create_cylinder_shell(
        diameter, height, polygonal_cutout_radius, polygonal_cutout_sides, align_vertex_theta_rad=cutout_align_theta
    )

    # Use grid_rows from settings
    rows_on_cylinder = settings.grid_rows

    # Convert dot spacing to angular measurements
    dot_spacing_angle = settings.dot_spacing / radius

    # Dot positioning with angular offsets for columns, linear for rows
    dot_col_angle_offsets = [-dot_spacing_angle / 2, dot_spacing_angle / 2]
    dot_row_offsets = [settings.dot_spacing, 0, -settings.dot_spacing]  # Vertical stays linear
    dot_positions = [[0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]]

    # Calculate vertical centering
    # The braille content spans from the top dot of the first row to the bottom dot of the last row
    # Each cell has dots at offsets [+dot_spacing, 0, -dot_spacing] from cell center
    # So a cell spans 2 * dot_spacing vertically

    # Total content height calculation:
    # - Distance between first and last row centers: (grid_rows - 1) * line_spacing
    # - Half cell height above first row center: dot_spacing
    # - Half cell height below last row center: dot_spacing
    braille_content_height = (settings.grid_rows - 1) * settings.line_spacing + 2 * settings.dot_spacing

    # Calculate where to position the first row's center
    # We want the content centered, so:
    # - Space above content = space below content = (cylinder_height - content_height) / 2
    # - First row center = cylinder_height - space_above - dot_spacing
    space_above = (height - braille_content_height) / 2.0
    first_row_center_y = height - space_above - settings.dot_spacing

    # Create row markers (triangle and line) for ALL rows
    line_end_meshes = []
    triangle_meshes = []

    # Create line ends and triangles for ALL rows in the grid to match embossing plate layout
    for row_num in range(settings.grid_rows):
        # Calculate Y position for this row with vertical centering
        y_pos = first_row_center_y - (row_num * settings.line_spacing) + settings.braille_y_adjust
        y_local = y_pos - (height / 2.0)

        if getattr(settings, 'indicator_shapes', 1):
            # For counter plate: triangle at first column (apex pointing left), line at last column
            # First column (triangle):
            triangle_x_first = start_angle * radius
            triangle_mesh = create_cylinder_triangle_marker(
                triangle_x_first,
                y_local,
                settings,
                diameter,
                seam_offset,
                height_mm=0.5,
                for_subtraction=True,
                point_left=True,
            )
            triangle_meshes.append(triangle_mesh)

            # Last column (line end):
            last_col_angle = start_angle + ((settings.grid_columns - 1) * cell_spacing_angle)
            line_end_x_last = last_col_angle * radius
            line_end_mesh = create_cylinder_line_end_marker(
                line_end_x_last, y_local, settings, diameter, seam_offset, height_mm=0.5, for_subtraction=True
            )
            line_end_meshes.append(line_end_mesh)

    # Create recess tools for ALL dot positions in ALL cells (universal counter plate)
    sphere_meshes = []

    # Get recess shape once outside the loop
    recess_shape = int(getattr(settings, 'recess_shape', 1))

    # Process ALL cells in the grid (not just those with braille content)
    # Mirror horizontally (right-to-left) so the counter plate reads RâL when printed
    num_text_cols = settings.grid_columns - 2
    for row_num in range(settings.grid_rows):
        # Calculate Y position for this row with vertical centering
        y_pos = first_row_center_y - (row_num * settings.line_spacing) + settings.braille_y_adjust

        # Process ALL columns mirrored (minus two for first cell indicator and last cell triangle)
        for col_num in range(num_text_cols):
            # Mirror column index across row so cells are placed right-to-left
            mirrored_idx = (num_text_cols - 1) - col_num
            # Calculate cell position (shifted by one cell due to first cell indicator)
            cell_angle = start_angle + ((mirrored_idx + 1) * cell_spacing_angle)
            cell_x = cell_angle * radius  # Convert to arc length

            # Create recess tool for ALL 6 dots in this cell
            for dot_idx in range(6):
                dot_pos = dot_positions[dot_idx]
                # Use angular offset for horizontal spacing, converted back to arc length
                dot_x = cell_x + (dot_col_angle_offsets[dot_pos[1]] * radius)
                dot_y = y_pos + dot_row_offsets[dot_pos[0]]

                if recess_shape == 2:
                    # Cone frustum on cylinder surface oriented along radial direction
                    base_d = float(
                        getattr(
                            settings,
                            'cone_counter_dot_base_diameter',
                            getattr(settings, 'counter_dot_base_diameter', 1.6),
                        )
                    )
                    hat_d = float(getattr(settings, 'cone_counter_dot_flat_hat', 0.4))
                    h_cone = float(getattr(settings, 'cone_counter_dot_height', 0.8))
                    base_r = max(settings.epsilon_mm, base_d / 2.0)
                    hat_r = max(settings.epsilon_mm, hat_d / 2.0)
                    # Ensure recess height exceeds radial overcut so it properly intersects the outer surface
                    radial_overcut = max(
                        settings.epsilon_mm, getattr(settings, 'cylinder_counter_plate_overcut_mm', 0.05)
                    )
                    h_cone = max(settings.epsilon_mm, h_cone + radial_overcut)
                    segments = 24
                    # Build local frustum along +Z with base at z=0 and bottom at z=-h_cone
                    angles = np.linspace(0, 2 * np.pi, segments, endpoint=False)
                    top_ring = np.column_stack(
                        [base_r * np.cos(angles), base_r * np.sin(angles), np.zeros_like(angles)]
                    )
                    bot_ring = np.column_stack(
                        [hat_r * np.cos(angles), hat_r * np.sin(angles), -h_cone * np.ones_like(angles)]
                    )
                    vertices = np.vstack([top_ring, bot_ring, [[0, 0, 0]], [[0, 0, -h_cone]]])
                    top_center_index = 2 * segments
                    bot_center_index = 2 * segments + 1
                    faces = []
                    for i in range(segments):
                        j = (i + 1) % segments
                        # indices
                        ti = i
                        tj = j
                        bi = segments + i
                        bj = segments + j
                        # side quad as two triangles (ensure correct orientation for outward normals)
                        faces.append([ti, bi, tj])
                        faces.append([bi, bj, tj])
                        # top cap - outward normal pointing up
                        faces.append([top_center_index, ti, tj])
                        # bottom cap - outward normal pointing down
                        faces.append([bot_center_index, bj, bi])
                    frustum = trimesh.Trimesh(vertices=vertices, faces=np.array(faces), process=True)
                    if not frustum.is_volume:
                        try:
                            frustum.fix_normals()
                            # Ensure the mesh is watertight and has proper orientation
                            if not frustum.is_watertight:
                                frustum.fill_holes()
                            # Force recomputation of volume properties
                            frustum._cache.clear()
                            if not frustum.is_volume:
                                # If still not a volume, try to repair it
                                frustum = frustum.repair()
                        except Exception:
                            pass
                    # Transform to cylinder surface with local frame
                    outer_radius = diameter / 2
                    theta = (dot_x / (np.pi * diameter)) * 2 * np.pi + np.radians(seam_offset)
                    r_hat = np.array([np.cos(theta), np.sin(theta), 0.0])
                    t_hat = np.array([-np.sin(theta), np.cos(theta), 0.0])
                    z_hat = np.array([0.0, 0.0, 1.0])
                    # Base center on cylinder surface
                    overcut = max(settings.epsilon, getattr(settings, 'cylinder_counter_plate_overcut_mm', 0.05))
                    base_center = r_hat * (outer_radius + overcut) + z_hat * (dot_y - (height / 2.0))
                    T = np.eye(4)
                    T[:3, 0] = t_hat
                    T[:3, 1] = z_hat
                    T[:3, 2] = r_hat
                    T[:3, 3] = base_center
                    frustum.apply_transform(T)
                    sphere_meshes.append(frustum)
                else:
                    # Create sphere for hemisphere or bowl cap
                    # Choose base diameter based on selected recess shape
                    use_bowl = recess_shape == 1
                    try:
                        if use_bowl:
                            counter_base = float(
                                getattr(settings, 'bowl_counter_dot_base_diameter', settings.counter_dot_base_diameter)
                            )
                        else:
                            counter_base = float(
                                getattr(settings, 'hemi_counter_dot_base_diameter', settings.counter_dot_base_diameter)
                            )
                    except Exception:
                        counter_base = settings.emboss_dot_base_diameter + settings.counter_plate_dot_size_offset
                    a = counter_base / 2.0
                    if use_bowl:
                        h = float(getattr(settings, 'counter_dot_depth', 0.6))
                        # Guard minimum
                        h = max(settings.epsilon_mm, h)
                        sphere_radius = (a * a + h * h) / (2.0 * h)
                    else:
                        sphere_radius = a
                    sphere = trimesh.creation.icosphere(
                        subdivisions=settings.hemisphere_subdivisions, radius=sphere_radius
                    )
                    if not sphere.is_volume:
                        sphere.fix_normals()
                    outer_radius = diameter / 2
                    theta = (dot_x / (np.pi * diameter)) * 2 * np.pi + np.radians(seam_offset)
                    overcut = max(settings.epsilon, getattr(settings, 'cylinder_counter_plate_overcut_mm', 0.05))
                    if use_bowl:
                        h = float(getattr(settings, 'counter_dot_depth', 0.6))
                        h = max(settings.epsilon_mm, h)
                        center_radius = outer_radius + (sphere_radius - h)
                    else:
                        center_radius = outer_radius + overcut
                    cyl_x = center_radius * np.cos(theta)
                    cyl_y = center_radius * np.sin(theta)
                    cyl_z = dot_y - (height / 2.0)
                    sphere.apply_translation([cyl_x, cyl_y, cyl_z])
                    sphere_meshes.append(sphere)

    print(f'DEBUG: Creating {len(sphere_meshes)} recess tools on cylinder counter plate (recess_shape={recess_shape})')

    if not sphere_meshes:
        print('WARNING: No spheres were generated for cylinder counter plate. Returning base shell.')
        # The cylinder is already created with vertical axis (along Z)
        # No rotation needed - it should stand upright
        # Just ensure the base is at Z=0
        min_z = cylinder_shell.bounds[0][2]
        cylinder_shell.apply_translation([0, 0, -min_z])

        return cylinder_shell

    # Special-case: for cone frusta, prefer individual subtraction for robustness
    if recess_shape == 2 and sphere_meshes:
        try:
            print('DEBUG: Cylinder cone mode - subtracting frusta individually for robustness...')
            result_shell = cylinder_shell.copy()
            for i, tool in enumerate(sphere_meshes):
                try:
                    print(f'DEBUG: Cylinder subtract recess tool {i + 1}/{len(sphere_meshes)}')
                    result_shell = trimesh.boolean.difference([result_shell, tool])
                except Exception as e_tool:
                    print(f'WARNING: Cylinder cone subtraction failed for tool {i + 1}: {e_tool}')
                    continue
            for i, triangle in enumerate(triangle_meshes):
                try:
                    result_shell = trimesh.boolean.difference([result_shell, triangle])
                except Exception as e_tri:
                    print(f'WARNING: Cylinder triangle subtraction failed {i + 1}: {e_tri}')
                    continue
            for i, line_end in enumerate(line_end_meshes):
                try:
                    result_shell = trimesh.boolean.difference([result_shell, line_end])
                except Exception as e_line:
                    print(f'WARNING: Cylinder line-end subtraction failed {i + 1}: {e_line}')
                    continue
            if not result_shell.is_watertight:
                result_shell.fill_holes()
            min_z = result_shell.bounds[0][2]
            result_shell.apply_translation([0, 0, -min_z])
            print(f'DEBUG: Cylinder cone plate completed: {len(result_shell.vertices)} vertices')
            return result_shell
        except Exception as e_cyl_cone:
            print(f'ERROR: Cylinder cone individual subtraction failed: {e_cyl_cone}')
            # Fall through to robust boolean strategy below as a last attempt

    # More robust boolean strategy:
    # 1) Start with the cylinder shell (which already has the polygonal cutout)
    # 2) Subtract the union of all spheres and triangles to create outer recesses

    engines_to_try = ['manifold', None]  # None uses trimesh default

    for engine in engines_to_try:
        try:
            engine_name = engine if engine else 'trimesh-default'

            # Union all spheres
            print(f'DEBUG: Cylinder boolean - union spheres with {engine_name}...')
            if len(sphere_meshes) == 1:
                union_spheres = sphere_meshes[0]
            else:
                union_spheres = trimesh.boolean.union(sphere_meshes, engine=engine)

            # Union all triangles (for subtraction into the cylinder shell)
            union_triangles = None
            if triangle_meshes:
                print(f'DEBUG: Cylinder boolean - union triangles for subtraction with {engine_name}...')
                if len(triangle_meshes) == 1:
                    union_triangles = triangle_meshes[0]
                else:
                    union_triangles = trimesh.boolean.union(triangle_meshes, engine=engine)

            # Union all line end markers
            if line_end_meshes:
                print(f'DEBUG: Cylinder boolean - union line end markers with {engine_name}...')
                if len(line_end_meshes) == 1:
                    union_line_ends = line_end_meshes[0]
                else:
                    union_line_ends = trimesh.boolean.union(line_end_meshes, engine=engine)

            # Combine cutouts (spheres and line ends) for subtraction
            print(f'DEBUG: Cylinder boolean - combining cutouts for subtraction with {engine_name}...')
            cutouts_list = [union_spheres]
            if line_end_meshes:
                cutouts_list.append(union_line_ends)
            if union_triangles is not None:
                cutouts_list.append(union_triangles)

            if len(cutouts_list) > 1:
                all_cutouts = trimesh.boolean.union(cutouts_list, engine=engine)
            else:
                all_cutouts = cutouts_list[0]

            print(f'DEBUG: Cylinder boolean - subtract cutouts from cylinder shell with {engine_name}...')
            final_shell = trimesh.boolean.difference([cylinder_shell, all_cutouts], engine=engine)

            # Triangles are recessed via subtraction; no union back

            if not final_shell.is_watertight:
                print('DEBUG: Cylinder final shell not watertight, attempting to fill holes...')
                final_shell.fill_holes()

            print(
                f'DEBUG: Cylinder counter plate completed with {engine_name}: {len(final_shell.vertices)} vertices, {len(final_shell.faces)} faces'
            )

            # The cylinder is already created with vertical axis (along Z)
            # No rotation needed - it should stand upright
            # Just ensure the base is at Z=0
            min_z = final_shell.bounds[0][2]
            final_shell.apply_translation([0, 0, -min_z])

            return final_shell
        except Exception as e:
            print(f'ERROR: Cylinder robust boolean with {engine_name} failed: {e}')
            continue

    # Fallback: subtract spheres individually from cylinder shell
    try:
        print('DEBUG: Fallback - individual subtraction from cylinder shell...')
        result_shell = cylinder_shell.copy()
        for i, sphere in enumerate(sphere_meshes):
            try:
                print(f'DEBUG: Subtracting sphere {i + 1}/{len(sphere_meshes)} from cylinder shell...')
                result_shell = trimesh.boolean.difference([result_shell, sphere])
            except Exception as sphere_error:
                print(f'WARNING: Failed to subtract sphere {i + 1}: {sphere_error}')
                continue

        # Subtract triangles individually (recess them)
        for i, triangle in enumerate(triangle_meshes):
            try:
                print(f'DEBUG: Subtracting triangle {i + 1}/{len(triangle_meshes)} from cylinder shell...')
                result_shell = trimesh.boolean.difference([result_shell, triangle])
            except Exception as triangle_error:
                print(f'WARNING: Failed to subtract triangle {i + 1}: {triangle_error}')
                continue

        # Subtract line end markers individually
        for i, line_end in enumerate(line_end_meshes):
            try:
                print(f'DEBUG: Subtracting line end marker {i + 1}/{len(line_end_meshes)} from cylinder shell...')
                result_shell = trimesh.boolean.difference([result_shell, line_end])
            except Exception as line_error:
                print(f'WARNING: Failed to subtract line end marker {i + 1}: {line_error}')
                continue

        final_shell = result_shell
        if not final_shell.is_watertight:
            final_shell.fill_holes()
        print(f'DEBUG: Fallback completed: {len(final_shell.vertices)} vertices, {len(final_shell.faces)} faces')

        # The cylinder is already created with vertical axis (along Z)
        # No rotation needed - it should stand upright
        # Just ensure the base is at Z=0
        min_z = final_shell.bounds[0][2]
        final_shell.apply_translation([0, 0, -min_z])

        return final_shell
    except Exception as final_error:
        print(f'ERROR: Cylinder fallback boolean failed: {final_error}')
        print('WARNING: Returning simple cylinder shell without recesses.')

        # The cylinder is already created with vertical axis (along Z)
        # No rotation needed - it should stand upright
        # Just ensure the base is at Z=0
        min_z = cylinder_shell.bounds[0][2]
        cylinder_shell.apply_translation([0, 0, -min_z])

        return cylinder_shell




