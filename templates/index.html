<!-- VERSION: 2024-12-19-revised -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Custom Braille STL Generator</title>
    <link rel="icon" href="/static/favicon.svg" type="image/svg+xml">
    <link rel="alternate icon" href="/favicon.ico" sizes="any">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* Theme CSS Variables */
        :root {
            /* Light mode colors */
            --bg-gradient-start: #e0e7ff;
            --bg-gradient-end: #f6f8fa;
            --bg-primary: #fff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --bg-input: #f9fafb;
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --text-tertiary: #666;
            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;
            --border-focus: #3182ce;
            --btn-primary-bg: linear-gradient(90deg, #3182ce 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #2563eb 60%, #4299e1 100%);
            --btn-success-bg: #10b981;
            --btn-success-hover-bg: #059669;
            --btn-secondary-bg: #9ca3af;
            --btn-tertiary-bg: #6b7280;
            --error-bg: #fee2e2;
            --error-border: #fecaca;
            --error-text: #b91c1c;
            --info-bg: #dbeafe;
            --info-border: #93c5fd;
            --info-text: #1e40af;
            --shadow-light: rgba(49,130,206,0.10);
            --shadow-medium: rgba(49,130,206,0.18);
            --stl-mesh-color: #6699cc;
            --stl-background: #f1f5f9;
            --stl-ambient-light: #888888;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.5;
            --stl-directional-intensity: 1.0;
            --scrollbar-width: 18px; /* Form section scrollbar */
            --global-scrollbar-width: 13.5px; /* Global page scrollbar - 25% smaller */
            --scrollbar-arrow-color: #3182ce; /* Light/default arrow color matches scrollbar */
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --bg-gradient-start: #1a202c;
            --bg-gradient-end: #2d3748;
            --bg-primary: #2d3748;
            --bg-secondary: #374151;
            --bg-tertiary: #4a5568;
            --bg-input: #374151;
            --text-primary: #f7fafc;
            --text-secondary: #e2e8f0;
            --text-tertiary: #cbd5e1;
            --border-primary: #4a5568;
            --border-secondary: #718096;
            --border-focus: #63b3ed;
            --btn-primary-bg: linear-gradient(90deg, #4299e1 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #3182ce 60%, #4299e1 100%);
            --btn-success-bg: #059669;
            --btn-success-hover-bg: #047857;
            --btn-secondary-bg: #718096;
            --btn-tertiary-bg: #4a5568;
            --error-bg: #742a2a;
            --error-border: #9b2c2c;
            --error-text: #fed7d7;
            --info-bg: #2c5282;
            --info-border: #3182ce;
            --info-text: #bee3f8;
            --shadow-light: rgba(0,0,0,0.3);
            --shadow-medium: rgba(0,0,0,0.5);
            --stl-mesh-color: #90cdf4;
            --stl-background: #2d3748;
            --stl-ambient-light: #666666;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.6;
            --stl-directional-intensity: 0.9;
            --scrollbar-arrow-color: #63b3ed; /* Bright blue arrows in dark theme */
        }

        /* High contrast mode */
        [data-theme="high-contrast"] {
            --bg-gradient-start: #000000;
            --bg-gradient-end: #000000;
            --bg-primary: #000000; /* Keep black background */
            --bg-secondary: #1a1a1a; /* Keep dark background */
            --bg-tertiary: #2a2a2a; /* Keep dark background */
            --bg-input: #1a1a1a; /* Keep dark background for inputs */
            --text-primary: #02fe05; /* Green instead of white */
            --text-secondary: #02fe05; /* Green instead of white */
            --text-tertiary: #02fe05; /* Green instead of white */
            --border-primary: #ffff00;
            --border-secondary: #00ffff;
            --border-focus: #ff00ff;
            --btn-primary-bg: #02fe05; /* Green */
            --btn-primary-hover-bg: #02fe05; /* Green */
            --btn-success-bg: #02fe05; /* Green */
            --btn-success-hover-bg: #02fe05; /* Green */
            --btn-secondary-bg: #ff6600;
            --btn-tertiary-bg: #ff6600;
            --error-bg: #ff0000;
            --error-border: #ff0000;
            --error-text: #02fe05; /* Green instead of white */
            --info-bg: #0000ff;
            --info-border: #0000ff;
            --info-text: #02fe05; /* Green instead of white */
            --shadow-light: none;
            --shadow-medium: none;
            --stl-mesh-color: #00ffff; /* Bright cyan for high contrast */
            --stl-background: #000000; /* Keep black background */
            --stl-ambient-light: #666666; /* Reduced ambient light to prevent washing out */
            --stl-directional-light: #e6e6e6; /* Slightly dimmed directional light for better contrast */
            --stl-ambient-intensity: 0.4; /* Lower ambient light intensity */
            --stl-directional-intensity: 0.8; /* Controlled directional light intensity */
            --scrollbar-arrow-color: #02fe05; /* High-contrast arrows */
        }

        /* High contrast mode specific button styling */
        [data-theme="high-contrast"] button[type="submit"] {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] button[type="submit"]:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        /* High contrast mode - Generate STL button state (blue) */
        [data-theme="high-contrast"] #action-btn.generate-state {
            background: #0201fe !important; /* Blue background for generate */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #fdfe00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] #action-btn.generate-state:hover {
            background: #0201fe !important; /* Blue background */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #02fe05 !important; /* Green border on hover */
        }

        /* High contrast mode - Download STL button state (green) */
        [data-theme="high-contrast"] #action-btn.download-state {
            background: #02fe05 !important; /* Green background for download */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] #action-btn.download-state:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        /* High contrast mode - Disabled/Loading state */
        [data-theme="high-contrast"] #action-btn:disabled {
            background: #666666 !important; /* Gray background for disabled */
            color: #cccccc !important; /* Light gray text */
            border: 2px solid #999999 !important; /* Gray border */
            cursor: not-allowed !important;
        }

        [data-theme="high-contrast"] #download-counter-plate-btn {
            background: #ff6600 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] #download-counter-plate-btn:hover {
            background: #ff8800 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        [data-theme="high-contrast"] .expert-toggle-btn,
        [data-theme="high-contrast"] .info-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn:hover,
        [data-theme="high-contrast"] .info-toggle-btn:hover {
            background: #000000 !important; /* Black background on hover */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn.active,
        [data-theme="high-contrast"] .info-toggle-btn.active {
            background: #000000 !important; /* Black background when active */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .font-size-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .font-size-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        [data-theme="high-contrast"] .font-size-btn.reset-btn {
            background: #2a2a2a !important; /* Darker background */
            color: #00ffff !important; /* Cyan text */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .font-size-display {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        /* Apply transition to theme changes */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; /* Ensure all elements include padding/borders in width */
        }

        /* Skip Link for Keyboard Navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--border-focus);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 0 0 8px 0;
            z-index: 1000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }



        /* Font Size Controls */
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.4em 0.6em;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .font-size-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            min-width: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .font-size-btn:hover {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px var(--shadow-medium);
        }

        .font-size-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .font-size-btn.reset-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.8em;
        }

        .font-size-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 3.5em;
            text-align: center;
            user-select: none;
        }



        /* Enhanced focus indicators for all interactive elements */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        a:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Ensure proper keyboard navigation visibility */
        *:focus-visible {
            outline: 3px solid var(--border-focus) !important;
            outline-offset: 2px !important;
        }

        /* Mobile-optimized containers */
        @media (max-width: 768px) {
            .main-layout {
                overflow-y: auto; /* Allow main scroll on mobile if needed */
            }

            /* Sticky generate button on mobile */
            .button-row {
                position: sticky;
                bottom: 0;
                background: var(--bg-primary);
                padding: 1em 0;
                margin: 0; /* Avoid horizontal overflow from negative margins */
                padding-left: 1em;
                padding-right: 1em;
                width: 100%;
                box-shadow: 0 -2px 8px var(--shadow-light);
                z-index: 10;
            }
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Fieldset styling */
        fieldset {
            border: none;
            padding: 0;
            margin: 0;
        }

        .line-input-fieldset {
            margin: 0;
        }

        /* Braille preview styles */
        .braille-preview {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
        }

        .preview-heading {
            margin-top: 0;
            color: var(--text-primary);
        }

        .preview-line-success {
            margin: 10px 0;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 5px;
            border: 1px solid var(--border-primary);
        }

        .preview-line-error {
            margin: 10px 0;
            padding: 10px;
            background: var(--error-bg);
            border-radius: 5px;
            border: 1px solid var(--error-border);
            color: var(--error-text);
        }

        .expert-info {
            font-size: 0.9em;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 1em;
            text-align: center;
        }

        /* High contrast text styling */
        [data-theme="high-contrast"] strong,
        [data-theme="high-contrast"] b {
            color: #02fe05 !important; /* Green for bold text */
        }

        [data-theme="high-contrast"] .grade-label[style*="font-weight: 700"] {
            color: #02fe05 !important; /* Green for bold labels */
        }

        [data-theme="high-contrast"] em,
        [data-theme="high-contrast"] i,
        [data-theme="high-contrast"] [style*="font-style: italic"] {
            color: #fdfe00 !important; /* Yellow for italic text */
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-info span {
            color: #fdfe00 !important; /* Yellow for grade info notes */
        }

        [data-theme="high-contrast"] #offset-help {
            color: #fdfe00 !important; /* Yellow for offset help text */
        }

        /* Note styling classes */
        .grade-note,
        .offset-note {
            color: var(--text-tertiary);
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-note,
        [data-theme="high-contrast"] .offset-note {
            color: #fdfe00 !important; /* Yellow for all note text */
        }

        html {
            background: linear-gradient(120deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh; /* Ensure background covers viewport */
            overscroll-behavior: none;
        }

        body {
            background: transparent; /* Inherit gradient from html */
            min-height: 100vh; /* Minimum viewport height, can grow if needed */
            font-family: 'Inter', system-ui, Arial, sans-serif;
            margin: 0;
            display: flex;
            align-items: flex-start; /* Align to top to prevent centering issues */
            justify-content: center;
            padding: 0; /* Remove padding to extend to browser edges */
            color: var(--text-primary);
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            box-sizing: border-box;
            overflow-x: hidden;
            overflow-y: auto; /* Allow scrolling if content overflows */
            overscroll-behavior: none;
        }

        /* Mobile-specific body adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0; /* Remove padding on mobile too */
                min-height: 100vh;
                overflow-y: auto; /* Allow scrolling on mobile if needed */
                overflow-x: hidden;
                align-items: flex-start; /* Align to top on mobile */
            }
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 2em;
            background: var(--bg-primary);
            border-radius: 0; /* Remove border radius to extend to edges */
            box-shadow: none; /* Remove shadow since we're edge-to-edge */
            padding: 2.5em;
            width: 100%;
            min-height: 100vh; /* Minimum full viewport height, can grow if needed */
            margin: 0;
            overflow-y: auto; /* Allow main scroll if content overflows */
            overflow-x: hidden;
            box-sizing: border-box;
        }

        /* Mobile layout optimization */
        @media (max-width: 768px) {
            .main-layout {
                padding: 1.5em;
                border-radius: 0; /* Remove border radius on mobile too */
                gap: 1.5em;
                box-shadow: none; /* Remove shadow on mobile too */
                min-height: 100vh; /* Minimum full height on mobile */
                overflow-y: auto; /* Allow main scroll on mobile if needed */
                overflow-x: hidden;
            }
        }

        @media (max-width: 480px) {
            .main-layout {
                padding: 1em;
                border-radius: 0; /* Remove border radius on small mobile too */
                gap: 1em;
            }
        }

        /* Title Section - Full Width at Top */
        .title-section {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 1.5em;
            width: 100%;
        }

        .title-section h1 {
            margin: 0;
            display: flex;
            flex-direction: row;
            align-items: baseline;
            gap: 0.4em;
            line-height: 1.1;
            white-space: nowrap;
        }

        .title-line-1 {
            font-size: 19.6pt;
            font-weight: 700;
            color: var(--text-primary); /* Default theme color */
        }

        .title-line-2 {
            font-size: 19.6pt;
            font-weight: 600;
            color: var(--text-secondary); /* Default theme color */
            margin: 0;
        }

        /* High contrast mode - bright violet title */
        [data-theme="high-contrast"] .title-line-1,
        [data-theme="high-contrast"] .title-line-2 {
            color: #fd01fc !important; /* Bright violet for high contrast mode */
        }

        /* Top Accessibility Controls */
        .accessibility-controls-top {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-end;
            gap: 0.8rem;
            margin-left: 1rem;
            flex-wrap: nowrap;
        }
        /* Ensure theme toggle appears before font-size controls (to the left) */
        .accessibility-controls-top .theme-toggle-section { order: 0; }
        .accessibility-controls-top .font-size-controls { order: 1; }

        /* Content Area - Two Column Layout */
        .content-area {
            display: flex;
            gap: 2.5em;
            width: 100%;
            flex: 1; /* Take remaining space after title */
            min-height: 0; /* Allow shrinking for scrolling to work */
            overflow: visible; /* Allow content to be visible */
        }

        /* Left Column - Preview Section (45% width) */
        .preview-section {
            flex: 0 0 45%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            /* Make left column independently scrollable without collapsing viewer */
            max-height: none;
            min-height: 0;
            overflow-y: visible;
            -webkit-overflow-scrolling: touch;
            overflow-x: hidden;
            padding-right: 1em; /* Add padding to prevent cutoff */
        }

        /* Right Column - Form Section (55% width) */
        .form-section {
            flex: 0 0 calc(55% - 2em); /* Subtract padding to prevent overflow */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-width: 320px;
            max-width: calc(55% - 2em); /* Prevent form from extending past background */
            /* Make right column independently scrollable - separate from left column */
            max-height: calc(100vh - 10em); /* Account for main-layout padding (5em) and title section (~5em) */
            min-height: 0;
            overflow-y: scroll; /* Enable scrolling for right column menu boxes */
            -webkit-overflow-scrolling: touch;
            overflow-x: hidden; /* Prevent horizontal overflow */
            scrollbar-gutter: stable; /* Reserve space so the scrollbar is always visible */
            scrollbar-width: auto; /* Firefox standard scrollbar */
            scrollbar-color: #3182ce #e2e8f0; /* Firefox: blue thumb on light grey track */
            /* Distinct background for scrollable area */
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.2em;
            border: 1px solid var(--border-secondary);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        /* Custom scrollbar styling for webkit browsers - larger and more visible */
        .form-section::-webkit-scrollbar {
            width: var(--scrollbar-width); /* +~28% width for clearer grab area */
        }

        .form-section::-webkit-scrollbar-track {
            background: #e2e8f0; /* Light grey background */
            border-radius: 8px;
            margin: 4px 0; /* Add some margin at top and bottom */
            border: 2px solid #3182ce; /* Blue border for high visibility */
        }

        .form-section::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #4299e1, #3182ce); /* Bright blue gradient */
            border-radius: 10px;
            border: 2px solid #ffffff; /* White border for strong contrast */
            box-shadow: 0 3px 6px rgba(49, 130, 206, 0.4); /* Blue shadow for depth */
        }

        .form-section::-webkit-scrollbar-thumb:hover {
            background: #2563eb; /* Darker blue on hover */
            border-color: #3182ce; /* Blue border on hover */
            box-shadow: 0 4px 8px rgba(49, 130, 206, 0.6); /* Enhanced shadow on hover */
        }

        /* Global scrollbar styling for main page scrollbar */
        body::-webkit-scrollbar {
            width: var(--global-scrollbar-width);
        }

        /* Use default browser scrollbar arrow buttons (no custom styling) */

        body::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-secondary);
        }

        body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--text-secondary), var(--text-primary));
            border-radius: 10px;
            border: 2px solid var(--bg-primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        body::-webkit-scrollbar-thumb:hover {
            background: var(--text-primary);
            border-color: var(--border-focus);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        /* Dark theme specific scrollbar improvements - Firefox */
        [data-theme="dark"] .form-section {
            scrollbar-color: #63b3ed #2d3748 !important; /* thumb color, track color */
        }

        /* Dark theme specific scrollbar improvements - WebKit (Chrome, Edge, Safari) */
        [data-theme="dark"] .form-section::-webkit-scrollbar-track {
            background: #2d3748 !important; /* Darker background for better contrast */
            border: 1px solid #63b3ed !important; /* Bright blue border for visibility */
            border-radius: 8px !important;
        }

        [data-theme="dark"] .form-section::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #90cdf4, #63b3ed) !important; /* Bright blue gradient */
            border: 2px solid #1a202c !important; /* Very dark border for definition */
            border-radius: 10px !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5) !important; /* Stronger shadow for dark theme */
        }

        [data-theme="dark"] .form-section::-webkit-scrollbar-thumb:hover {
            background: #4299e1 !important; /* Solid bright blue on hover */
            border-color: #63b3ed !important; /* Bright blue border on hover */
            box-shadow: 0 3px 6px rgba(0,0,0,0.6) !important; /* Enhanced shadow on hover */
        }

        [data-theme="dark"] body::-webkit-scrollbar-track {
            background: #2d3748; /* Darker background for better contrast */
            border: 1px solid #63b3ed; /* Bright blue border for visibility */
        }

        [data-theme="dark"] body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #90cdf4, #63b3ed); /* Bright blue gradient */
            border: 2px solid #1a202c; /* Very dark border for definition */
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); /* Stronger shadow for dark theme */
        }

        [data-theme="dark"] body::-webkit-scrollbar-thumb:hover {
            background: #4299e1; /* Solid bright blue on hover */
            border-color: #63b3ed; /* Bright blue border on hover */
            box-shadow: 0 3px 6px rgba(0,0,0,0.6); /* Enhanced shadow on hover */
        }

        /* High contrast: match form-section scrollbar to global scrollbar scheme */
        [data-theme="high-contrast"] .form-section {
            /* Firefox */
            scrollbar-color: var(--text-secondary) var(--bg-tertiary) !important;
        }

        [data-theme="high-contrast"] .form-section::-webkit-scrollbar-track {
            background: var(--bg-tertiary) !important;
            border: 2px solid var(--border-secondary) !important;
            border-radius: 8px !important;
        }

        [data-theme="high-contrast"] .form-section::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--text-secondary), var(--text-primary)) !important;
            border: 2px solid var(--bg-primary) !important;
            border-radius: 10px !important;
            box-shadow: none !important;
        }

        /* Mobile layout - stack columns */
        @media (max-width: 768px) {
            .content-area {
                flex-direction: column;
                gap: 1.5em;
                overflow: visible; /* Allow content to be visible on mobile */
            }

            .preview-section {
                flex: none;
                width: 100%;
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .form-section {
                flex: 1; /* Take remaining space */
                width: 100%;
                max-height: none; /* Remove height restriction on mobile */
                overflow-y: auto; /* Enable scrolling within the container */
                overflow-x: hidden;
                /* Keep scrollable styling on mobile for inner content */
                background: var(--bg-secondary);
                border: 1px solid var(--border-primary);
                border-radius: 12px;
                padding: 1.2em;
                box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            }
        }

        /* Desktop layout - sticky left preview, separate right column scrolling */
        @media (min-width: 769px) {
            .preview-section {
                position: sticky;
                top: 0;
                align-self: flex-start; /* ensure sticky positions relative to content area */
            }

            /* Ensure right column scrolling is properly configured for desktop */
            .form-section {
                max-height: calc(100vh - 10em); /* Account for main-layout padding and title section */
                overflow-y: scroll;
                position: relative; /* For scroll indicator positioning */
            }

            /* Visual scroll indicator - shadow at bottom when scrollable */
            .form-section::after {
                content: '';
                position: sticky;
                bottom: 0;
                left: 0;
                right: var(--scrollbar-width);
                height: 20px;
                background: linear-gradient(to top, var(--bg-secondary), transparent);
                pointer-events: none;
                opacity: 0.8;
            }
        }

        #viewer {
            width: 100%;
            min-width: 0; /* Avoid forcing horizontal scroll on very small devices */
            max-width: 100%;
            height: calc(100vh - 16em); /* Adjust for new layout spacing */
            border-radius: 18px;
            border: 2px solid var(--border-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 4px 24px var(--shadow-light);
            display: flex;
            align-items: center; /* vertically center canvas */
            justify-content: center; /* horizontally center canvas */
            margin: 0 0 1.5em 0;
            transition: box-shadow 0.2s;
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden; /* Ensure content doesn't overflow rounded corners */
            box-sizing: border-box; /* Include border in size calculation */
            position: relative; /* Create positioning context for overlay */
        }

        /* Canvas should fill the content box and be clipped by the rounded frame */
        #viewer canvas {
            position: relative;
            z-index: 1;
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Mobile viewer optimizations */
        @media (max-width: 768px) {
            #viewer {
                height: calc(40vh - 1em); /* Responsive height for tablets - leave more room for content */
                min-width: unset;
                width: 100%;
                max-width: 100%;
                border-radius: 12px;
                margin: 0 0 1em 0;
            }
        }

        @media (max-width: 480px) {
            #viewer {
                height: calc(35vh - 1em); /* Responsive height for phones - more compact */
                border-radius: 12px;
            }
        }
        #viewer:focus-within, #viewer:active {
            box-shadow: 0 8px 32px var(--shadow-medium);
        }

        h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 0.7em;
            color: var(--text-primary);
            text-align: left;
        }

        /* Mobile heading optimization */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 0.5em;
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
                line-height: 1.3;
            }
        }
        .info-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .info-panel p {
            margin: 0.3em 0;
        }
        .grade-selection {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
        }

        /* Mobile grade selection optimization */
        @media (max-width: 768px) {
            .grade-selection {
                padding: 1.2em;
                margin-bottom: 1.2em;
            }
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.6em;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.6em;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--text-secondary);
            padding: 0.5em 0;
            margin: -0.5em 0;
        }

        /* Mobile radio option optimization */
        @media (max-width: 768px) {
            .radio-option {
                padding: 0.8em 0;
                font-size: 1em;
                gap: 0.8em;
            }

            .radio-option input[type="radio"] {
                width: 20px;
                height: 20px;
                min-width: 20px;
                min-height: 20px;
            }
        }
        .radio-option input[type="radio"] {
            margin: 0;
            cursor: pointer;
        }
        .radio-text {
            cursor: pointer;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 1.1em;
        }
        .line-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
        }
        .line-input {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.8em;
        }
        .line-translation-row,
        .line-text-row {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.4em;
        }
        .line-text-row input[type="text"] {
            width: 100%;
        }
        /* Ensure even vertical spacing between each manual line group */
        #dynamic-line-inputs {
            display: flex;
            flex-direction: column;
            gap: 1em;
        }
        /* Normalize label spacing within rows */
        .line-translation-row .line-label,
        .line-text-row .line-label {
            margin: 0;
        }

        /* Mobile line input optimization */
        @media (max-width: 768px) {
            .line-input {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5em;
            }

            .line-label {
                font-size: 0.95em;
                font-weight: 600;
                margin-bottom: 0.2em;
            }
        }
        /* Placement mode toggle: allow wrapping to avoid right cutoff on small screens */
        .line-input-mode-toggle {
            flex-wrap: wrap; /* New: allow items to wrap onto next line */
        }
        /* Put the "Placement Mode:" label on its own line when needed */
        .line-input-mode-toggle > .line-label {
            flex-basis: 100%;
            margin-bottom: 0.2em !important; /* override inline margin */
        }
        @media (max-width: 768px) {
            .line-input-mode-toggle {
                gap: 0.6em; /* slightly tighter gap on mobile */
            }
            .line-input-mode-toggle > * {
                min-width: 0; /* allow flex children to shrink properly */
            }
            .line-input-mode-toggle label {
                max-width: 100%;
                white-space: normal; /* allow label text to wrap */
            }
        }
        .line-label {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 60px;
            font-size: 0.9em;
        }
        input[type="text"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Mobile-friendly input styles */
        @media (max-width: 768px) {
            input[type="text"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
            }
        }
        input[type="text"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }

        /* Ensure number inputs are properly styled and functional */
        input[type="number"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            min-width: 80px;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            appearance: none;
        }

        /* Remove spinner buttons */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Mobile-friendly number input styles */
        @media (max-width: 768px) {
            input[type="number"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
                width: 100%;
                min-width: unset;
            }
        }

        input[type="number"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }

        input[type="number"]:hover {
            border-color: var(--border-primary);
        }

        /* Language select dropdown styling */
        .language-select {
            width: 100%;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%23666" d="M0 0l6 6 6-6z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.8em center;
            background-size: 12px;
            padding-right: 2.5em;
        }

        /* Mobile select optimization */
        @media (max-width: 768px) {
            .language-select {
                padding: 1em;
                padding-right: 3em;
                font-size: 16px;
                min-height: 48px;
            }
        }

        .language-select:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }

        .language-select:hover {
            border-color: var(--border-primary);
        }

        /* High contrast mode select styling */
        [data-theme="high-contrast"] .language-select {
            background: #1a1a1a !important;
            color: #ffffff !important;
            border: 2px solid #ffff00 !important;
        }

        [data-theme="high-contrast"] .language-select:focus {
            background: #2a2a2a !important;
            color: #ffffff !important;
            border: 2px solid #ff00ff !important;
        }

        [data-theme="high-contrast"] .language-select option {
            background: #1a1a1a !important;
            color: #ffffff !important;
        }

        [data-theme="high-contrast"] .language-select optgroup {
            background: #2a2a2a !important;
            color: #ffff00 !important;
            font-weight: bold;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
            margin-top: 1em;
        }
        button {
            border: none;
            border-radius: 8px;
            padding: 0.7em 1em;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            line-height: 1.2;
            white-space: nowrap;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        /* Mobile-friendly button styles */
        @media (max-width: 768px) {
            button {
                padding: 1em 1.2em;
                font-size: 1.1em;
                min-height: 48px;
                min-width: 48px;
                white-space: normal; /* Allow wrapping on small screens */
            }
        }
        button[type="submit"] {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        button[type="submit"]:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }

        /* Action button state styles */
        #action-btn {
            transition: all 0.3s ease;
            min-width: 140px;
            text-align: center;
            font-size: 0.95em;
        }

        #action-btn.generate-state {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        #action-btn.generate-state:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }

        #action-btn.download-state {
            background: var(--btn-success-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        #action-btn.download-state:hover {
            background: var(--btn-success-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }

        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            margin-bottom: 1em;
            flex-wrap: wrap;
        }

        /* Mobile button row optimization */
        @media (max-width: 768px) {
            .button-row {
                gap: 0.8em;
                justify-content: stretch;
            }

            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }

        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }

            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }


        #download-counter-plate-btn {
            background: var(--btn-tertiary-bg);
            color: #fff;
        }
        #download-counter-plate-btn:hover {
            background: var(--btn-tertiary-bg);
            opacity: 0.9;
            transform: translateY(-2px) scale(1.03);
        }
        #error-message {
            color: var(--error-text);
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            border-radius: 6px;
            padding: 0.9em 1.2em;
            margin: 0;
            font-size: 1.25em;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 0.7em;
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            width: 100%;
            text-align: center;
            z-index: 2;
            pointer-events: none;
            box-shadow: 0 6px 20px var(--shadow-light);
            box-sizing: border-box;
        }

        #error-message.info {
            color: var(--info-text);
            background: var(--info-bg);
            border: 1px solid var(--info-border);
        }

        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }

        .expert-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5em;
            transition: background 0.2s, border-color 0.2s;
            width: 100%;
        }

        .expert-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }

        .expert-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }

        .expert-toggle-btn.active #expert-toggle-text {
            color: #fff;
        }

        .expert-toggle-btn.active #expert-toggle-icon {
            transform: rotate(180deg);
        }

        /* Reset to Defaults button styling */
        .reset-container {
            margin-top: 0.6em;
        }
        .reset-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em 1.2em;
            width: 100%;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .reset-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }
        [data-theme="high-contrast"] .reset-btn {
            background: #1a1a1a !important;
            color: #02fe05 !important;
            border: 2px solid #02fe05 !important;
        }
        [data-theme="high-contrast"] .reset-btn:hover {
            background: #000000 !important;
            color: #02fe05 !important;
            border: 2px solid #02fe05 !important;
        }

        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }

        /* Ensure Expert Mode inputs are properly spaced and visible */
        .expert-settings .grade-selection {
            margin-bottom: 1em;
        }

        .expert-settings input[type="number"] {
            margin-top: 0.3em;
            margin-bottom: 0.5em;
        }

        .expert-settings label {
            display: block;
            margin-bottom: 0.3em;
            font-weight: 500;
            color: var(--text-primary);
        }
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }

        .info-dropdown {
            margin-bottom: 1.5em;
        }

        .info-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }

        .info-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }

        .info-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }

        .info-toggle-btn.active #info-toggle-text {
            color: #fff;
        }

        .info-toggle-btn.active #info-toggle-icon {
            transform: rotate(180deg);
        }

        .info-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        /* Expert submenus */
        .expert-submenu {
            margin-top: 0.8em;
        }
        .expert-submenu-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }
        .expert-submenu-toggle:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }
        .expert-submenu-toggle.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        .expert-submenu-toggle.active .expert-submenu-title {
            color: #fff;
        }
        .expert-submenu-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
        }

        .info-content p {
            margin: 0.3em 0;
        }

        /* Additional mobile optimizations */
        @media (max-width: 768px) {
            .viewer-section, .form-section {
                max-width: 100%;
                min-width: unset;
            }

            .info-panel, .info-content {
                padding: 1.2em;
                font-size: 0.95em;
            }

            .info-toggle-btn, .expert-toggle-btn {
                padding: 1em;
                font-size: 1em;
                min-height: 48px;
            }

            #error-message {
                padding: 1em;
                font-size: 0.95em;
                margin: 0.8em 0;
            }

            .button-group {
                gap: 0.8em;
            }

            /* Mobile optimizations */
            html {
                scroll-behavior: smooth;
            }
        }

        /* Extra small devices */
        @media (max-width: 480px) {
            .expert-settings input[type="number"] {
                width: 100%;
            }

            .font-size-controls {
                transform: scale(0.9);
                transform-origin: top right;
            }
        }



        /* Plate Selection Row Layout */
        .plate-selection-row {
            display: flex;
            align-items: flex-start;
            gap: 1.5em;
            margin-top: 1em;
        }

        .plate-type-selection {
            flex: 1;
            min-width: 250px;
        }

        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            flex-shrink: 0;
        }

        /* Mobile plate selection row optimization */
        @media (max-width: 768px) {
            .plate-selection-row {
                flex-direction: column;
                gap: 1em;
            }

            .plate-type-selection {
                min-width: unset;
                width: 100%;
            }

            .button-row {
                width: 100%;
                justify-content: stretch;
            }

            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }

        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }

            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }

        /* Theme Toggle Section */
        .theme-toggle-section {
            display: flex;
            align-items: center;
            gap: 0.8em;
            margin-left: 0;
        }

        .theme-label-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            color: var(--text-secondary);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.3em;
            min-height: 2.5em;
            box-sizing: border-box;
        }

        .theme-label-text {
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Theme Toggle Button */
        .theme-toggle-btn {
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .theme-toggle-btn:hover {
            background: var(--bg-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .theme-toggle-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .theme-icon {
            font-size: 1.2em;
        }

        /* Mobile title section optimization */
        @media (max-width: 768px) {
            .title-section {
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 1rem;
                margin-bottom: 1em;
            }

            .title-section h1 {
                text-align: center;
                white-space: normal; /* Allow multi-line title on small screens */
                word-break: break-word;
            }

            .title-line-1 {
                font-size: 16pt;
            }

            .title-line-2 {
                font-size: 16pt;
            }

            .accessibility-controls-top {
                margin-left: 0;
                align-items: center;
                flex-wrap: wrap; /* Prevent controls from overflowing horizontally */
                justify-content: center;
            }

            .theme-toggle-section {
                flex-direction: column;
                align-items: center;
                gap: 0.5em;
                margin-left: 0;
            }

            .theme-label-box {
                font-size: 0.85em;
                min-height: 2.2em;
            }
        }

        @media (max-width: 480px) {
            .title-line-1 {
                font-size: 13.6pt;
            }

            .title-line-2 {
                font-size: 13.6pt;
            }
        }

        /* Form Section Accessibility Controls */
        [data-theme="high-contrast"] .theme-label-box {
            background: #1a1a1a !important; /* Dark background for high contrast */
            border: 2px solid #ffff00 !important; /* Yellow border for high contrast */
        }

        [data-theme="high-contrast"] .theme-label-text {
            color: #02fe05 !important; /* Green text for high contrast */
        }

        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow instead of yellow */
            color: #0201fe !important; /* Blue instead of black */
            border: 2px solid #0201fe !important; /* Blue instead of black */
        }

        [data-theme="high-contrast"] input[type="text"],
        [data-theme="high-contrast"] input[type="number"] {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] input[type="text"]:focus,
        [data-theme="high-contrast"] input[type="number"]:focus {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ff00ff !important; /* Magenta border on focus */
        }

        [data-theme="high-contrast"] .info-panel,
        [data-theme="high-contrast"] .grade-selection,
        [data-theme="high-contrast"] .info-content {
            background: #1a1a1a !important; /* Dark background for panels */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .braille-preview {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .preview-line-success {
            background: #2a2a2a !important; /* Darker background */
            color: #02fe05 !important; /* Green text for success */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .preview-line-error {
            background: #ff0000 !important;
            color: #02fe05 !important; /* Green text */
            border: 2px solid #ff0000 !important;
        }

        /* Subline under each preview line for computer shorthand */
        .preview-subline {
            font-size: 0.9em;
            opacity: 0.85;
            margin-top: 0.25em;
        }

        /* Section Title Styling - Larger Font for All Themes */
        .info-panel strong,
        .info-panel p strong {
            font-size: 1.3em !important;
            font-weight: 700 !important;
        }

        #info-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }

        .grade-label {
            font-weight: 600;
            color: var(--text-primary);
            display: block;
            margin-bottom: 0.8em;
            font-size: 1.2em !important; /* Increased from 0.9em */
        }

        .expert-toggle-btn #expert-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }

        /* Auto placement textarea styling to visually align with manual inputs */
        #auto-input-container textarea#auto-text {
            width: 100%;
            min-height: 6.5em; /* approx 4 lines */
            line-height: 1.4;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }
        #auto-input-container textarea#auto-text:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        /* High contrast maintains theme variables already set */
    </style>
</head>
<body>
    <!-- Skip Navigation Link for Keyboard Users -->
    <a href="#main-content" class="skip-link" tabindex="0">Skip to main content</a>



    <div class="main-layout" role="main" id="main-content">
        <!-- Title Section at the top -->
        <div class="title-section">
            <h1 id="main-heading">
                <span class="title-line-1">Custom Braille</span>
                <span class="title-line-2">STL Generator</span>
            </h1>

            <!-- Accessibility Controls in top right -->
            <div class="accessibility-controls-top" role="group" aria-label="Accessibility controls">
                <!-- Font Size Controls -->
                <div class="font-size-controls" role="group" aria-label="Font size adjustment">
                    <button id="font-decrease" class="font-size-btn" aria-label="Decrease font size" title="Decrease font size">
                        <span aria-hidden="true">A-</span>
                        <span class="sr-only">Decrease font size</span>
                    </button>
                    <span class="font-size-display" aria-label="Current font size">
                        <span id="current-font-size">100</span>%
                    </span>
                    <button id="font-increase" class="font-size-btn" aria-label="Increase font size" title="Increase font size">
                        <span aria-hidden="true">A+</span>
                        <span class="sr-only">Increase font size</span>
                    </button>
                    <button id="font-reset" class="font-size-btn reset-btn" aria-label="Reset font size to default" title="Reset font size to default">
                        <span aria-hidden="true"></span>
                        <span class="sr-only">Reset font size</span>
                    </button>
                </div>

                <!-- Theme Toggle Section -->
                <div class="theme-toggle-section" role="group" aria-labelledby="theme-label">
                    <div id="theme-label" class="theme-label-box">
                        <span class="theme-label-text">Change Theme to </span>
                    </div>
                    <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle theme" title="Toggle between light, dark, and high contrast themes">
                        <span class="theme-icon" aria-hidden="true"></span>
                        <span class="theme-text">High Contrast</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content Area - Two Column Layout -->
        <div class="content-area">
            <!-- Left Column - STL Preview Section (45% width) -->
            <div class="preview-section" role="region" aria-label="3D STL Preview">
                <div id="viewer" role="img" aria-label="3D preview of braille business card STL file" tabindex="0">
                    <div id="error-message" role="alert" aria-live="assertive" aria-atomic="true">
                        <span style="font-weight:bold;" aria-hidden="true"></span>
                        <span id="error-text-container" style="display: flex; flex-direction: column; align-items: center;">
                            <span id="error-text"></span>
                            <span id="error-subtext" style="display: none; font-size: 0.8em; margin-top: 0.4em; opacity: 0.85;"></span>
                        </span>
                    </div>
                </div>
                <!-- Action Button moved here -->
                <div class="button-row" style="margin-top: 1em;">
                    <button type="button" id="action-btn" class="generate-state" aria-label="Generate STL file from entered text" data-state="generate">Generate STL</button>
                </div>
            </div>

            <!-- Right Column - Form Controls Section (55% width) -->
            <div class="form-section" role="region" aria-label="Braille Card Configuration">
                <div class="info-panel">
                    <p><strong>What Does This Program Do?:</strong></p>
                    <p>Generates custom braille "plates" to use in a 3D printable Business Card Braille Embosser {Link to Project Here}. Default plate sizes are for standard 3.5  2 business cards.</p>
                    <p><strong>Where Do I Start?:</strong></p>
                    <p>Read the directions in the "More Info" dropdown menu below:</p>
                </div>

                <div class="info-dropdown">
                    <button type="button" id="info-toggle" class="info-toggle-btn">
                        <span id="info-toggle-text">Directions:</span>
                        <span id="info-toggle-icon"></span>
                    </button>
                    <div id="info-content" class="info-content" style="display: none;">
                        <p><strong>Directions: Making a braille business card (beginnerfriendly)</strong></p>
                        <p><strong>Quick start</strong></p>
                        <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Type your info under <strong>Enter Text for Braille Translation</strong>.</li>
                            <li>Set <strong>Placement Mode</strong> to <strong>Auto Placement</strong> (recommended).</li>
                            <li>Click <strong>Preview Braille Translation</strong>. Fix any warnings.</li>
                            <li>Click <strong>Generate STL</strong>, review the 3D preview, then <strong>Download STL</strong>.</li>
                            <li>Switch <strong>Select Plate to Generate</strong> to <strong>Universal Counter Plate</strong> and <strong>Download STL</strong> again.</li>
                        </ol>

                        <p><strong>What to include (tiny space = tough choices)</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Aim for <strong>4 short lines</strong>, about <strong>13 braille cells per line</strong>.</li>
                            <li>Suggested layout:
                                <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                                    <li>Line 1: Your name</li>
                                    <li>Line 2: Organization/company (optional if clear in email/web)</li>
                                    <li>Line 3: Phone number</li>
                                    <li>Line 4: Email address</li>
                                </ul>
                            </li>
                            <li>If space runs out: shorten organization words (e.g., Amer for American), drop job title, or use lowercase to remove braille capitalization markers.</li>
                        </ul>

                        <p><strong>Smart formatting for tight space (BANAaligned)</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li><strong>Phone:</strong> Enter like <em>123.456.7890</em> (use periods; no parentheses) to minimize numeric markers.</li>
                            <li><strong>Email:</strong> If it must wrap, split after punctuation (at, dot, hyphen). Avoid splitting inside a syllable. Start the next line at the left.</li>
                            <li><strong>Web:</strong> If it must wrap, split after punctuation (colon, period, slash). Avoid splitting inside a syllable. Start the next line at the left.</li>
                            <li><strong>Names:</strong> If a long name wont fit, remove capitals (type lowercase), remove middle initial, or use a first initial plus surname.</li>
                            <li><strong>Grade choice:</strong> Keep <em>English (UEB)  uncontracted (grade 1)</em> for clarity. Use contracted (grade 2) only if you absolutely need to save space.</li>
                        </ul>

                        <p><strong>Using the controls (match these labels in the app)</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li><strong>Placement Mode:</strong>
                                <em>Auto Placement</em> wraps text to fit cells with BANAaware warnings; <em>Manual Placement</em> lets you set each line yourself.
                            </li>
                            <li><strong>Select Language:</strong> Use <em>English (UEB)  uncontracted (grade 1)</em> unless you know you need something else.</li>
                            <li><strong>Select Plate to Generate:</strong> Make the <em>Embossing Plate</em> first, then the <em>Universal Counter Plate</em>.</li>
                            <li><strong>Preview Braille Translation:</strong> Shows your braille lines and a helpful shorthand of contractions; address any warnings before generating STLs.</li>
                            <li><strong>Expert Mode (only if needed):</strong>
                                <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                                    <li><em>Number of Braille Cells (Characters):</em> Keep <strong>13</strong> with indicators On.</li>
                                    <li><em>Number of Braille Lines:</em> <strong>4</strong> is typical.</li>
                                    <li><em>Indicator Shapes:</em> Keep <strong>On</strong> so users can feel row start/end; it reserves 2 cells per row.</li>
                                    <li><em>Card size and spacing:</em> Defaults target standard 3.5  2 cards; adjust only if your cards differ.</li>
                                    <li><em>Dot dimensions:</em> Leave defaults unless embossing is too shallow or too sharp.</li>
                                </ul>
                            </li>
                            <li><strong>Reset Settings:</strong> Restores sensible defaults.</li>
                        </ul>

                        <p><strong>Fitting within limits</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>A cell is one braille character space. Your perrow limit is shown in <em>Number of Braille Cells (Characters)</em>.</li>
                            <li>With indicators On, standard cards typically fit <strong>13 cells  4 lines</strong>.</li>
                            <li>If you see an unsplittable word warning, shorten the word, switch to Manual Placement, or trim other content.</li>
                        </ul>

                        <p><strong>Generating and printing</strong></p>
                        <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li><strong>Generate STL</strong> for the selected plate and review the 3D preview.</li>
                            <li><strong>Download STL</strong> for the <em>Embossing Plate</em>, then repeat for the <em>Universal Counter Plate</em>.</li>
                            <li>Print both plates. Reuse the counter plate; you only need to print it once.</li>
                            <li>Embossing tip: Press firmly and evenly with the card centered. Test on a spare card first.</li>
                        </ol>

                        <p><strong>Common fixes if text wont fit</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Use lowercase to remove capitalization indicators.</li>
                            <li>Abbreviate organization words.</li>
                            <li>Stick with Grade 1 (uncontracted) unless you must switch to Grade 2 (contracted) to save space.</li>
                            <li>Prioritize the essentials: name + one contact (phone or email).</li>
                        </ul>

                        <p><strong>Acknowledgements:</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Powered by <a href="https://liblouis.io/" target="_blank" style="color: #3182ce; text-decoration: none;"><strong>Liblouis</strong></a>, an open-source professional braille translator.</li>
                            <li>Extra thanks to <strong>Tobi Weinberg</strong> for the substantial time and effort he volunteered to help start this project and see it through.</li>
                        </ul>
                    </div>
                </div>

                <form id="braille-form" aria-labelledby="main-heading">
                    <!-- Text Input Section moved into form (separate scrollable pane) -->
                    <div class="line-input-group">
                        <fieldset class="line-input-fieldset">
                            <legend class="grade-label">Enter Text for Braille Translation</legend>
                            <div class="grade-note" style="margin-bottom: 0.8em; font-size: 0.85em;">
                                <strong>Note:</strong> Contracted braille combines letters into single cells, so the character limit is only confirmed <em>after translation</em>  the program will warn you automatically if it's too long.
                            </div>
                            <!-- Placement mode toggle -->
                            <div class="line-input-mode-toggle" style="margin-bottom: 0.8em; display: flex; align-items: center; gap: 1em;">
                                <label class="line-label" for="placement_mode_auto" style="margin: 0;">Placement Mode:</label>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="placement_mode" value="auto" id="placement_mode_auto" checked>
                                    Auto Placement
                                </label>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="placement_mode" value="manual" id="placement_mode_manual">
                                    Manual Placement
                                </label>
                            </div>
                            <!-- Auto placement textarea (hidden by default) -->
                            <div id="auto-input-container" style="display: none;">
                                <label for="auto-text" class="line-label">Auto Placement Text</label>
                                <textarea id="auto-text" rows="4" placeholder="Type all your text here. It will be translated to braille and auto-wrapped across rows based on available cells." style="width: 100%; resize: vertical;"></textarea>
                                <div id="auto-overflow-warning" class="grade-note" style="margin-top: 0.6em; color: #d73502; display: none;">
                                    <strong>Warning:</strong> <span id="auto-overflow-message"></span>
                                </div>
                            </div>
                            <!-- Dynamic line inputs container -->
                            <div id="dynamic-line-inputs">
                                <!-- Line inputs will be dynamically generated here based on grid_rows value -->
                            </div>
                        </fieldset>
                    </div>
                    <!-- Language Selection -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Language:</legend>
                            <div style="margin-bottom: 0.8em;">
                                <select id="language-table" name="language_table" class="language-select" aria-describedby="language-help">
                                    <option value="en-ueb-g2.ctb">English (UEB), United States  contracted (grade 2)</option>
                                    <option value="en-ueb-g1.ctb" selected>English (UEB), United States  uncontracted (grade 1)</option>
                                    <option value="en-us-g2.ctb">English (EBAE), United States  contracted (grade 2)</option>
                                    <option value="en-us-g1.ctb">English (EBAE), United States  uncontracted (grade 1)</option>
                                </select>
                                <div id="language-help" class="grade-note" style="margin-top: 6px; font-size: 0.85em;">
                                    Default: English (UEB), United States  uncontracted (grade 1). Chosen to align with BANA guidance for business cards and to minimize ambiguity for names, emails, and short contact info. Use contracted (grade 2) only when space is limited.
                                </div>
                            </div>
                        </fieldset>
                    </div>

                    <!-- Plate Type Selection moved here -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Plate to Generate</legend>
                            <div class="radio-group" role="radiogroup" aria-required="true">
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="positive" checked aria-describedby="emboss-plate-desc">
                                    <span class="radio-text">Embossing Plate</span>
                                </label>
                                <span id="emboss-plate-desc" class="sr-only">Creates raised braille dots for embossing cards</span>
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="negative" aria-describedby="counter-plate-desc">
                                    <span class="radio-text">Universal Counter Plate</span>
                                </label>
                                <span id="counter-plate-desc" class="sr-only">Creates recessed dots to support embossing process</span>

                            </div>
                        </fieldset>
                    </div>
                    <!-- Reset Settings menu box -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Reset Settings</legend>
                            <div class="reset-container">
                                <button type="button" id="reset-defaults-btn" class="reset-btn" aria-label="Reset all settings to default">Reset all settings to default</button>
                            </div>
                        </fieldset>
                    </div>





                    <div class="expert-mode-toggle">
                        <button type="button" id="expert-toggle" class="expert-toggle-btn">
                            <span id="expert-toggle-text">Show Expert Mode</span>
                            <span id="expert-toggle-icon"></span>
                        </button>
                    </div>

                    <div id="expert-settings" class="expert-settings" style="display: none;">
                        <div class="expert-info" role="note" aria-label="Expert mode information">
                            Any changes made here will affect both plates.
                        </div>

                        <!-- Preview button moved to the top of Expert Mode -->
                        <div style="margin-top: 1em; margin-bottom: 0.5em; text-align: center;">
                            <button type="button" id="preview-braille-btn">Preview Braille Translation</button>
                        </div>

                        <div id="braille-preview" class="braille-preview" style="display: none;" role="region" aria-label="Braille translation preview">
                            <h3 class="preview-heading">Braille Translation Preview:</h3>
                            <div id="preview-content"></div>
                        </div>

                        <!-- Submenu: Shape Selection -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Shape Selection</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <!-- Output Shape Selection (moved into Expert Mode) -->
                                <div class="grade-selection">
                                    <fieldset>
                                        <legend class="grade-label">Output Shape (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-required="true">
                                            <label class="radio-option">
                                                <input type="radio" name="shape_type" value="cylinder" checked aria-describedby="cylinder-shape-desc">
                                                <span class="radio-text">Cylinder</span>
                                            </label>
                                            <span id="cylinder-shape-desc" class="sr-only">Creates a cylindrical braille surface</span>
                                            <label class="radio-option" style="opacity: 0.5; cursor: not-allowed;">
                                                <input type="radio" name="shape_type" value="card" disabled aria-describedby="card-shape-desc">
                                                <span class="radio-text">Flat Card <em style="font-size: 0.85em; color: var(--warning-color, #f39c12);">(temporarily disabled)</em></span>
                                            </label>
                                            <span id="card-shape-desc" class="sr-only">Creates a flat rectangular braille card - temporarily disabled</span>
                                        </div>
                                    </fieldset>
                                </div>

                                <!-- Combined Shape Selection (for both Embossing Plate and Counter Plate) -->
                                <div class="grade-selection" id="combined-shape-selection" style="display: block;">
                                    <fieldset>
                                        <legend class="grade-label">Braille Dot Shape (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-required="true">
                                            <label class="radio-option">
                                                <input type="radio" name="combined_shape" value="rounded" checked aria-describedby="rounded-combined-desc">
                                                <span class="radio-text">Rounded</span>
                                            </label>
                                            <span id="rounded-combined-desc" class="sr-only">Creates rounded dome dots for emboss plate and spherical-cap bowl recess for counter plate</span>
                                            <label class="radio-option">
                                                <input type="radio" name="combined_shape" value="cone" aria-describedby="cone-combined-desc">
                                                <span class="radio-text">Cone</span>
                                            </label>
                                            <span id="cone-combined-desc" class="sr-only">Creates cone frustum dots for emboss plate and conical frustum recess for counter plate</span>
                                        </div>
                                    </fieldset>
                                </div>

                                <!-- Hidden radio buttons for backend compatibility -->
                                <div style="display: none;">
                                    <input type="radio" name="dot_shape" value="rounded" checked>
                                    <input type="radio" name="dot_shape" value="cone">
                                    <input type="radio" name="recess_shape" value="1" checked>
                                    <input type="radio" name="recess_shape" value="2">
                                </div>

                                <!-- Indicator Shape toggle -->
                                <div class="grade-selection">
                                    <fieldset>
                                        <legend class="grade-label" style="font-size: 1.2em; font-weight: 700;">Indicator Shapes (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-label="Indicator Shape toggle">
                                            <label class="radio-option">
                                                <input type="radio" name="indicator_shapes" id="indicator_on" value="1" checked>
                                                <span class="radio-text">On</span>
                                            </label>
                                            <label class="radio-option">
                                                <input type="radio" name="indicator_shapes" id="indicator_off" value="0">
                                                <span class="radio-text">Off</span>
                                            </label>
                                        </div>
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            When On: 2 cells are reserved per row for start/end markers. When Off: all cells are available for text.
                                        </div>
                                    </fieldset>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Braille Spacing -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Braille Spacing</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille Dimensions</label>
                                    <div>
                                        <label for="grid_columns" id="grid_columns_label">Number of Braille Cells (Characters):</label>
                                        <input type="number" id="grid_columns" name="grid_columns" value="13" style="width: 110px;">
                                        <div id="grid_columns_note" class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            For embossing plates: 2 cells are reserved for row indicators (start/end markers), leaving 13 cells available for text.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="grid_rows">Number of Braille Lines:</label>
                                        <input type="number" id="grid_rows" name="grid_rows" value="4" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cell_spacing">Braille Cell Spacing:</label>
                                        <input type="number" id="cell_spacing" name="cell_spacing" value="6.5" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="line_spacing">Braille Line Spacing:</label>
                                        <input type="number" id="line_spacing" name="line_spacing" value="10.0" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="dot_spacing">Braille Dot Spacing:</label>
                                        <input type="number" id="dot_spacing" name="dot_spacing" value="2.5" step="0.1" style="width: 110px;">
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille / Card Positioning</label>
                                    <div>
                                        <label for="braille_y_adjust">Y Adjust:</label>
                                        <input type="number" id="braille_y_adjust" name="braille_y_adjust" value="0.0" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="braille_x_adjust">X Adjust:</label>
                                        <input type="number" id="braille_x_adjust" name="braille_x_adjust" value="0.0" step="0.1" style="width: 110px;">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Braille Dot Adjustments -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Braille Dot Adjustments</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection" id="rounded_dot_group" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Embossing Braille Dot Dimensions (Rounded Shape)</label>
                                    <div>
                                        <label for="rounded_dot_base_diameter">Rounded braille dot base diameter (cone base) (mm):</label>
                                        <input type="number" id="rounded_dot_base_diameter" name="rounded_dot_base_diameter" value="2.0" step="0.1" min="0.5" max="3" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_base_height">Rounded braille dot base height (cone height) (mm):</label>
                                        <input type="number" id="rounded_dot_base_height" name="rounded_dot_base_height" value="0.2" step="0.1" min="0" max="2.0" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_dome_diameter">Rounded braille dome diameter (linked to cone flat top) (mm):</label>
                                        <input type="number" id="rounded_dot_dome_diameter" name="rounded_dot_dome_diameter" value="1.5" step="0.1" min="0.5" max="3.0" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_dome_height">Rounded braille dot dome height (mm):</label>
                                        <input type="number" id="rounded_dot_dome_height" name="rounded_dot_dome_height" value="0.6" step="0.1" min="0.1" max="2.0" style="width: 110px;">
                                    </div>
                                    <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                        The cone base sits on the surface; the dome grows from the cone's flat top. Dome diameter is always equal to the cone flat-top diameter.
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Embossing Braille Dot Dimensions (Cone Shape)</label>
                                    <div>
                                        <label for="emboss_dot_base_diameter">Dot diameter:</label>
                                        <input type="number" id="emboss_dot_base_diameter" name="emboss_dot_base_diameter" value="1.8" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="emboss_dot_height">Dot height:</label>
                                        <input type="number" id="emboss_dot_height" name="emboss_dot_height" value="1.0" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="emboss_dot_flat_hat">Flat hat diameter:</label>
                                        <input type="number" id="emboss_dot_flat_hat" name="emboss_dot_flat_hat" value="0.4" step="0.1" style="width: 110px;">
                                    </div>
                                </div>

                                <!-- Counter Braille Recessed Dot Dimensions (Rounded Shape) -->
                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Braille Recessed Dot Dimensions (Rounded Shape)</label>
                                    <!-- Hidden hemisphere dial for future use -->
                                    <div style="display: none;">
                                        <label for="hemi_counter_dot_base_diameter">Hemisphere Recess Dot Base Diameter (mm):</label>
                                        <input type="number" id="hemi_counter_dot_base_diameter" name="hemi_counter_dot_base_diameter" value="1.6" step="0.1" min="0.5" max="5">
                                    </div>
                                    <div id="hemisphere_dimensions_group" style="margin-top: 6px; display: none;">
                                        <div class="grade-note" style="font-size: 0.85em;">
                                            Hemisphere depth equals radius at the opening.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="bowl_counter_dot_base_diameter">Bowl Recess Dot Base Diameter (mm):</label>
                                        <input type="number" id="bowl_counter_dot_base_diameter" name="bowl_counter_dot_base_diameter" value="1.8" step="0.1" min="0.5" max="5" style="width: 110px;">
                                    </div>
                                    <div id="bowl_dimensions_group" style="margin-top: 6px;">
                                        <div>
                                            <label for="counter_dot_depth">Bowl Recess Dot Depth (mm):</label>
                                            <input type="number" id="counter_dot_depth" name="counter_dot_depth" value="0.8" step="0.1" min="0" max="5" style="width: 110px;">
                                        </div>
                                    </div>
                                </div>

                                <!-- Counter Braille Recessed Dot Dimensions (Cone Shape) -->
                                <div class="grade-selection" id="cone_dimensions_group" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Braille Recessed Dot Dimensions (Cone Shape)</label>
                                    <div>
                                        <label for="cone_counter_dot_base_diameter">Dot Base Diameter (mm):</label>
                                        <input type="number" id="cone_counter_dot_base_diameter" name="cone_counter_dot_base_diameter" value="1.6" step="0.1" min="0.1" max="5" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cone_counter_dot_height">Dot Height (mm):</label>
                                        <input type="number" id="cone_counter_dot_height" name="cone_counter_dot_height" value="0.8" step="0.1" min="0" max="5" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cone_counter_dot_flat_hat">Dot Flat Hat Diameter (mm):</label>
                                        <input type="number" id="cone_counter_dot_flat_hat" name="cone_counter_dot_flat_hat" value="0.4" step="0.1" min="0" max="5" style="width: 110px;">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Surface Dimensions -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Surface Dimensions</span>
                                <span class="expert-submenu-icon"></span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Cylinder Dimensions</label>
                                    <div>
                                        <label for="cylinder_diameter_mm">Cylinder Diameter (mm):</label>
                                        <input type="number" id="cylinder_diameter_mm" name="cylinder_diameter_mm" value="30.75" step="0.1" min="10" max="200" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_height_mm">Cylinder Height (mm):</label>
                                        <input type="number" id="cylinder_height_mm" name="cylinder_height_mm" value="52" step="0.1" min="10" max="200" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_polygonal_cutout_radius_mm">Polygonal Cutout Circumscribed Radius (mm):</label>
                                        <input type="number" id="cylinder_polygonal_cutout_radius_mm" name="cylinder_polygonal_cutout_radius_mm" value="13" step="0.1" min="0" max="50" style="width: 110px;">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Creates a polygonal cutout along the cylinder's length. Set to 0 for no cutout.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_polygonal_cutout_sides">Polygonal Cutout Points:</label>
                                        <input type="number" id="cylinder_polygonal_cutout_sides" name="cylinder_polygonal_cutout_sides" value="12" step="1" min="3" max="60" style="width: 110px;">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Lower values create simpler shapes (e.g., 6); higher values approximate a circle.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="seam_offset_deg">Seam Offset (degrees):</label>
                                        <input type="number" id="seam_offset_deg" name="seam_offset_deg" value="355" step="1" min="0" max="360" style="width: 110px;">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Rotates the starting position of braille text around the cylinder
                                        </div>
                                    </div>
                                    <div id="cylinder-overflow-warning" class="grade-note" style="margin-top: 10px; color: #d73502; display: none;">
                                        <strong>Warning:</strong> <span id="cylinder-overflow-message"></span>
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Plate Dimensions</label>
                                    <div>
                                        <label for="card_width">Plate Width:</label>
                                        <input type="number" id="card_width" name="card_width" value="90" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="card_height">Plate Height:</label>
                                        <input type="number" id="card_height" name="card_height" value="52" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="card_thickness">Plate Thickness:</label>
                                        <input type="number" id="card_thickness" name="card_thickness" value="2.0" step="0.1" style="width: 110px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="button-group">
                        <!-- Test buttons removed as they are no longer needed -->
                    </div>
                </form>
            </div>
        </div>
    </div>



    <!-- Load the real liblouis JavaScript implementation from static files -->
    <script src="/static/liblouis/build-no-tables-utf16.js"></script>
    <script src="/static/liblouis/easy-api.js"></script>

    <script type="module">
        import * as THREE from '/static/three.module.js';
        import { STLLoader } from '/static/STLLoader.js';
        import { OrbitControls } from '/static/OrbitControls.js';
        async function loadLanguageOptions() {
            const select = document.getElementById('language-table');
            if (!select) return;

            // Preserve the four top U.S. English defaults (UEB and EBAE)
            const defaultValues = new Set(['en-ueb-g2.ctb', 'en-ueb-g1.ctb', 'en-us-g2.ctb', 'en-us-g1.ctb']);
            const defaultOptions = Array.from(select.querySelectorAll('option')).filter(o => defaultValues.has(o.value));

            // Clear existing and re-add defaults in an optgroup
            select.innerHTML = '';
            const defaultGroup = document.createElement('optgroup');
            defaultGroup.label = 'Default';
            defaultOptions.forEach(o => defaultGroup.appendChild(o));
            select.appendChild(defaultGroup);

            // Fetch available tables from backend
            let resp;
            try {
                resp = await fetch('/liblouis/tables', { credentials: 'same-origin' });
            } catch (e) {
                return; // Fail silently; defaults remain
            }
            if (!resp || !resp.ok) return;
            const data = await resp.json().catch(() => null);
            if (!data || !Array.isArray(data.tables)) return;

            // Build label for each entry (native-language autonyms)
            const otherGroup = document.createElement('optgroup');
            otherGroup.label = 'Other';

            const seen = new Set(defaultValues);
            const entries = data.tables.slice();

            // Sort: English first, then by locale and file name
            entries.sort((a, b) => {
                const aEn = (a.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                const bEn = (b.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                if (aEn !== bEn) return aEn - bEn;
                const al = (a.locale || '').toLowerCase();
                const bl = (b.locale || '').toLowerCase();
                if (al !== bl) return al < bl ? -1 : 1;
                const af = (a.file || '').toLowerCase();
                const bf = (b.file || '').toLowerCase();
                return af < bf ? -1 : af > bf ? 1 : 0;
            });

            // Name helpers using Intl.DisplayNames for correctness
            const getLanguageAutonym = (lang) => {
                try {
                    // Use the language's own locale to get its autonym
                    const dn = new Intl.DisplayNames([lang], { type: 'language' });
                    return dn.of(lang) || lang;
                } catch (e) {
                    // Fallback capitalization
                    return lang.charAt(0).toUpperCase() + lang.slice(1);
                }
            };

            const getLanguageEnglish = (lang) => {
                try {
                    const dn = new Intl.DisplayNames(['en'], { type: 'language' });
                    return dn.of(lang) || lang;
                } catch (e) {
                    return lang.charAt(0).toUpperCase() + lang.slice(1);
                }
            };

            const getRegionEnglish = (region) => {
                if (!region) return '';
                try {
                    const dn = new Intl.DisplayNames(['en'], { type: 'region' });
                    return dn.of(region) || region;
                } catch (e) {
                    return region;
                }
            };

            // Helper to get full display name: autonym first, then English
            const getDisplayName = (t) => {
                const locale = (t.locale || '').replace('_', '-');
                const parts = locale.split('-');
                const langCode = (parts[0] || 'und').toLowerCase();
                const region = parts[1] ? parts[1].toUpperCase() : '';

                const auto = getLanguageAutonym(langCode);
                const eng = getLanguageEnglish(langCode);
                const regionEng = getRegionEnglish(region);

                let displayName = auto === eng ? auto : `${auto}  ${eng}`;
                if (regionEng) displayName += `, ${regionEng}`;

                return displayName;
            };

            // Process entries
            const usedSemantic = new Set(); // Deduplicate by semantic identity (locale+variant+grade+type+dots)

            for (const t of entries) {
                const file = t.file;
                if (!file || seen.has(file)) continue;
                seen.add(file);

                // Get base language name
                let baseName = getDisplayName(t);

                // Build description parts
                const parts = [];

                // Grade/contraction info
                if (t.grade === '2') {
                    parts.push('contracted');
                } else if (t.grade === '1') {
                    parts.push('uncontracted');
                } else if (t.grade === '0') {
                    parts.push('computer');
                }

                // Type info
                if (t.type === 'computer' && !parts.includes('computer')) {
                    if (t.dots === 8) {
                        parts.push('8-dot computer');
                    } else {
                        parts.push('computer');
                    }
                } else if (t.type === 'literary' && t.contraction === 'full') {
                    if (!parts.includes('contracted')) {
                        parts.push('literary');
                    }
                }

                // Variant info (UEB, EBAE, etc)
                if (t.variant) {
                    parts.push(t.variant);
                }

                // Special naming for specific files
                if (file === 'en-ueb-g2.ctb') {
                    baseName = 'English (UEB), United States';
                    parts.length = 0;
                    parts.push('contracted', 'grade 2');
                } else if (file === 'en-ueb-g1.ctb') {
                    baseName = 'English (UEB), United States';
                    parts.length = 0;
                    parts.push('uncontracted', 'grade 1');
                } else if (file === 'en-us-g2.ctb') {
                    baseName = 'English (EBAE), United States';
                    parts.length = 0;
                    parts.push('contracted', 'grade 2');
                } else if (file === 'en-us-g1.ctb') {
                    baseName = 'English (EBAE), United States';
                    parts.length = 0;
                    parts.push('uncontracted', 'grade 1');
                } else if (file.includes('-comp')) {
                    if (!parts.includes('computer') && !parts.includes('8-dot computer')) {
                        parts.push('computer braille');
                    }
                }

                // Build final label
                let label = baseName;
                if (parts.length > 0) {
                    label += ` (${parts.join(', ')})`;
                }

                // Deduplicate by semantic identity to avoid near-duplicate entries
                const semanticKey = [
                    (t.locale || '').toLowerCase(),
                    (t.variant || '').toLowerCase(),
                    (t.grade || '').toString().toLowerCase(),
                    (t.type || '').toLowerCase(),
                    (t.dots == null ? '' : String(t.dots))
                ].join('|');
                if (usedSemantic.has(semanticKey)) {
                    continue; // Skip duplicates
                }
                usedSemantic.add(semanticKey);

                const opt = document.createElement('option');
                opt.value = file;
                opt.textContent = label;
                otherGroup.appendChild(opt);
            }

            select.appendChild(otherGroup);

            // Default to UEB grade 1 unless user has a saved preference (business card-friendly)
            try {
                const saved = localStorage.getItem('braille_prefs_language_table');
                const hasSaved = saved && Array.from(select.options).some(o => o.value === saved);
                select.value = hasSaved ? saved : 'en-ueb-g1.ctb';
            } catch (e) {
                select.value = 'en-ueb-g1.ctb';
            }
        }

        // Kick off language options load ASAP
        loadLanguageOptions().then(() => {
            try {
                const select = document.getElementById('language-table');
                // Force default to English (UEB) uncontracted grade 1 if available
                try {
                    const desiredDefault = 'en-ueb-g1.ctb';
                    const hasDesired = Array.from(select.options).some(o => o.value === desiredDefault);
                    if (hasDesired) select.value = desiredDefault;
                } catch (e) {}
                select.addEventListener('change', () => {
                    try { localStorage.setItem('braille_prefs_language_table', select.value); } catch (e) {}
                    // Keep per-line language dropdowns in sync with available options
                    try { syncLineLanguageSelects(); } catch (e) {}
                });
                // Populate per-line selects once options are loaded
                try { syncLineLanguageSelects(); } catch (e) {}
            } catch (e) {}
        });


        // Declare 3D scene variables at module scope
        let renderer, scene, camera, mesh, controls;
        let lastSTLUrl = null;

        // Production logging - only log errors in production
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        const log = {
            debug: isProduction ? () => {} : console.log,
            info: isProduction ? () => {} : console.log,
            error: console.error // Always log errors
        };

        // Helper function to sync emboss cone params to counter cone params (module scope)
        function syncEmbossToCounterConeParams() {
            const embossBase = document.getElementById('emboss_dot_base_diameter');
            const embossHeight = document.getElementById('emboss_dot_height');
            const embossFlatHat = document.getElementById('emboss_dot_flat_hat');
            const counterBase = document.getElementById('cone_counter_dot_base_diameter');
            const counterHeight = document.getElementById('cone_counter_dot_height');
            const counterFlatHat = document.getElementById('cone_counter_dot_flat_hat');

            if (embossBase && counterBase) {
                counterBase.value = embossBase.value;
                log.debug('Synced cone_counter_dot_base_diameter to:', embossBase.value);
            }
            if (embossHeight && counterHeight) {
                counterHeight.value = embossHeight.value;
                log.debug('Synced cone_counter_dot_height to:', embossHeight.value);
            }
            if (embossFlatHat && counterFlatHat) {
                counterFlatHat.value = embossFlatHat.value;
                log.debug('Synced cone_counter_dot_flat_hat to:', embossFlatHat.value);
            }
        }

        // Theme switching functionality
        const themes = ['dark', 'high-contrast', 'light'];
        const themeIcons = {
            'dark': '',
            'high-contrast': '',
            'light': ''
        };
        const themeNames = {
            'dark': 'Dark',
            'high-contrast': 'High Contrast',
            'light': 'Light'
        };

        // 
        // CAMERA SETTINGS - Central configuration for STL preview camera positions
        // 
        // These settings control the initial camera position when STL models are generated.
        // Adjust these values to change the default viewing angle for each shape type.
        //
        // Coordinate System:
        //   - Cards: Y-axis is up, camera looks from +Z axis toward origin
        //   - Cylinders: Z-axis is up (cylinder axis), camera looks from XY plane toward origin
        //
        // To rotate the initial view:
        //   - For cylinders: Adjust CYLINDER.position.x and .y to rotate around the Z-axis
        //     Example: { x: -120, y: 0 } views from -X axis (opposite side)
        //     Example: { x: 0, y: 120 } views from +Y axis (90 rotation)
        //   - For cards: Adjust CARD.position values as needed
        //
        // Distance from origin determines zoom level (larger = more zoomed out)
        // 
        const CAMERA_SETTINGS = {
            // Card shape camera settings (standard flat plate)
            CARD: {
                position: { x: 0, y: 0, z: 120 },   // Camera on +Z axis, looking at origin
                up: { x: 0, y: 1, z: 0 },           // Y-axis is up
                target: { x: 0, y: 0, z: 0 },       // Look at origin
                fov: 45,                            // Field of view in degrees
                near: 0.1,                          // Near clipping plane
                far: 1000                           // Far clipping plane
            },
            // Cylinder shape camera settings (cylindrical surface)
            // Camera positioned to view the indicator shapes (triangle/rectangle) side
            CYLINDER: {
                position: { x: -120, y: 0, z: 0 },  // Camera on -X axis (views indicator side)
                up: { x: 0, y: 0, z: 1 },           // Z-axis is up (cylinder axis)
                target: { x: 0, y: 0, z: 0 },       // Look at origin
                fov: 45,                            // Field of view in degrees
                near: 0.1,                          // Near clipping plane
                far: 1000                           // Far clipping plane
            }
        };

        let currentThemeIndex = 0;
        // Always start in dark mode; do not persist theme
        applyTheme('dark');

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);

            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');

            // Find the next theme in the cycle
            const currentIndex = themes.indexOf(theme);
            const nextIndex = (currentIndex + 1) % themes.length;
            const nextTheme = themes[nextIndex];

            // Show the next theme that will be applied when clicked
            themeIcon.textContent = themeIcons[nextTheme];
            themeText.textContent = themeNames[nextTheme];

            // Update aria-label to show current theme and what will happen next
            themeToggle.setAttribute('aria-label', `Current theme: ${themeNames[theme]}. Click to switch to ${themeNames[nextTheme]} theme`);

            // Announce theme change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Theme changed to ${themeNames[theme]}`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);

            // Update 3D scene colors for new theme
            update3DSceneColors();
        }

        document.getElementById('theme-toggle').addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(themes[currentThemeIndex]);
        });

        // Function to update 3D scene colors when theme changes
        function update3DSceneColors() {
            if (typeof scene !== 'undefined' && scene && typeof renderer !== 'undefined' && renderer) {
                const styles = getComputedStyle(document.documentElement);
                const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
                const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
                const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
                const stlMeshColor = styles.getPropertyValue('--stl-mesh-color').trim() || '#6699cc';
                const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
                const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;

                // Update scene background
                scene.background = new THREE.Color(stlBackground);

                // Remove existing lights to rebuild them with proper configuration
                const sceneLightsToRemove = scene.children.filter(child =>
                    child instanceof THREE.DirectionalLight || child instanceof THREE.AmbientLight
                );
                sceneLightsToRemove.forEach(light => scene.remove(light));

                // Also remove camera-attached directional lights
                const cameraLightsToRemove = camera.children.filter(child =>
                    child instanceof THREE.DirectionalLight
                );
                cameraLightsToRemove.forEach(light => camera.remove(light));

                // Rebuild lighting based on current theme
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);

                if (currentTheme === 'high-contrast') {
                    // High contrast mode: conventional three-point lighting for better detail visibility
                    // Key light: 45 horizontal, 30 vertical (right side) - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);

                    // Fill light: 45 horizontal, 15 vertical (left side) for shadow softening - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                    fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                    camera.add(fillLight);

                    // Subtle back light for edge definition - camera-relative
                    const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                    backLight.position.set(0, 0.5, -0.866).normalize();
                    camera.add(backLight);
                } else {
                    // Standard lighting: conventional angle for optimal detail visibility
                    // Key light: 45 horizontal, 30 vertical - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);

                    // Add subtle fill light for standard modes too - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                    fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                    camera.add(fillLight);
                }

                // Add ambient light
                scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));

                // Update mesh color and material properties if mesh exists
                if (mesh && mesh.material) {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    mesh.material.color = new THREE.Color(stlMeshColor);

                    // Update specular properties for high contrast mode
                    if (currentTheme === 'high-contrast') {
                        mesh.material.specular = new THREE.Color(0xffffff); // White specular highlights
                        mesh.material.shininess = 300; // Higher shininess for sharper highlights
                    } else {
                        mesh.material.specular = new THREE.Color(0x111111); // Standard specular
                        mesh.material.shininess = 200; // Standard shininess
                    }

                    mesh.material.needsUpdate = true;
                }

                // Force a re-render
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }
        }

        // Theme initialization is handled above in the main theme logic

        // Font size adjustment functionality
        const fontSizes = [75, 87.5, 100, 112.5, 125, 150, 175, 200];
        let currentFontSizeIndex = 2; // Start at 100%

        // Check if mobile device
        const isMobile = window.innerWidth <= 768;

        // Always start at default 100%; do not persist font size
        currentFontSizeIndex = 2;

        function applyFontSize(sizeIndex) {
            const size = fontSizes[sizeIndex];
            document.documentElement.style.fontSize = size + '%';
            document.getElementById('current-font-size').textContent = size;
            currentFontSizeIndex = sizeIndex;

            // Announce font size change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Font size changed to ${size}%`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
        }

        // Initialize font size
        applyFontSize(currentFontSizeIndex);

        // Font size control event listeners
        document.getElementById('font-decrease').addEventListener('click', () => {
            if (currentFontSizeIndex > 0) {
                applyFontSize(currentFontSizeIndex - 1);
            }
        });

        document.getElementById('font-increase').addEventListener('click', () => {
            if (currentFontSizeIndex < fontSizes.length - 1) {
                applyFontSize(currentFontSizeIndex + 1);
            }
        });

        document.getElementById('font-reset').addEventListener('click', () => {
            applyFontSize(2); // Reset to 100%
        });

        const form = document.getElementById('braille-form');
        const viewer = document.getElementById('viewer');
        const actionBtn = document.getElementById('action-btn');
        let lastGeneratedSTLUrl = null;
        let lastGeneratedFilename = null;

        const previewBrailleBtn = document.getElementById('preview-braille-btn');
        const errorDiv = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');

        // Function to reset button to generate state
        function resetToGenerateState() {
            actionBtn.textContent = 'Generate STL';
            actionBtn.className = 'generate-state';
            actionBtn.setAttribute('data-state', 'generate');
            actionBtn.setAttribute('aria-label', 'Generate STL file from entered text');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }

        // Function to set button to download state
        function setToDownloadState() {
            actionBtn.textContent = 'Download STL';
            actionBtn.className = 'download-state';
            actionBtn.setAttribute('data-state', 'download');
            actionBtn.setAttribute('aria-label', 'Download generated STL file');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }

        // Store the current plate type for download naming
        let currentPlateType = 'positive';

        // Add event handler for the action button
        actionBtn.addEventListener('click', () => {
            if (actionBtn.getAttribute('data-state') === 'generate') {
                form.dispatchEvent(new Event('submit'));
            } else if (actionBtn.getAttribute('data-state') === 'download') {
                // Download the generated STL
                if (lastGeneratedSTLUrl) {
                    const a = document.createElement('a');
                    a.href = lastGeneratedSTLUrl;
                    // Use the filename generated on the frontend
                    if (lastGeneratedFilename) {
                        a.download = lastGeneratedFilename;
                    }
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }
        });
        const expertToggleBtn = document.getElementById('expert-toggle');
        const expertSettings = document.getElementById('expert-settings');
        const expertToggleText = document.getElementById('expert-toggle-text');
        const expertToggleIcon = document.getElementById('expert-toggle-icon');
        const braillePreview = document.getElementById('braille-preview');
        const previewContent = document.getElementById('preview-content');
        const infoToggleBtn = document.getElementById('info-toggle');
        const infoContent = document.getElementById('info-content');
        const infoToggleText = document.getElementById('info-toggle-text');
        const infoToggleIcon = document.getElementById('info-toggle-icon');



        // Add event listeners to reset button state when inputs change
        function addInputChangeListeners() {
            // Dynamic text input fields
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                if (input) {
                    // Remove existing listener to prevent duplicates
                    input.removeEventListener('input', resetToGenerateState);
                    input.addEventListener('input', resetToGenerateState);
                }
            }

            // Language selection
            const languageSelect = document.getElementById('language-table');
            if (languageSelect) {
                languageSelect.addEventListener('change', function() {
                    resetToGenerateState();
                });
            }

            // Function to update grid columns based on plate type (promoted to top-level scope below)
            function updateGridColumnsForPlateType(preserveValue = false) {
                const plateType = document.querySelector('input[name="plate_type"]:checked').value;
                const gridColumnsInput = document.getElementById('grid_columns');
                const gridColumnsLabel = document.getElementById('grid_columns_label');
                const gridColumnsNote = document.getElementById('grid_columns_note');
                const indicatorOn = document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';

                // Store current value before update
                const currentValue = parseInt(gridColumnsInput.value);

                if (plateType === 'positive') {
                    // Embossing plate - available cells depend on indicator toggle
                    gridColumnsLabel.textContent = 'Number of Available Braille Cells:';
                    gridColumnsNote.style.display = 'block';
                    gridColumnsNote.textContent = indicatorOn
                        ? 'For embossing plates: 2 cells are reserved for row indicators (start/end markers).'
                        : 'Indicators off: all columns are available for text.';
                    // Always normalize the dial to the recommended default to avoid drift
                    gridColumnsInput.value = indicatorOn ? '13' : '15';
                } else {
                    // Counter plate - available cells depend on indicator toggle
                    gridColumnsLabel.textContent = 'Available Braille Cells for Text:';
                    gridColumnsNote.textContent = indicatorOn
                        ? 'For counter plates: 2 cells are reserved for row indicators (start/end markers), leaving 13 cells available for text.'
                        : 'Indicators off: all columns are available for text.';
                    gridColumnsNote.style.display = 'block';
                    // Always normalize the dial to the recommended default to avoid drift
                    gridColumnsInput.value = indicatorOn ? '13' : '15';
                }
            }
            // Expose for other handlers safely
            try { window.updateGridColumnsForPlateType = updateGridColumnsForPlateType; } catch (e) {}

            // Plate type radio buttons
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateGridColumnsForPlateType();
                    const combinedShapeSel = document.getElementById('combined-shape-selection');
                    if (combinedShapeSel) { combinedShapeSel.style.display = 'block'; }
                    const roundedGroup = document.getElementById('rounded_dot_group');
                    if (roundedGroup) roundedGroup.style.display = '';
                    if (document.querySelector('input[name="placement_mode"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                });
            });

            // Initialize grid columns on page load
            updateGridColumnsForPlateType();
            // Wire indicator toggle listeners
            document.querySelectorAll('input[name="indicator_shapes"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateGridColumnsForPlateType(true);
                    if (document.querySelector('input[name=\"placement_mode\"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                });
            });

            // Shape type radio buttons
            document.querySelectorAll('input[name="shape_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                    if (document.querySelector('input[name=\"placement_mode\"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                    // Do not persist shape selection; always reset on reload
                });
            });
            // Plate type radio buttons (update dependent UI; recess controls always visible)
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                });
            });

            // Counter plate controls
            const hemiCounterBase = document.getElementById('hemi_counter_dot_base_diameter');
            const bowlCounterBase = document.getElementById('bowl_counter_dot_base_diameter');
            const counterDotDepth = document.getElementById('counter_dot_depth');
            const coneCounterBase = document.getElementById('cone_counter_dot_base_diameter');
            const coneCounterHeight = document.getElementById('cone_counter_dot_height');
            const coneCounterHat = document.getElementById('cone_counter_dot_flat_hat');
            if (hemiCounterBase) hemiCounterBase.addEventListener('input', resetToGenerateState);
            if (bowlCounterBase) bowlCounterBase.addEventListener('input', resetToGenerateState);
            if (counterDotDepth) counterDotDepth.addEventListener('input', resetToGenerateState);
            if (coneCounterBase) coneCounterBase.addEventListener('input', resetToGenerateState);
            if (coneCounterHeight) coneCounterHeight.addEventListener('input', resetToGenerateState);
            if (coneCounterHat) coneCounterHat.addEventListener('input', resetToGenerateState);

            // Combined shape selection - sets both emboss and counter shapes
            document.querySelectorAll('input[name="combined_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    resetToGenerateState();
                    const combinedVal = document.querySelector('input[name="combined_shape"]:checked')?.value || 'rounded';
                    const isRounded = combinedVal === 'rounded';
                    const isCone = combinedVal === 'cone';

                    console.log('Combined shape changed to:', combinedVal, 'isRounded:', isRounded, 'isCone:', isCone);

                    // Set emboss plate shape (dot_shape)
                    const dotShapeRadios = document.querySelectorAll('input[name="dot_shape"]');
                    dotShapeRadios.forEach(radio => {
                        if (isRounded && radio.value === 'rounded') {
                            radio.checked = true;
                            console.log('Set dot_shape to rounded');
                        }
                        if (isCone && radio.value === 'cone') {
                            radio.checked = true;
                            console.log('Set dot_shape to cone');
                        }
                    });

                    // Set counter plate shape (recess_shape)
                    const recessShapeRadios = document.querySelectorAll('input[name="recess_shape"]');
                    recessShapeRadios.forEach(radio => {
                        if (isRounded && radio.value === '1') {
                            radio.checked = true; // Bowl (rounded)
                            console.log('Set recess_shape to 1 (bowl)');
                        }
                        if (isCone && radio.value === '2') {
                            radio.checked = true; // Cone
                            console.log('Set recess_shape to 2 (cone)');
                        }
                    });

                    // Sync emboss cone parameters to counter cone parameters when cone is selected
                    if (isCone) {
                        syncEmbossToCounterConeParams();
                    }

                    // Update dimension groups visibility
                    const bowlGroup = document.getElementById('bowl_dimensions_group');
                    const coneGroup = document.getElementById('cone_dimensions_group');
                    if (bowlGroup) bowlGroup.style.display = '';
                    if (coneGroup) coneGroup.style.display = '';

                    // Debug: Log current values
                    const currentDotShape = document.querySelector('input[name="dot_shape"]:checked')?.value;
                    const currentRecessShape = document.querySelector('input[name="recess_shape"]:checked')?.value;
                    console.log('After sync - dot_shape:', currentDotShape, 'recess_shape:', currentRecessShape);
                });
            });

            // Add listeners to sync emboss cone params to counter cone params when changed
            ['emboss_dot_base_diameter', 'emboss_dot_height', 'emboss_dot_flat_hat'].forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        // Only sync if cone shape is selected
                        const isCone = document.querySelector('input[name="combined_shape"]:checked')?.value === 'cone';
                        if (isCone) {
                            syncEmbossToCounterConeParams();
                        }
                    });
                }
            });

            // Expert mode parametric dials
            const expertInputs = [
                'emboss_dot_base_diameter',
                'emboss_dot_height',
                'emboss_dot_flat_hat',
                'hemi_counter_dot_base_diameter',
                'bowl_counter_dot_base_diameter',
                'counter_dot_depth',
                'cone_counter_dot_base_diameter',
                'cone_counter_dot_height',
                'cone_counter_dot_flat_hat',
                // use_bowl_recess handled via radios
                'rounded_dot_base_diameter',
                'rounded_dot_cylinder_height',
                'rounded_dot_base_height',
                'rounded_dot_dome_diameter',
                'rounded_dot_dome_height',
                'grid_columns',
                'grid_rows',
                'cell_spacing',
                'line_spacing',
                'dot_spacing',
                'card_width',
                'card_height',
                'card_thickness',
                'braille_x_adjust',
                'braille_y_adjust',
                // Custom: indicator shapes toggle changes available cells view
                'indicator_shapes'
            ];

            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        if (inputId === 'indicator_shapes') {
                            updateGridColumnsForPlateType(true);
                        }
                    });
                }
            });

            // Cylinder parameter inputs
            const cylinderInputs = [
                'cylinder_diameter_mm',
                'cylinder_height_mm',
                'cylinder_polygonal_cutout_radius_mm',
                'cylinder_polygonal_cutout_sides',
                'seam_offset_deg'
            ];

            cylinderInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        checkCylinderOverflow();
                    });
                }
            });
        }

        // Function to show/hide cylinder settings based on shape selection
        function updateShapeSettings() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement) {
                console.warn('No shape type selected');
                return;
            }
            const shapeType = shapeTypeElement.value;
            const cylinderSettings = document.querySelector('.grade-selection:has(#cylinder_diameter_mm)');

            // Always show cylinder dimensions in expert mode
            if (cylinderSettings) {
                cylinderSettings.style.display = 'block';
            }
            // Recess controls always visible; toggle sub-groups by chosen recess
            const recessSel = document.getElementById('recess-shape-selection');
            const recessValInit = document.querySelector('input[name="recess_shape"]:checked')?.value || '1';
            const isBowl = recessValInit === '1';
            const isCone = recessValInit === '2';
            if (recessSel) recessSel.style.display = '';
            const bowlGroup = document.getElementById('bowl_dimensions_group');
            const hemiGroup = document.getElementById('hemisphere_dimensions_group');
            const coneGroup = document.getElementById('cone_dimensions_group');
            if (bowlGroup) bowlGroup.style.display = '';
            if (hemiGroup) hemiGroup.style.display = 'none';
            if (coneGroup) coneGroup.style.display = '';

            // Initialize cylinder height with current card height when cylinder is selected
            if (shapeType === 'cylinder') {
                const cardHeight = document.getElementById('card_height').value;
                const cylinderHeightInput = document.getElementById('cylinder_height_mm');
                if (cylinderHeightInput) {
                    cylinderHeightInput.value = cardHeight;
                }
                checkCylinderOverflow();
            }
        }

        // Function to check cylinder text overflow
        function checkCylinderOverflow() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement || shapeTypeElement.value !== 'cylinder') return;
            const shapeType = shapeTypeElement.value;

            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const dotSpacing = parseFloat(document.getElementById('dot_spacing').value) || 2.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;

            // Calculate how many cells fit around circumference
            // cellSpacing is the center-to-center distance between cells
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);

            // Calculate how many rows fit on cylinder
            const rowsOnCylinder = Math.floor(height / lineSpacing);

            // Get total cells needed from text
            const lines = getDynamicLineValues();
            let totalCellsNeeded = 0;
            lines.forEach(line => {
                if (line.trim()) {
                    totalCellsNeeded += line.trim().length;
                }
            });

            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;

            const warningDiv = document.getElementById('cylinder-overflow-warning');
            const warningMessage = document.getElementById('cylinder-overflow-message');

            if (totalCellsNeeded > totalCellsAvailable) {
                warningMessage.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        }

        // Function to create dynamic line inputs based on grid_rows value
        function createDynamicLineInputs(numLines) {
            const container = document.getElementById('dynamic-line-inputs');
            container.innerHTML = ''; // Clear existing inputs

            for (let i = 1; i <= numLines; i++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'line-input';
                lineDiv.innerHTML = `
                    <div class="line-translation-row">
                        <label for="line_lang_${i}" class="line-label">Line ${i} Translation</label>
                        <select id="line_lang_${i}" name="line_lang_${i}" class="language-select line-language-select" aria-describedby="line${i}-lang-help"></select>
                        <span id="line${i}-lang-help" class="sr-only">Select translation language for line ${i}</span>
                    </div>
                    <div class="line-text-row">
                        <label for="line${i}" class="line-label">Line ${i}</label>
                        <input type="text" id="line${i}" name="line${i}" placeholder="Enter English text here..." maxlength="50" aria-describedby="line${i}-help">
                        <span id="line${i}-help" class="sr-only">Maximum 50 characters for line ${i}</span>
                    </div>
                `;
                container.appendChild(lineDiv);
            }

            // Populate per-line language selects with available options
            syncLineLanguageSelects();

            // Re-add event listeners for the new inputs
            addInputChangeListeners();
        }

        // Populate all per-line language selects from the master language-table options
        function syncLineLanguageSelects() {
            const master = document.getElementById('language-table');
            if (!master) return;
            const optionsHTML = master.innerHTML;
            const masterValue = master.value;
            document.querySelectorAll('.line-language-select').forEach(sel => {
                const previous = sel.value;
                sel.innerHTML = optionsHTML;
                // Prefer keeping prior choice; otherwise prefer English UEB Grade 1; otherwise fallback to master
                const hasPrev = previous && Array.from(sel.options).some(o => o.value === previous);
                const desiredDefault = 'en-ueb-g1.ctb';
                const hasDesired = Array.from(sel.options).some(o => o.value === desiredDefault);
                sel.value = hasPrev ? previous : (hasDesired ? desiredDefault : masterValue);
            });
        }

        // Function to collect all dynamic line values
        function getDynamicLineValues() {
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            const lines = [];
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                lines.push(input ? input.value : '');
            }
            return lines;
        }

        // When in auto mode, show overall overflow for cylinders too
        const cylinderOverflowDiv = document.getElementById('cylinder-overflow-warning');
        const cylinderOverflowMsg = document.getElementById('cylinder-overflow-message');
        const originalCheckCylinderOverflow = checkCylinderOverflow;
        checkCylinderOverflow = function() {
            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            if (placementMode === 'manual') {
                return originalCheckCylinderOverflow();
            }
            // Auto mode: compute based on auto text
            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);
            const rowsOnCylinder = Math.floor(height / lineSpacing);
            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;
            const src = (document.getElementById('auto-text')?.value || '').trim();
            if (!src) {
                cylinderOverflowDiv.style.display = 'none';
                return;
            }
            // Translate then compare
            translateWithLiblouis(src, 'g2', document.getElementById('language-table')?.value || 'en-ueb-g1.ctb')
                .then(braille => {
                    const totalCellsNeeded = braille.length;
                    if (totalCellsNeeded > totalCellsAvailable) {
                        cylinderOverflowMsg.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                        cylinderOverflowDiv.style.display = 'block';
                    } else {
                        cylinderOverflowDiv.style.display = 'none';
                    }
                })
                .catch(() => {
                    // Ignore
                });
        };

        // Function to add listener for grid_rows changes
        function addGridRowsListener() {
            const gridRowsInput = document.getElementById('grid_rows');
            if (gridRowsInput) {
                gridRowsInput.addEventListener('input', () => {
                    const numLines = parseInt(gridRowsInput.value) || 4;
                    // Enforce only a minimum of 1 line; no artificial upper bound
                    const safeLines = Math.max(1, numLines);
                    if (safeLines !== numLines) {
                        gridRowsInput.value = safeLines;
                    }
                    createDynamicLineInputs(safeLines);
                    resetToGenerateState();
                });
            }
        }

        // Initialize dynamic line inputs and listeners (force default 4 on first load)
        const gridRowsEl = document.getElementById('grid_rows');
        if (gridRowsEl) gridRowsEl.value = '4';
        createDynamicLineInputs(4);
        addInputChangeListeners();
        addGridRowsListener();

        // Placement mode logic
        const placementRadios = document.querySelectorAll('input[name="placement_mode"]');
        const autoContainer = document.getElementById('auto-input-container');
        const dynamicContainer = document.getElementById('dynamic-line-inputs');
        const autoText = document.getElementById('auto-text');
        const autoWarning = document.getElementById('auto-overflow-warning');
        const autoWarningMsg = document.getElementById('auto-overflow-message');

        function isIndicatorsOn() {
            return document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';
        }

        function getAvailableColumns() {
            const gridColumnsValue = parseInt(document.getElementById('grid_columns').value) || 15;
            // The UI dial shows usable text cells; use it directly for wrapping
            return gridColumnsValue;
        }

        function getTotalCellsAvailable() {
            const rows = parseInt(document.getElementById('grid_rows').value) || 4;
            const cols = getAvailableColumns();
            return rows * cols;
        }

        // BANA-compliant-ish auto wrapping for braille rows
        // Policy:
        // - Prefer not to divide words across lines
        // - Hyphenated words may break after a hyphen (hyphen remains at end of line)
        // - If a single non-hyphenated word exceeds the row width in braille cells,
        //   we attempt a simple syllable-like split; if none found, we warn and abort
        async function banaAutoWrap(src, cols, rows, tableName) {
            const warnings = [];
            const textLines = [];
            const brailleLines = [];

            const normalizeSpaces = (s) => s.replace(/\s+/g, ' ').trim();
            const isHyphenChar = (ch) => /[-\u2010\u2011\u2012\u2013\u2014\u2212]/.test(ch);
            const isEmailBreakChar = (ch) => ch === '@' || ch === '.';

            // Preferred in-word break positions (rightmost-first) for overlong tokens
            // - After hyphen-like chars
            // - After '@' or '.' (email/URLs)
            function findPreferredBreakPositions(word) {
                const positions = [];
                for (let i = 0; i < word.length; i++) {
                    const ch = word[i];
                    if (isHyphenChar(ch) || isEmailBreakChar(ch)) {
                        // break AFTER this char
                        if (i + 1 < word.length) positions.push(i);
                    }
                }
                return positions;
            }

            // Find potential syllable break indices using a simple vowel-based heuristic.
            // This is a fallback when no hyphen is present; not perfect, but avoids arbitrary splits.
            function findHeuristicSyllableBreaks(word) {
                const breaks = [];
                const vowels = /[aeiouyAEIOUY]/;
                for (let i = 1; i < word.length - 1; i++) {
                    const prev = word[i - 1];
                    const cur = word[i];
                    const next = word[i + 1];
                    if (vowels.test(prev) && !vowels.test(cur)) {
                        // Vowel  consonant boundary; prefer breaking here if needed
                        breaks.push(i);
                    } else if (vowels.test(cur) && !vowels.test(next)) {
                        // After a vowel when next is consonant
                        breaks.push(i + 1);
                    }
                }
                // Deduplicate and sort ascending
                return Array.from(new Set(breaks)).filter(b => b > 0 && b < word.length).sort((a,b)=>a-b);
            }

            async function translateLen(text) {
                const b = await translateWithLiblouis(text, 'g2', tableName);
                return b.length;
            }

            async function translateText(text) {
                return await translateWithLiblouis(text, 'g2', tableName);
            }

            let remaining = normalizeSpaces(src);
            if (!remaining) {
                // Return empty lines matching requested rows
                for (let r = 0; r < rows; r++) { textLines.push(''); brailleLines.push(''); }
                return { textLines, brailleLines, warnings };
            }

            const words = remaining.split(' ');
            let currentText = '';
            let currentBraille = '';

            // Helper to finalize current line
            async function pushCurrent() {
                const text = currentText.trim();
                const braille = text ? await translateText(text) : '';
                textLines.push(text);
                brailleLines.push(braille);
                currentText = '';
                currentBraille = '';
            }

            // Process each word greedily with lookahead via translation
            let i = 0;
            while (i < words.length && textLines.length < rows) {
                let word = words[i];
                if (!word) { i++; continue; }

                // Try to append word to current line (with a space if needed)
                const candidate = currentText ? `${currentText} ${word}` : word;
                const candidateBrailleLen = await translateLen(candidate);
                if (candidateBrailleLen <= cols) {
                    currentText = candidate;
                    currentBraille = null; // invalidate cache
                    i++;
                    continue;
                }

                // Would overflow. If current line has content, finalize it and retry word on next line
                if (currentText) {
                    await pushCurrent();
                    continue; // Retry same word on new line
                }

                // Single word longer than a line. Try preferred break opportunities first.
                const pref = findPreferredBreakPositions(word);
                let didSplitPreferred = false;
                for (let k = pref.length - 1; k >= 0; k--) {
                    const pos = pref[k];
                    const head = word.slice(0, pos + 1); // include break char at end of line
                    const headLen = await translateLen(head);
                    if (headLen <= cols) {
                        currentText = head;
                        await pushCurrent();
                        // Remainder becomes current word for next iteration
                        const tail = word.slice(pos + 1);
                        words[i] = tail || '';
                        if (!words[i]) { i++; }
                        didSplitPreferred = true;
                        break;
                    }
                }
                if (didSplitPreferred) {
                    continue; // continue outer while loop on possibly updated words[i]
                }

                // Try heuristic syllable-like breaks (do NOT insert a hyphen)
                const syllableBreaks = findHeuristicSyllableBreaks(word);
                if (syllableBreaks.length > 0) {
                    // Choose the largest prefix that fits
                    let chosen = -1;
                    for (const b of syllableBreaks) {
                        const head = word.slice(0, b);
                        const headLen = await translateLen(head);
                        if (headLen <= cols) chosen = b; else break;
                    }
                    if (chosen > 0) {
                        const head = word.slice(0, chosen);
                        currentText = head;
                        await pushCurrent();
                        const tail = word.slice(chosen);
                        words[i] = tail || '';
                        if (!words[i]) { i++; }
                        continue;
                    }
                }

                // Monosyllabic or no safe split found: cannot divide per BANA
                const wordBrailleLen = await translateLen(word);
                warnings.push(`Word "${word}" requires ${wordBrailleLen} cells but only ${cols} fit per row. It cannot be divided per BANA; increase columns/rows or use Manual Placement.`);
                return { error: true, warnings };
            }

            // Push the last line if any and if we still have space for lines
            if (currentText && textLines.length < rows) {
                await pushCurrent();
            }

            // If content remains beyond rows, warn
            if (i < words.length) {
                warnings.push('Text exceeds available rows after word-aware wrapping; extra content was not placed.');
            }

            // Ensure we return exactly "rows" lines for downstream consumers
            while (textLines.length < rows) { textLines.push(''); brailleLines.push(''); }
            if (textLines.length > rows) {
                textLines.length = rows; brailleLines.length = rows;
            }

            return { textLines, brailleLines, warnings };
        }

        function updatePlacementUI() {
            const mode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            if (mode === 'auto') {
                autoContainer.style.display = '';
                dynamicContainer.style.display = 'none';
            } else {
                autoContainer.style.display = 'none';
                dynamicContainer.style.display = '';
                // Ensure per-line language selects are populated when switching to manual
                syncLineLanguageSelects();
            }
            resetToGenerateState();
        }

        placementRadios.forEach(r => r.addEventListener('change', () => {
            updatePlacementUI();
        }));

        // Update UI on relevant changes to show/compute warnings
        ['grid_rows','grid_columns','cell_spacing','line_spacing','cylinder_diameter_mm','cylinder_height_mm','indicator_shapes']
            .forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        if (document.querySelector('input[name="placement_mode"]:checked')?.value === 'auto') {
                            computeAutoOverflow();
                        }
                    });
                }
            });

        async function computeAutoOverflow() {
            autoWarning.style.display = 'none';
            autoWarningMsg.textContent = '';
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect?.value || 'en-ueb-g1.ctb';
            const src = (autoText?.value || '').trim();
            if (!src) return;
            try {
                const braille = await translateWithLiblouis(src, 'g2', tableName);
                const totalCellsNeeded = braille.length;
                const totalCellsAvailable = getTotalCellsAvailable();
                if (totalCellsNeeded > totalCellsAvailable) {
                    const over = totalCellsNeeded - totalCellsAvailable;
                    autoWarningMsg.textContent = `Your text exceeds the number of available braille cells by ${over} cells.`;
                    autoWarning.style.display = 'block';
                }
            } catch (e) {
                // Ignore preview warning if translation not available
            }
        }

        if (autoText) {
            autoText.addEventListener('input', () => {
                resetToGenerateState();
                computeAutoOverflow();
            });
        }

        // Initialize placement UI
        updatePlacementUI();

        // Persistence: save and restore user settings
        function persistValue(key, value) {
            try { localStorage.setItem(key, value); } catch (e) {}
        }
        function readPersisted(key) {
            try { return localStorage.getItem(key); } catch (e) { return null; }
        }
        function clearAllPersistence() {
            const keys = [
                'braille_prefs_language_table',
                'braille_prefs_plate_type',
                'braille_prefs_shape_type',
                'braille_prefs_dot_shape',
                'braille_prefs_combined_shape',
                'braille_prefs_placement_mode',
                'braille_prefs_indicator_shapes',
                'braille_prefs_expert_visible',
                'braille_prefs_grid_columns',
                'braille_prefs_grid_rows',
                'braille_prefs_cell_spacing',
                'braille_prefs_line_spacing',
                'braille_prefs_dot_spacing',
                'braille_prefs_card_width',
                'braille_prefs_card_height',
                'braille_prefs_card_thickness',
                'braille_prefs_braille_x_adjust',
                'braille_prefs_braille_y_adjust',
                'braille_prefs_emboss_dot_base_diameter',
                'braille_prefs_emboss_dot_height',
                'braille_prefs_emboss_dot_flat_hat',
                'braille_prefs_hemi_counter_dot_base_diameter',
                'braille_prefs_bowl_counter_dot_base_diameter',
                'braille_prefs_counter_dot_depth',
                'braille_prefs_use_bowl_recess', // legacy
                'braille_prefs_recess_shape',
                'braille_prefs_cone_counter_dot_base_diameter',
                'braille_prefs_cone_counter_dot_height',
                'braille_prefs_cone_counter_dot_flat_hat',
                'braille_prefs_rounded_dot_base_diameter',
                'braille_prefs_rounded_dot_base_height',
                'braille_prefs_rounded_dot_dome_diameter',
                'braille_prefs_rounded_dot_dome_height',
                'braille_prefs_cylinder_diameter_mm',
                'braille_prefs_cylinder_height_mm',
                'braille_prefs_cylinder_polygonal_cutout_radius_mm',
                'braille_prefs_cylinder_polygonal_cutout_sides',
                'braille_prefs_seam_offset_deg'
            ];
            keys.forEach(k => { try { localStorage.removeItem(k); } catch (e) {} });
        }

        function applyPersistedSettings() {
            // Placement mode (auto/manual)
            const savedPlacement = readPersisted('braille_prefs_placement_mode');
            if (savedPlacement === 'auto' || savedPlacement === 'manual') {
                const radio = document.querySelector(`input[name="placement_mode"][value="${savedPlacement}"]`);
                if (radio) radio.checked = true;
            }
            // Plate type
            const savedPlate = readPersisted('braille_prefs_plate_type');
            if (savedPlate === 'positive' || savedPlate === 'negative') {
                const radio = document.querySelector(`input[name="plate_type"][value="${savedPlate}"]`);
                if (radio) radio.checked = true;
            }
            // Indicator shapes (on/off)
            const savedIndicator = readPersisted('braille_prefs_indicator_shapes');
            if (savedIndicator === '1' || savedIndicator === '0') {
                const radio = document.querySelector(`input[name="indicator_shapes"][value="${savedIndicator}"]`);
                if (radio) radio.checked = true;
            }
            // Shape type
            const savedShape = readPersisted('braille_prefs_shape_type');
            if (savedShape === 'card' || savedShape === 'cylinder') {
                const radio = document.querySelector(`input[name="shape_type"][value="${savedShape}"]`);
                if (radio) radio.checked = true;
            }
            // Dot shape
            const savedDot = readPersisted('braille_prefs_dot_shape');
            if (savedDot === 'cone' || savedDot === 'rounded') {
                const radio = document.querySelector(`input[name="dot_shape"][value="${savedDot}"]`);
                if (radio) radio.checked = true;
            }
            // Combined shape - initialize based on saved dot shape or default to rounded
            const savedCombined = readPersisted('braille_prefs_combined_shape') || savedDot || 'rounded';
            if (savedCombined === 'cone' || savedCombined === 'rounded') {
                const radio = document.querySelector(`input[name="combined_shape"][value="${savedCombined}"]`);
                if (radio) radio.checked = true;

                console.log('Initializing combined shape to:', savedCombined);

                // Sync individual values for backend compatibility
                const dotShapeRadios = document.querySelectorAll('input[name="dot_shape"]');
                const recessShapeRadios = document.querySelectorAll('input[name="recess_shape"]');

                if (savedCombined === 'rounded') {
                    dotShapeRadios.forEach(r => { if (r.value === 'rounded') r.checked = true; });
                    recessShapeRadios.forEach(r => { if (r.value === '1') r.checked = true; }); // Bowl
                    console.log('Initialized to rounded - dot_shape: rounded, recess_shape: 1');
                } else if (savedCombined === 'cone') {
                    dotShapeRadios.forEach(r => { if (r.value === 'cone') r.checked = true; });
                    recessShapeRadios.forEach(r => { if (r.value === '2') r.checked = true; }); // Cone
                    // Sync emboss cone params to counter cone params on initialization
                    syncEmbossToCounterConeParams();
                    console.log('Initialized to cone - dot_shape: cone, recess_shape: 2');
                }
            }
            // Expert visibility
            const savedExpert = readPersisted('braille_prefs_expert_visible');
            if (savedExpert === 'true' || savedExpert === 'false') {
                const visible = savedExpert === 'true';
                expertSettings.style.display = visible ? 'block' : 'none';
                expertToggleText.textContent = visible ? 'Hide Expert Mode' : 'Show Expert Mode';
                expertToggleIcon.textContent = visible ? '' : '';
                expertToggleBtn.classList.toggle('active', visible);
            }
            // Numeric/text inputs
            const map = [
                ['grid_rows','braille_prefs_grid_rows'],
                ['cell_spacing','braille_prefs_cell_spacing'],
                ['line_spacing','braille_prefs_line_spacing'],
                ['dot_spacing','braille_prefs_dot_spacing'],
                ['card_width','braille_prefs_card_width'],
                ['card_height','braille_prefs_card_height'],
                ['card_thickness','braille_prefs_card_thickness'],
                ['braille_x_adjust','braille_prefs_braille_x_adjust'],
                ['braille_y_adjust','braille_prefs_braille_y_adjust'],
                ['emboss_dot_base_diameter','braille_prefs_emboss_dot_base_diameter'],
                ['emboss_dot_height','braille_prefs_emboss_dot_height'],
                ['emboss_dot_flat_hat','braille_prefs_emboss_dot_flat_hat'],
                ['hemi_counter_dot_base_diameter','braille_prefs_hemi_counter_dot_base_diameter'],
                ['bowl_counter_dot_base_diameter','braille_prefs_bowl_counter_dot_base_diameter'],
                ['counter_dot_depth','braille_prefs_counter_dot_depth'],
                ['cone_counter_dot_base_diameter','braille_prefs_cone_counter_dot_base_diameter'],
                ['cone_counter_dot_height','braille_prefs_cone_counter_dot_height'],
                ['cone_counter_dot_flat_hat','braille_prefs_cone_counter_dot_flat_hat'],
                ['recess_shape','braille_prefs_recess_shape'],
                ['rounded_dot_base_diameter','braille_prefs_rounded_dot_base_diameter'],
                ['rounded_dot_base_height','braille_prefs_rounded_dot_base_height'],
                ['rounded_dot_dome_diameter','braille_prefs_rounded_dot_dome_diameter'],
                ['rounded_dot_dome_height','braille_prefs_rounded_dot_dome_height'],
                ['cylinder_diameter_mm','braille_prefs_cylinder_diameter_mm'],
                ['cylinder_height_mm','braille_prefs_cylinder_height_mm'],
                ['cylinder_polygonal_cutout_radius_mm','braille_prefs_cylinder_polygonal_cutout_radius_mm'],
                ['cylinder_polygonal_cutout_sides','braille_prefs_cylinder_polygonal_cutout_sides'],
                ['seam_offset_deg','braille_prefs_seam_offset_deg']
            ];
            map.forEach(([id,key]) => {
                const v = readPersisted(key);
                if (v !== null && v !== undefined) {
                    const el = document.getElementById(id);
                    if (el) el.value = v;
                }
            });
            // Restore recess shape selection (default to Bowl when no saved value)
            const savedRecessShape = readPersisted('braille_prefs_recess_shape');
            if (savedRecessShape === '0' || savedRecessShape === '1' || savedRecessShape === '2') {
                const r = document.querySelector(`input[name="recess_shape"][value="${savedRecessShape}"]`);
                if (r) r.checked = true;
            } else {
                const r = document.querySelector('input[name="recess_shape"][value="1"]');
                if (r) r.checked = true;
            }
            // grid_columns handled last to avoid preserve conversion
            const savedCols = readPersisted('braille_prefs_grid_columns');
            updateShapeSettings();
            updateGridColumnsForPlateType(true);
            if (savedCols !== null && savedCols !== undefined) {
                const gridColsEl = document.getElementById('grid_columns');
                if (gridColsEl) gridColsEl.value = savedCols;
            }
            // Recreate dynamic line inputs in case grid_rows changed
            const numLines = parseInt(document.getElementById('grid_rows').value) || 4;
            createDynamicLineInputs(numLines);
        }

        function wirePersistenceListeners() {
            // Placement mode (auto/manual)
            document.querySelectorAll('input[name="placement_mode"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_placement_mode', document.querySelector('input[name="placement_mode"]:checked').value));
            });
            // Plate type
            document.querySelectorAll('input[name="plate_type"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_plate_type', document.querySelector('input[name="plate_type"]:checked').value));
            });
            // Indicator shapes (on/off)
            document.querySelectorAll('input[name="indicator_shapes"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_indicator_shapes', document.querySelector('input[name="indicator_shapes"]:checked').value));
            });
            // Shape type
            document.querySelectorAll('input[name="shape_type"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_shape_type', document.querySelector('input[name="shape_type"]:checked').value));
            });
            // Dot shape (now handled by combined shape)
            document.querySelectorAll('input[name="dot_shape"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_dot_shape', document.querySelector('input[name="dot_shape"]:checked').value));
            });
            // Combined shape (new primary control)
            document.querySelectorAll('input[name="combined_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    const val = document.querySelector('input[name="combined_shape"]:checked')?.value || 'rounded';
                    persistValue('braille_prefs_combined_shape', val);
                    // Also persist the individual values for backend compatibility
                    persistValue('braille_prefs_dot_shape', val);
                    persistValue('braille_prefs_recess_shape', val === 'rounded' ? '1' : '2');
                });
            });
            // Expert visibility
            expertToggleBtn.addEventListener('click', () => {
                const isVisible = expertSettings.style.display !== 'none';
                // After toggle above, visibility will invert; persist the next state
                const nextVisible = !isVisible;
                persistValue('braille_prefs_expert_visible', String(nextVisible));
            });
            // Numeric/text inputs
            const map = [
                ['grid_columns','braille_prefs_grid_columns'],
                ['grid_rows','braille_prefs_grid_rows'],
                ['cell_spacing','braille_prefs_cell_spacing'],
                ['line_spacing','braille_prefs_line_spacing'],
                ['dot_spacing','braille_prefs_dot_spacing'],
                ['card_width','braille_prefs_card_width'],
                ['card_height','braille_prefs_card_height'],
                ['card_thickness','braille_prefs_card_thickness'],
                ['braille_x_adjust','braille_prefs_braille_x_adjust'],
                ['braille_y_adjust','braille_prefs_braille_y_adjust'],
                ['emboss_dot_base_diameter','braille_prefs_emboss_dot_base_diameter'],
                ['emboss_dot_height','braille_prefs_emboss_dot_height'],
                ['emboss_dot_flat_hat','braille_prefs_emboss_dot_flat_hat'],
                ['hemi_counter_dot_base_diameter','braille_prefs_hemi_counter_dot_base_diameter'],
                ['bowl_counter_dot_base_diameter','braille_prefs_bowl_counter_dot_base_diameter'],
                ['counter_dot_depth','braille_prefs_counter_dot_depth'],
                ['cone_counter_dot_base_diameter','braille_prefs_cone_counter_dot_base_diameter'],
                ['cone_counter_dot_height','braille_prefs_cone_counter_dot_height'],
                ['cone_counter_dot_flat_hat','braille_prefs_cone_counter_dot_flat_hat'],
                ['recess_shape','braille_prefs_recess_shape'],
                ['rounded_dot_base_diameter','braille_prefs_rounded_dot_base_diameter'],
                ['rounded_dot_base_height','braille_prefs_rounded_dot_base_height'],
                ['rounded_dot_dome_diameter','braille_prefs_rounded_dot_dome_diameter'],
                ['rounded_dot_dome_height','braille_prefs_rounded_dot_dome_height'],
                ['cylinder_diameter_mm','braille_prefs_cylinder_diameter_mm'],
                ['cylinder_height_mm','braille_prefs_cylinder_height_mm'],
                ['cylinder_polygonal_cutout_radius_mm','braille_prefs_cylinder_polygonal_cutout_radius_mm'],
                ['cylinder_polygonal_cutout_sides','braille_prefs_cylinder_polygonal_cutout_sides'],
                ['seam_offset_deg','braille_prefs_seam_offset_deg']
            ];
            map.forEach(([id,key]) => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => persistValue(key, el.value));
                }
            });
            // Recess shape radio persistence (now handled by combined shape)
            document.querySelectorAll('input[name="recess_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    const val = document.querySelector('input[name="recess_shape"]:checked')?.value || '1';
                    persistValue('braille_prefs_recess_shape', val);
                });
            });
        }

        // On load, restore persisted settings, then wire listeners
        try { applyPersistedSettings(); } catch (e) {}
        try { wirePersistenceListeners(); } catch (e) {}
        // After restoring persisted settings, update placement UI to reflect restored mode
        try { updatePlacementUI(); } catch (e) {}

        // Reset to defaults button
        const resetBtn = document.getElementById('reset-defaults-btn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                clearAllPersistence();
                // Reset selects to their default option values
                const selectEls = Array.from(document.querySelectorAll('select'));
                selectEls.forEach(sel => { sel.value = sel.options[0]?.value || sel.defaultValue; });
                // Ensure language resets to UEB Grade 1
                try {
                    const langSelect = document.getElementById('language-table');
                    if (langSelect) {
                        langSelect.value = 'en-ueb-g1.ctb';
                        try { localStorage.setItem('braille_prefs_language_table', 'en-ueb-g1.ctb'); } catch (e) {}
                    }
                } catch (e) {}
                // Reset radio groups to defaultChecked
                const radioGroups = new Map();
                document.querySelectorAll('input[type="radio"]').forEach(r => {
                    if (!radioGroups.has(r.name)) radioGroups.set(r.name, []);
                    radioGroups.get(r.name).push(r);
                });
                radioGroups.forEach(group => {
                    const def = group.find(r => r.defaultChecked);
                    if (def) def.checked = true;
                });
                // Reset all inputs to their defaultValue
                document.querySelectorAll('input[type="number"], input[type="text"]').forEach(inp => {
                    if (inp.defaultValue !== undefined) inp.value = inp.defaultValue;
                });
                // Expert visibility default (hidden)
                expertSettings.style.display = 'none';
                expertToggleText.textContent = 'Show Expert Mode';
                expertToggleIcon.textContent = '';
                expertToggleBtn.classList.remove('active');
                updateShapeSettings();
                updateGridColumnsForPlateType();
                checkCylinderOverflow();
                resetToGenerateState();

                // Inform the user to refresh the page to fully reset preview and state
                try {
                    errorText.textContent = 'Settings reset to defaults. Please refresh the page to fully reset and clear the preview.';
                    errorDiv.style.display = 'flex';
                    errorDiv.className = 'error-message info';
                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                        errorDiv.className = 'error-message';
                    }, 5000);
                } catch (e) { /* ignore */ }
            });
        }

        // Initialize shape settings to show/hide cylinder parameters correctly
        updateShapeSettings();

        expertToggleBtn.addEventListener('click', () => {
            const isVisible = expertSettings.style.display !== 'none';
            expertSettings.style.display = isVisible ? 'none' : 'block';
            expertToggleText.textContent = isVisible ? 'Show Expert Mode' : 'Hide Expert Mode';
            expertToggleIcon.textContent = isVisible ? '' : '';
            expertToggleBtn.classList.toggle('active', !isVisible);
        });

        // Dot shape radio buttons
        document.querySelectorAll('input[name="dot_shape"]').forEach(radio => {
            radio.addEventListener('change', function() {
                resetToGenerateState();
            });
        });

        // Removed redundant toggle-dot-shape button

        infoToggleBtn.addEventListener('click', () => {
            const isVisible = infoContent.style.display !== 'none';
            infoContent.style.display = isVisible ? 'none' : 'block';
                                        infoToggleText.textContent = isVisible ? 'More Info' : 'Hide Information';
            infoToggleIcon.textContent = isVisible ? '' : '';
            infoToggleBtn.classList.toggle('active', !isVisible);
        });

        // Wire Expert submenus (expand/collapse)
        (function initExpertSubmenus() {
            const submenuToggles = Array.from(document.querySelectorAll('.expert-submenu-toggle'));
            submenuToggles.forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const content = toggle.parentElement?.querySelector('.expert-submenu-content');
                    if (!content) return;
                    const isOpen = content.style.display !== 'none';
                    content.style.display = isOpen ? 'none' : 'block';
                    toggle.classList.toggle('active', !isOpen);
                    toggle.setAttribute('aria-expanded', String(!isOpen));
                    const icon = toggle.querySelector('.expert-submenu-icon');
                    if (icon) icon.textContent = isOpen ? '' : '';
                });
            });
        })();

        // Add real-time debugging for Expert Mode parametric dials
        const expertInputs = [
            'emboss_dot_base_diameter',
            'emboss_dot_height',
            'emboss_dot_flat_hat',
            'hemi_counter_dot_base_diameter',
            'bowl_counter_dot_base_diameter',
            'counter_dot_depth',
            'grid_columns',
            'grid_rows',
            'cell_spacing',
            'line_spacing',
            'dot_spacing',
            'card_width',
            'card_height',
            'card_thickness',
            'braille_x_adjust',
            'braille_y_adjust',
            'cylinder_diameter_mm',
            'cylinder_height_mm',
            'cylinder_polygonal_cutout_radius_mm',
            'cylinder_polygonal_cutout_sides',
            'seam_offset_deg'
        ];

        expertInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', (e) => {
                    log.debug(`Expert Mode Input Changed: ${inputId} = ${e.target.value}`);

                    // If grid_columns changed, update the label/note but preserve the value
                    if (inputId === 'grid_columns') {
                        updateGridColumnsForPlateType(true);
                    }
                });

                // Also log the initial values
                log.debug(`Initial value for ${inputId}: ${input.value}`);
            }
        });
        // Log initial recess shape radio value too
        (function logInitialRecessShape() {
            const v = document.querySelector('input[name="use_bowl_recess"]:checked')?.value;
            if (v !== undefined) {
                log.debug('Initial value for use_bowl_recess:', v);
            }
        })();

        // Function to get current Expert Mode values
        window.getCurrentExpertModeValues = function() {
            const values = {};
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    values[inputId] = input.value;
                }
            });
            return values;
        };

        // Convert a unicode braille string to computer shorthand tokens with brief indicators
        function brailleToComputerShorthand(brailleStr) {
            // Common UEB contractions and indicators
            const contractionMap = {
                '': 'ch',
                '': 'sh',
                '': 'th',
                '': 'wh',
                '': 'ed',
                '': 'er',
                '': 'ou',
                '': 'ow',
                '': 'ar',
                '': 'ing',
                '': 'en',
                '': 'in',
                '': 'st',
                '': 'the',
                '': 'and',
                '': 'of',
                '': 'for',
                '': 'with'
            };

            const indicatorMap = {
                '': '[Capital Symbol]',
                '': '[Number Symbol]'
            };

            const punctuationMap = {
                '': ',',
                '': ';',
                '': ':',
                '': '.',
                '': '!',
                '': '?',
                '': '-',
                '': '\''
            };

            const letterMap = {
                '':'a','':'b','':'c','':'d','':'e','':'f','':'g','':'h','':'i','':'j',
                '':'k','':'l','':'m','':'n','':'o','':'p','':'q','':'r','':'s','':'t',
                '':'u','':'v','':'w','':'x','':'y','':'z'
            };

            const digitMap = {
                '':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'
            };

            let result = '';
            let numericMode = false;
            let pendingWordGap = false;

            for (const ch of brailleStr) {
                if (ch === ' ') {
                    // Word boundary
                    numericMode = false;
                    pendingWordGap = true;
                    continue;
                }

                if (indicatorMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += indicatorMap[ch];
                    pendingWordGap = false;
                    if (ch === '') numericMode = true;
                    continue;
                }

                if (contractionMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += `[${contractionMap[ch]}]`;
                    pendingWordGap = false;
                    // contractions end numeric mode
                    numericMode = false;
                    continue;
                }

                if (numericMode && digitMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += digitMap[ch];
                    pendingWordGap = false;
                    continue;
                }

                if (letterMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += letterMap[ch];
                    pendingWordGap = false;
                    // letters in numeric mode that are not digits will end numeric mode
                    numericMode = false;
                    continue;
                }

                if (punctuationMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += punctuationMap[ch];
                    pendingWordGap = false;
                    numericMode = false;
                    continue;
                }

                // Fallback: show the braille cell itself
                if (result.length > 0) {
                    result += pendingWordGap ? '  ' : ' ';
                }
                result += ch;
                pendingWordGap = false;
                numericMode = false;
            }

            return result;
        }

        // Preview braille translation using real liblouis (supports manual and auto placement)
        previewBrailleBtn.addEventListener('click', async () => {
            // Reset button state when previewing (user is making changes)
            resetToGenerateState();

            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect.value;

            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            errorDiv.style.display = 'none';
            let previewHTML = '';

            if (placementMode === 'manual') {
                const lines = getDynamicLineValues();
                if (lines.every(line => !line.trim())) {
                    errorText.textContent = 'Please enter text in at least one line.';
                    errorDiv.style.display = 'flex';
                    return;
                }
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        try {
                            const perLineTable = (document.getElementById(`line_lang_${i+1}`)?.value) || tableName;
                            const braille = await translateWithLiblouis(lines[i].trim(), 'g2', perLineTable);
                            const shorthand = brailleToComputerShorthand(braille);
                            previewHTML += `<div class="preview-line-success">
                                <div><strong>Line ${i + 1}:</strong> "${lines[i].trim()}"  "${braille}"</div>
                                <div class="preview-subline">Computer shorthand: "${shorthand}"</div>
                            </div>`;
                        } catch (error) {
                            log.error('Translation failed for line', i + 1, ':', error);
                            previewHTML += `<div class="preview-line-error">
                                <strong>Line ${i + 1}:</strong> "${lines[i].trim()}"  Error: ${error.message}
                            </div>`;
                        }
                    }
                }
            } else {
                // Auto mode: BANA-aware word wrapping for preview
                const src = (document.getElementById('auto-text')?.value || '').trim();
                if (!src) {
                    errorText.textContent = 'Please enter text in the Auto Placement field.';
                    errorDiv.style.display = 'flex';
                    return;
                }
                try {
                    const shapeTypeEl = document.querySelector('input[name="shape_type"]:checked');
                    const shapeTypeVal = shapeTypeEl ? shapeTypeEl.value : 'card';
                    // Use unified available columns helper
                    const cols = getAvailableColumns();
                    const rows = parseInt(document.getElementById('grid_rows').value) || 4;
                    const wrap = await banaAutoWrap(src, cols, rows, tableName);
                    if (wrap.error) {
                        errorText.textContent = wrap.warnings && wrap.warnings.length ? wrap.warnings.join(' ') : 'Unable to wrap text per BANA rules.';
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        // Still show whatever lines we have (empty)
                    }
                    const linesForPreview = wrap.brailleLines || [];
                    for (let r = 0; r < rows; r++) {
                        const slice = linesForPreview[r] || '';
                        const shorthand = slice ? brailleToComputerShorthand(slice) : '';
                        previewHTML += `<div class="preview-line-success">
                            <div><strong>Row ${r + 1}:</strong> "${slice}"</div>
                            <div class="preview-subline">${shorthand ? `Computer shorthand: "${shorthand}"` : ''}</div>
                        </div>`;
                    }
                    if (wrap.warnings && wrap.warnings.length) {
                        errorText.textContent = wrap.warnings.join(' ');
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'grade-note';
                    }
                } catch (error) {
                    log.error('BANA wrap failed for auto text:', error);
                    previewHTML += `<div class="preview-line-error">
                        <strong>Auto Placement:</strong> Error: ${error.message}
                    </div>`;
                }
            }

            previewContent.innerHTML = previewHTML;
            braillePreview.style.display = 'block';
        });

        function init3D() {
            // Mobile-optimized renderer settings
            const isMobile = window.innerWidth <= 768;
            renderer = new THREE.WebGLRenderer({
                antialias: !isMobile, // Disable antialiasing on mobile for performance
                powerPreference: isMobile ? "low-power" : "high-performance"
            });
            const initW = viewer.clientWidth;
            const initH = viewer.clientHeight || 420;
            renderer.setSize(initW, initH, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
            // Preserve overlay children inside #viewer; only remove previous canvas if present
            const existingCanvas = viewer.querySelector('canvas');
            if (existingCanvas) viewer.removeChild(existingCanvas);
            viewer.appendChild(renderer.domElement);

            // Get theme-appropriate colors with proper fallbacks
            const styles = getComputedStyle(document.documentElement);
            const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
            const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
            const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
            const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
            const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(stlBackground);

            // Initialize camera using CAMERA_SETTINGS.CARD as default (cards are default shape)
            const defaultCam = CAMERA_SETTINGS.CARD;
            camera = new THREE.PerspectiveCamera(defaultCam.fov, initW / initH, defaultCam.near, defaultCam.far);
            camera.position.set(defaultCam.position.x, defaultCam.position.y, defaultCam.position.z);
            camera.up.set(defaultCam.up.x, defaultCam.up.y, defaultCam.up.z);
            camera.lookAt(defaultCam.target.x, defaultCam.target.y, defaultCam.target.z);

            // Add camera to scene so attached lights will work
            scene.add(camera);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(defaultCam.target.x, defaultCam.target.y, defaultCam.target.z);

            // Mobile-optimized controls
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = isMobile ? 0.5 : 1.0;
            controls.zoomSpeed = isMobile ? 0.8 : 1.2;
            controls.panSpeed = isMobile ? 0.5 : 0.8;

            // Touch-specific settings
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            controls.update();

            // Theme-appropriate lighting with intensity control
            const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);

            // Position the directional light for optimal detail visibility
            // Use conventional 3D modeling lighting angles
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'high-contrast') {
                // High contrast mode: conventional three-point lighting for better detail visibility
                // Key light: 45 horizontal, 30 vertical (right side) - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);

                // Fill light: 45 horizontal, 15 vertical (left side) for shadow softening - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                camera.add(fillLight);

                // Subtle back light for edge definition - camera-relative
                const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                backLight.position.set(0, 0.5, -0.866).normalize();
                camera.add(backLight);
            } else {
                // Standard lighting: conventional angle for optimal detail visibility
                // Key light: 45 horizontal, 30 vertical - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);

                // Add subtle fill light for standard modes too - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                camera.add(fillLight);
            }

            scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));

            // Handle window resize for mobile orientation changes
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            const targetW = viewer.clientWidth;
            const targetH = viewer.clientHeight || 420;
            camera.aspect = targetW / targetH;
            camera.updateProjectionMatrix();
            renderer.setSize(targetW, targetH, false);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        form.onsubmit = async (e) => {
            e.preventDefault();
            errorDiv.style.display = 'none';
            errorText.textContent = '';
            const errorSubtext = document.getElementById('error-subtext');
            if (errorSubtext) {
                errorSubtext.textContent = '';
                errorSubtext.style.display = 'none';
            }

            // Collect input depending on placement mode
            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            let lines = [];
            let originalLines = [];
            if (placementMode === 'manual') {
                lines = getDynamicLineValues();
                originalLines = [...lines];
            } else {
                const src = (document.getElementById('auto-text')?.value || '').trim();
                originalLines = [src];
                // We'll translate the whole text, then wrap to rows based on available cells
            }

            const plateTypeEl = document.querySelector('input[name="plate_type"]:checked');
            const plateType = plateTypeEl ? plateTypeEl.value : 'positive';
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect?.value || 'en-ueb-g1.ctb';

            // Translate text to braille only for positive plates
            let translatedLines = [];
            let perLineLanguageTables = [];
            let translationErrors = [];
            if (plateType === 'positive') {
                if (placementMode === 'manual') {
                    // Per-line translation
                    perLineLanguageTables = new Array(lines.length).fill(tableName);
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line) {
                            try {
                                const perLineTable = (document.getElementById(`line_lang_${i+1}`)?.value) || tableName;
                                perLineLanguageTables[i] = perLineTable;
                                log.debug(`Translating line ${i + 1}: '${line}' to braille using table: ${perLineTable}...`);
                                const brailleText = await translateWithLiblouis(line, 'g2', perLineTable);
                                log.debug(`Line ${i + 1} translated: '${line}'  '${brailleText}'`);
                                translatedLines.push(brailleText);
                            } catch (error) {
                                log.error(`Failed to translate line ${i + 1}:`, error);
                                translationErrors.push({ line: i + 1, text: line, error: error.toString() });
                                translatedLines.push('');
                            }
                        } else {
                            translatedLines.push('');
                        }
                    }
                } else {
                    // Auto mode: BANA-aware wrapping
                    const src = (document.getElementById('auto-text')?.value || '').trim();
                    if (!src) {
                        translatedLines = Array(parseInt(document.getElementById('grid_rows').value) || 4).fill('');
                    } else {
                        try {
                            const shapeTypeEl = document.querySelector('input[name="shape_type"]:checked');
                            const shapeTypeVal = shapeTypeEl ? shapeTypeEl.value : 'card';
                            const cols = getAvailableColumns();
                            const rows = parseInt(document.getElementById('grid_rows').value) || 4;
                            const wrap = await banaAutoWrap(src, cols, rows, tableName);
                            if (wrap.error) {
                                const msg = wrap.warnings && wrap.warnings.length ? wrap.warnings.join(' ') : 'Unable to wrap text per BANA rules.';
                                errorText.textContent = msg;
                                errorDiv.style.display = 'flex';
                                errorDiv.className = 'error-message';
                                // Stop submission
                                resetToGenerateState();
                                return;
                            }
                            translatedLines = wrap.brailleLines;
                            // Provide per-line language tables (single table for all lines in auto mode)
                            perLineLanguageTables = new Array(rows).fill(tableName);
                            // Update originalLines to reflect the per-line source segments
                            originalLines = wrap.textLines;
                            if (wrap.warnings && wrap.warnings.length) {
                                errorText.textContent = wrap.warnings.join(' ');
                                errorDiv.style.display = 'flex';
                                errorDiv.className = 'grade-note';
                            }
                        } catch (error) {
                            log.error('Failed to wrap auto text (BANA):', error);
                            translationErrors.push({ line: 1, text: src, error: error.toString() });
                            translatedLines = Array(parseInt(document.getElementById('grid_rows').value) || 4).fill('');
                        }
                    }
                }
                log.debug('Original lines:', lines);
                log.debug('Translated lines:', translatedLines);

                // Check if any translation errors occurred
                if (translationErrors.length > 0) {
                    let errorMessage = '<strong>Translation failed for the following lines:</strong><br><br>';
                    translationErrors.forEach(err => {
                        errorMessage += `Line ${err.line}: "${err.text}"<br>`;
                    });
                    errorMessage += '<br><strong>Please check your text and try again.</strong><br><br>';
                    errorMessage += 'Common issues include:<br>';
                    errorMessage += ' Special characters that cannot be translated<br>';
                    errorMessage += ' Text that is incompatible with the selected braille table<br>';
                    errorMessage += ' System errors during translation<br><br>';
                    errorMessage += '<em>The STL file was not generated to prevent producing incorrect braille.</em>';

                    errorText.innerHTML = errorMessage;  // Use innerHTML for HTML formatting
                    errorDiv.style.display = 'flex';
                    errorDiv.className = 'error-message';

                    // Re-enable button and reset to generate state
                    resetToGenerateState();
                    return;
                }
            } else {
                // Counter plates don't need text - just pass empty lines
                translatedLines = ['', '', '', ''];
                log.debug('Counter plate selected - no text translation needed');
            }
            const settings = {
                // Add 2 only if indicator shapes are ON; otherwise send exact cells
                grid_columns: (document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1')
                    ? String(parseInt(document.getElementById('grid_columns').value) + 2)
                    : String(parseInt(document.getElementById('grid_columns').value)),
                grid_rows: document.getElementById('grid_rows').value,
                cell_spacing: document.getElementById('cell_spacing').value,
                line_spacing: document.getElementById('line_spacing').value,
                dot_spacing: document.getElementById('dot_spacing').value,
                emboss_dot_base_diameter: document.getElementById('emboss_dot_base_diameter').value,
                emboss_dot_height: document.getElementById('emboss_dot_height').value,
                emboss_dot_flat_hat: document.getElementById('emboss_dot_flat_hat').value,
                // Back-compat: if backend expects offset, compute from difference
                // but we also send independent counter base diameter explicitly
                // Separate diameters per recess shape
                hemi_counter_dot_base_diameter: document.getElementById('hemi_counter_dot_base_diameter')?.value || '1.6',
                bowl_counter_dot_base_diameter: document.getElementById('bowl_counter_dot_base_diameter')?.value || '1.6',
                // Back-compat: provide unified base diameter reflecting current recess selection
                counter_dot_base_diameter: (() => {
                    const recessVal = document.querySelector('input[name="recess_shape"]:checked')?.value || '1';
                    if (recessVal === '1') return (document.getElementById('bowl_counter_dot_base_diameter')?.value || '1.6');
                    if (recessVal === '0') return (document.getElementById('hemi_counter_dot_base_diameter')?.value || '1.6');
                    return (document.getElementById('cone_counter_dot_base_diameter')?.value || '1.6');
                })(),
                counter_dot_depth: document.getElementById('counter_dot_depth')?.value || '0.6',
                use_bowl_recess: (document.querySelector('input[name="recess_shape"]:checked')?.value === '1') ? 1 : 0,
                recess_shape: parseInt(document.querySelector('input[name="recess_shape"]:checked')?.value || '1'),
                // Cone parameters
                cone_counter_dot_base_diameter: document.getElementById('cone_counter_dot_base_diameter')?.value || '1.6',
                cone_counter_dot_height: document.getElementById('cone_counter_dot_height')?.value || '0.8',
                cone_counter_dot_flat_hat: document.getElementById('cone_counter_dot_flat_hat')?.value || '0.4',
                card_width: document.getElementById('card_width').value,
                card_height: document.getElementById('card_height').value,
                card_thickness: document.getElementById('card_thickness').value,
                braille_x_adjust: document.getElementById('braille_x_adjust').value,
                braille_y_adjust: document.getElementById('braille_y_adjust').value,
                // Rounded dome settings (optional)
                use_rounded_dots: (document.querySelector('input[name="dot_shape"]:checked')?.value === 'rounded') ? 1 : 0,
                dot_shape: document.querySelector('input[name="dot_shape"]:checked')?.value || 'rounded',
                // Legacy fallbacks retained for backend compatibility
                rounded_dot_diameter: document.getElementById('rounded_dot_dome_diameter')?.value || '1.5',
                rounded_dot_height: document.getElementById('rounded_dot_dome_height')?.value || '0.6',
                // New explicit params
                rounded_dot_base_diameter: document.getElementById('rounded_dot_base_diameter')?.value || '2.0',
                rounded_dot_base_height: document.getElementById('rounded_dot_base_height')?.value || document.getElementById('rounded_dot_cylinder_height')?.value || '0.2',
                rounded_dot_cylinder_height: document.getElementById('rounded_dot_base_height')?.value || document.getElementById('rounded_dot_cylinder_height')?.value || '0.2',
                rounded_dot_dome_diameter: document.getElementById('rounded_dot_dome_diameter')?.value || '1.5',
                rounded_dot_dome_height: document.getElementById('rounded_dot_dome_height')?.value || '0.6',
                // New: indicator shapes toggle
                indicator_shapes: (document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1') ? 1 : 0
            };

            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Settings object keys:', Object.keys(settings));
            log.debug('Settings object values:', Object.values(settings));

            // Debug shape values specifically
            const currentDotShape = document.querySelector('input[name="dot_shape"]:checked')?.value;
            const currentRecessShape = document.querySelector('input[name="recess_shape"]:checked')?.value;
            const currentCombinedShape = document.querySelector('input[name="combined_shape"]:checked')?.value;
            log.debug('Shape values - combined:', currentCombinedShape, 'dot_shape:', currentDotShape, 'recess_shape:', currentRecessShape, 'use_rounded_dots:', settings.use_rounded_dots);
            // Rounded-dome inputs are always visible for embossing plate; no dynamic toggle

            // Check if at least one line has content (only for positive plates)
            const hasContent = placementMode === 'manual' ? lines.some(l => l && l.trim()) : ((originalLines[0] || '').trim().length > 0);
            if (plateType === 'positive' && !hasContent) {
                errorText.textContent = 'Please enter text in at least one line.';
                errorDiv.style.display = 'flex';
                return;
            }

            // Validate braille character limits AFTER translation
            const gridColumnsValue = parseInt(document.getElementById('grid_columns').value);
            const indicatorsOn = document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';
            if (plateType === 'positive') {
                const availableColumns = gridColumnsValue;
                // In auto mode, we already wrapped by row capacity; skip line-specific error.
                if (placementMode === 'manual') {
                    for (let i = 0; i < translatedLines.length; i++) {
                        const brailleLine = translatedLines[i];
                        if (brailleLine && brailleLine.length > availableColumns) {
                            const over = brailleLine.length - availableColumns;
                            errorText.textContent = `Line ${i + 1} exceeds ${availableColumns} available braille cells by ${over} cells after translation. Please shorten your text.`;
                            errorDiv.style.display = 'flex';
                            errorDiv.className = 'error-message';
                            return;
                        }
                    }
                }
            } else {
                // For counter plates, all grid columns are available
                for (let i = 0; i < translatedLines.length; i++) {
                    const brailleLine = translatedLines[i];
                    if (brailleLine && brailleLine.length > gridColumnsValue) {
                        const over = brailleLine.length - gridColumnsValue;
                        errorText.textContent = `Line ${i + 1} exceeds ${gridColumnsValue} braille cells by ${over} cells after translation. Please shorten your text.`;
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        return;
                    }
                }
            }

            // Show loading message
            errorText.textContent = plateType === 'positive' ? 'Translating text to braille...' : 'Generating counter plate...';
            errorDiv.style.display = 'flex';
            errorDiv.className = 'error-message info';

            // Get shape type and recess shape to determine if we need the long-wait warning
            const shapeTypeElGen = document.querySelector('input[name="shape_type"]:checked');
            const shapeType = shapeTypeElGen ? shapeTypeElGen.value : 'card';
            const recessShapeEl = document.querySelector('input[name="recess_shape"]:checked');
            const recessShape = recessShapeEl ? recessShapeEl.value : '1';
            const isConeRecess = recessShape === '2';

            // Show special warning for counter plate + cone recess (takes 1-2 minutes)
            if (plateType === 'negative' && isConeRecess) {
                errorSubtext.textContent = 'This may take 12 minutes. Leaving or refreshing this page will cancel the process.';
                errorSubtext.style.display = 'block';
            } else {
                errorSubtext.textContent = '';
                errorSubtext.style.display = 'none';
            }

            // Update button to show loading state
            actionBtn.disabled = true;
            actionBtn.textContent = 'Generating...';
            actionBtn.style.opacity = '0.7';
            let cylinderParams = {};

            if (shapeType === 'cylinder') {
                cylinderParams = {
                    diameter_mm: document.getElementById('cylinder_diameter_mm')?.value || '30.75',
                    height_mm: document.getElementById('cylinder_height_mm')?.value || '52',
                    polygonal_cutout_radius_mm: document.getElementById('cylinder_polygonal_cutout_radius_mm')?.value || '13',
                    polygonal_cutout_sides: document.getElementById('cylinder_polygonal_cutout_sides')?.value || '12',
                    seam_offset_deg: document.getElementById('seam_offset_deg')?.value || '355'
                };
            }

            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Shape Type:', shapeType);
            log.debug('Cylinder Params:', cylinderParams);

            // Build original_lines for indicators
            let originalForIndicators = null;
            if (placementMode === 'manual') {
                originalForIndicators = lines;
            } else {
                const srcAuto = (document.getElementById('auto-text')?.value || '').trim();
                const tokens = srcAuto.split(/\s+/).filter(Boolean);
                const rowsCount = parseInt(document.getElementById('grid_rows').value) || 4;
                // Derive per-row indicator from first alphanumeric of each token
                const indicators = tokens.map(tok => {
                    const m = tok.match(/[A-Za-z0-9]/);
                    return m ? m[0] : '';
                });
                // Map indicators to rows cyclically or truncated
                originalForIndicators = new Array(rowsCount).fill('');
                for (let r = 0; r < rowsCount; r++) {
                    originalForIndicators[r] = indicators[r] || '';
                }
            }

            // Try GET lookup first for negative plates to leverage CDN-cached 302
            if (plateType === 'negative') {
                try {
                    const lookupParams = new URLSearchParams();
                    lookupParams.set('shape_type', shapeType);
                    lookupParams.set('settings', JSON.stringify(settings));
                    lookupParams.set('format', 'json');
                    if (shapeType === 'cylinder') {
                        lookupParams.set('cylinder_params', JSON.stringify(cylinderParams));
                    }
                    const lookupRes = await fetch(`/lookup_stl?${lookupParams.toString()}`, { method: 'GET', headers: { 'Accept': 'application/json' } });
                    if (lookupRes.ok) {
                        const j = await lookupRes.json();
                        const blobUrl = j && j.url;
                        if (blobUrl) {
                            errorDiv.style.display = 'none';
                            // Directly proceed to preview/download using the blob URL
                            if (lastSTLUrl) URL.revokeObjectURL(lastSTLUrl);
                            lastSTLUrl = blobUrl; // external URL; no need to createObjectURL
                            // Update filename consistent with backend (counter plate)
                            const isBowlSel = document.querySelector('input[name="use_bowl_recess"]:checked')?.value === '1';
                            let baseStr = '0';
                            if (isBowlSel) {
                                baseStr = document.getElementById('bowl_counter_dot_base_diameter')?.value
                                    || document.getElementById('counter_dot_base_diameter')?.value
                                    || '0';
                            } else {
                                baseStr = document.getElementById('hemi_counter_dot_base_diameter')?.value
                                    || document.getElementById('counter_dot_base_diameter')?.value
                                    || '0';
                            }
                            const totalDiameter = parseFloat(baseStr) || 0;
                            lastGeneratedSTLUrl = lastSTLUrl;
                            lastGeneratedFilename = `braille_counter_plate_${totalDiameter}mm-${shapeType}.stl`;
                            loadSTL(lastSTLUrl);
                            actionBtn.disabled = false;
                            setToDownloadState();
                            return; // done via GET lookup
                        }
                    }
                } catch (e) {
                    // Fallback to POST if lookup fails
                }
            }

            const res = await fetch('/generate_braille_stl', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    lines: translatedLines,
                    original_lines: originalForIndicators,
                    placement_mode: placementMode,
                    grade: 'g2',
                    plate_type: plateType,
                    shape_type: shapeType,
                    cylinder_params: cylinderParams,
                    per_line_language_tables: perLineLanguageTables,
                    settings: settings
                })
            });

            // Hide loading message
            errorDiv.style.display = 'none';
            if (errorSubtext) {
                errorSubtext.textContent = '';
                errorSubtext.style.display = 'none';
            }

            if (!res.ok) {
                let msg = 'Error generating STL';
                try {
                    const data = await res.json();
                    if (data.error) msg = data.error;
                } catch (e) {
                    msg = `Server error: ${res.status} ${res.statusText}`;
                }
                errorText.textContent = msg;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message'; // Reset to error style
                // Re-enable button on error and reset to generate state
                resetToGenerateState();
                return;
            }


            try {
                // Create blob and URL for 3D preview
                const blob = await res.blob();
                if (lastSTLUrl) URL.revokeObjectURL(lastSTLUrl);
                lastSTLUrl = URL.createObjectURL(blob);

                // Generate filename on frontend to match backend logic
                const plateType = document.querySelector('input[name="plate_type"]:checked').value;
                const shapeType = document.querySelector('input[name="shape_type"]:checked').value;
                let filename = plateType === 'positive' ? 'braille_embossing_plate' : 'braille_counter_plate';

                if (plateType === 'positive') {
                    // Get the current lines from the form
                    const placementModeNow = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
                    let lines = [];
                    if (placementModeNow === 'manual') {
                        const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
                        for (let i = 1; i <= gridRows; i++) {
                            const input = document.getElementById(`line${i}`);
                            lines.push(input ? input.value : '');
                        }
                    } else {
                        lines = [document.getElementById('auto-text')?.value || ''];
                    }

                    // Find first non-empty line (prioritizing Line 1)
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            // Sanitize filename: remove special characters and limit length
                            let sanitized = lines[i].trim().substring(0, 30);
                            sanitized = sanitized.replace(/[^\w\s-]/g, '');
                            sanitized = sanitized.replace(/[-\s]+/g, '_').replace(/^_+|_+$/g, '');

                            if (sanitized) {
                                filename = `braille_embossing_plate_${sanitized}-${shapeType}`;
                                break;
                            }
                        }
                    }
                    // If no text was found, still append shape type
                    if (!filename.includes(shapeType)) {
                        filename = `braille_embossing_plate-${shapeType}`;
                    }
                } else {
                    // For counter plates, include actual counter base diameter in filename
                    const isBowlSel = document.querySelector('input[name="use_bowl_recess"]:checked')?.value === '1';
                    let baseStr = '0';
                    if (isBowlSel) {
                        baseStr = document.getElementById('bowl_counter_dot_base_diameter')?.value
                            || document.getElementById('counter_dot_base_diameter')?.value
                            || '0';
                    } else {
                        baseStr = document.getElementById('hemi_counter_dot_base_diameter')?.value
                            || document.getElementById('counter_dot_base_diameter')?.value
                            || '0';
                    }
                    const totalDiameter = parseFloat(baseStr) || 0;
                    filename = `braille_counter_plate_${totalDiameter}mm-${shapeType}`;
                }

                // Store the generated STL URL and filename for download
                lastGeneratedSTLUrl = lastSTLUrl;
                lastGeneratedFilename = `${filename}.stl`;
                loadSTL(lastSTLUrl);

                // Change button to download state after successful generation
                actionBtn.disabled = false;
                setToDownloadState();
            } catch (e) {
                errorText.textContent = 'Failed to process STL file: ' + e.message;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message'; // Reset to error style
                // Re-enable button on error and reset to generate state
                resetToGenerateState();
            }
        };



        function loadSTL(url) {
            init3D();
            const loader = new STLLoader();
            loader.load(url, function (geometry) {
                if (mesh) scene.remove(mesh);

                // Center the geometry first
                geometry.center();

                // Compute bounding box after centering to detect object type
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const width = bbox.max.x - bbox.min.x;
                const height = bbox.max.y - bbox.min.y;
                const depth = bbox.max.z - bbox.min.z;

                // Check if this is a cylinder
                const shapeType = document.querySelector('input[name="shape_type"]:checked')?.value;
                const isCylinder = shapeType === 'cylinder' || height > Math.max(width, depth) * 1.5;

                // Get theme-appropriate mesh color with proper fallback
                const styles = getComputedStyle(document.documentElement);
                const meshColorVar = styles.getPropertyValue('--stl-mesh-color').trim();
                const meshColor = meshColorVar || '#6699cc';
                // Enhanced material for high contrast mode
                const currentTheme = document.documentElement.getAttribute('data-theme');
                let material;

                if (currentTheme === 'high-contrast') {
                    // High contrast material with enhanced specular highlights
                    material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(meshColor),
                        specular: 0xffffff, // White specular highlights for maximum contrast
                        shininess: 300, // Higher shininess for sharper highlights
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                } else {
                    // Standard material for other themes
                    material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(meshColor),
                        specular: 0x111111,
                        shininess: 200,
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                }
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = 0;
                scene.add(mesh);

                // Adjust camera position based on object type using CAMERA_SETTINGS
                if (isCylinder) {
                    // For cylinders: use CAMERA_SETTINGS.CYLINDER configuration
                    // The cylinder's axis is along the Z-direction, centered at origin
                    const cylCam = CAMERA_SETTINGS.CYLINDER;

                    // Ensure camera up vector is correct for upright viewing BEFORE lookAt
                    camera.up.set(cylCam.up.x, cylCam.up.y, cylCam.up.z);

                    // Position camera using CAMERA_SETTINGS (views indicator shapes side)
                    camera.position.set(cylCam.position.x, cylCam.position.y, cylCam.position.z);
                    controls.target.set(cylCam.target.x, cylCam.target.y, cylCam.target.z);
                    camera.lookAt(cylCam.target.x, cylCam.target.y, cylCam.target.z);

                    // Recreate controls so internal up-vector transform matches camera.up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(cylCam.target.x, cylCam.target.y, cylCam.target.z);
                    // Reapply standard control settings
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    // Panning orthogonal to world up for Z-up scenes
                    controls.screenSpacePanning = false;

                    camera.updateProjectionMatrix();
                } else {
                    // For cards: use CAMERA_SETTINGS.CARD configuration
                    const cardCam = CAMERA_SETTINGS.CARD;

                    camera.position.set(cardCam.position.x, cardCam.position.y, cardCam.position.z);
                    camera.up.set(cardCam.up.x, cardCam.up.y, cardCam.up.z);
                    camera.lookAt(cardCam.target.x, cardCam.target.y, cardCam.target.z);
                    // Recreate controls to ensure correct up-vector mapping when switching back to Y-up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(cardCam.target.x, cardCam.target.y, cardCam.target.z);
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    controls.screenSpacePanning = true;
                    camera.updateProjectionMatrix();
                }

                // Force controls to update with new camera settings
                controls.update();
                controls.saveState(); // Save the new camera state as default

                animate();
            }, undefined, function (error) {
                errorText.textContent = 'Failed to load STL: ' + error;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message';
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls && controls.update();
            render();
        }

        // Initialize liblouis web worker and 3D viewer on page load
        let liblouisWorker = null;
        let liblouisReady = false;
        let workerMessageId = 0;
        let pendingWorkerMessages = new Map();

        // Function to send message to worker and get response
        function sendWorkerMessage(type, data = {}) {
            return new Promise((resolve, reject) => {
                if (!liblouisWorker) {
                    reject(new Error('Worker not initialized'));
                    return;
                }

                const id = ++workerMessageId;
                pendingWorkerMessages.set(id, { resolve, reject });

                liblouisWorker.postMessage({ id, type, data });

                // Timeout after 10 seconds
                setTimeout(() => {
                    if (pendingWorkerMessages.has(id)) {
                        pendingWorkerMessages.delete(id);
                        reject(new Error('Worker message timeout'));
                    }
                }, 10000);
            });
        }

        // Mobile-specific utilities
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Prevent double-tap zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });

        // Handle mobile keyboard visibility and orientation changes
        if (isMobileDevice()) {
            const inputs = document.querySelectorAll('input[type="text"], input[type="number"], select');
            inputs.forEach(input => {
                input.addEventListener('focus', () => {
                    // Scroll input into view when keyboard appears
                    setTimeout(() => {
                        const scrollParent = input.closest('.preview-section, .form-section') || document.scrollingElement;
                        if (scrollParent && scrollParent !== document.scrollingElement) {
                            const parentRect = scrollParent.getBoundingClientRect();
                            const inputRect = input.getBoundingClientRect();
                            const offset = (inputRect.top + inputRect.height / 2) - (parentRect.top + parentRect.height / 2);
                            scrollParent.scrollBy({ top: offset, behavior: 'smooth' });
                        } else {
                            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 300);
                });
            });

            // Handle orientation changes to maintain 200% zoom
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (window.innerWidth <= 768) {
                        applyFontSize(6); // Reset to 200% on orientation change
                    }
                }, 100);
            });
        }

        window.addEventListener('load', async () => {
            try {
                // Initialize liblouis web worker
                log.debug('Initializing liblouis web worker...');

                // Test if worker file is accessible first
                try {
                    const workerResponse = await fetch('/static/liblouis-worker.js');
                    if (!workerResponse.ok) {
                        throw new Error(`Worker file not accessible: ${workerResponse.status}`);
                    }
                    log.debug('Worker file is accessible');
                } catch (fetchError) {
                    log.error('Worker file test failed:', fetchError);
                    throw new Error('Cannot access worker file: ' + fetchError.message);
                }

                liblouisWorker = new Worker('/static/liblouis-worker.js');

                // Handle worker messages
                liblouisWorker.onmessage = function(e) {
                    const { id, type, result } = e.data;

                    if (pendingWorkerMessages.has(id)) {
                        const { resolve, reject } = pendingWorkerMessages.get(id);
                        pendingWorkerMessages.delete(id);

                        if (result.success) {
                            resolve(result);
                        } else {
                            reject(new Error(result.error));
                        }
                    }
                };

                liblouisWorker.onerror = function(error) {
                    log.error('Worker error:', error);
                };

                // Initialize liblouis in the worker
                const initResult = await sendWorkerMessage('init');
                if (initResult.success) {
                    liblouisReady = true;
                    log.debug('Liblouis web worker initialized successfully');
                } else {
                    throw new Error('Failed to initialize liblouis worker: ' + initResult.error);
                }

            } catch (error) {
                log.error('Failed to initialize liblouis worker:', error);

                // Fallback: disable liblouis and show error message
                log.debug('Web worker failed - disabling liblouis translation');
                liblouisReady = false;
                liblouisWorker = null;

                // Show user that translation is disabled
                const errorDiv = document.getElementById('error-message');
                const errorText = document.getElementById('error-text');
                if (errorDiv && errorText) {
                    errorText.textContent = 'Web worker failed to initialize. Braille translation preview is disabled on this deployment.';
                    errorDiv.style.display = 'flex';
                }
            }

            // Always default to card on load; do not restore from storage
            const card = document.querySelector('input[name="shape_type"][value="card"]');
            if (card) card.checked = true;

            init3D();
            animate();
        });

        // Function to translate text using liblouis web worker
        async function translateWithLiblouis(text, grade, tableName = null) {
            if (!liblouisReady || !liblouisWorker) {
                throw new Error('Liblouis worker not initialized - translation preview unavailable on this deployment');
            }

            try {
                log.debug('Sending translation request to worker:', text, 'grade:', grade, 'table:', tableName);
                const result = await sendWorkerMessage('translate', { text, grade, tableName });

                if (result.success && result.translation) {
                    log.debug('Translation successful:', result.translation);
                    return result.translation;
                } else {
                    throw new Error('Translation failed: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                log.error('Worker translation failed:', error);
                throw error;
            }
        }




    </script>
</body>
</html>
</html>
