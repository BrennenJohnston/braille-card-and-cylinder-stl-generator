<!-- VERSION: 2024-12-19-revised -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Custom Braille STL Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* Theme CSS Variables */
        :root {
            /* Light mode colors */
            --bg-gradient-start: #e0e7ff;
            --bg-gradient-end: #f6f8fa;
            --bg-primary: #fff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --bg-input: #f9fafb;
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --text-tertiary: #666;
            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;
            --border-focus: #3182ce;
            --btn-primary-bg: linear-gradient(90deg, #3182ce 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #2563eb 60%, #4299e1 100%);
            --btn-success-bg: #10b981;
            --btn-success-hover-bg: #059669;
            --btn-secondary-bg: #9ca3af;
            --btn-tertiary-bg: #6b7280;
            --error-bg: #fee2e2;
            --error-border: #fecaca;
            --error-text: #b91c1c;
            --info-bg: #dbeafe;
            --info-border: #93c5fd;
            --info-text: #1e40af;
            --shadow-light: rgba(49,130,206,0.10);
            --shadow-medium: rgba(49,130,206,0.18);
            --stl-mesh-color: #6699cc;
            --stl-background: #f1f5f9;
            --stl-ambient-light: #888888;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.5;
            --stl-directional-intensity: 1.0;
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --bg-gradient-start: #1a202c;
            --bg-gradient-end: #2d3748;
            --bg-primary: #2d3748;
            --bg-secondary: #374151;
            --bg-tertiary: #4a5568;
            --bg-input: #374151;
            --text-primary: #f7fafc;
            --text-secondary: #e2e8f0;
            --text-tertiary: #cbd5e1;
            --border-primary: #4a5568;
            --border-secondary: #718096;
            --border-focus: #63b3ed;
            --btn-primary-bg: linear-gradient(90deg, #4299e1 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #3182ce 60%, #4299e1 100%);
            --btn-success-bg: #059669;
            --btn-success-hover-bg: #047857;
            --btn-secondary-bg: #718096;
            --btn-tertiary-bg: #4a5568;
            --error-bg: #742a2a;
            --error-border: #9b2c2c;
            --error-text: #fed7d7;
            --info-bg: #2c5282;
            --info-border: #3182ce;
            --info-text: #bee3f8;
            --shadow-light: rgba(0,0,0,0.3);
            --shadow-medium: rgba(0,0,0,0.5);
            --stl-mesh-color: #90cdf4;
            --stl-background: #2d3748;
            --stl-ambient-light: #666666;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.6;
            --stl-directional-intensity: 0.9;
        }

        /* High contrast mode */
        [data-theme="high-contrast"] {
            --bg-gradient-start: #000000;
            --bg-gradient-end: #000000;
            --bg-primary: #000000; /* Keep black background */
            --bg-secondary: #1a1a1a; /* Keep dark background */
            --bg-tertiary: #2a2a2a; /* Keep dark background */
            --bg-input: #1a1a1a; /* Keep dark background for inputs */
            --text-primary: #02fe05; /* Green instead of white */
            --text-secondary: #02fe05; /* Green instead of white */
            --text-tertiary: #02fe05; /* Green instead of white */
            --border-primary: #ffff00;
            --border-secondary: #00ffff;
            --border-focus: #ff00ff;
            --btn-primary-bg: #02fe05; /* Green */
            --btn-primary-hover-bg: #02fe05; /* Green */
            --btn-success-bg: #02fe05; /* Green */
            --btn-success-hover-bg: #02fe05; /* Green */
            --btn-secondary-bg: #ff6600;
            --btn-tertiary-bg: #ff6600;
            --error-bg: #ff0000;
            --error-border: #ff0000;
            --error-text: #02fe05; /* Green instead of white */
            --info-bg: #0000ff;
            --info-border: #0000ff;
            --info-text: #02fe05; /* Green instead of white */
            --shadow-light: none;
            --shadow-medium: none;
            --stl-mesh-color: #00ffff; /* Bright cyan for high contrast */
            --stl-background: #000000; /* Keep black background */
            --stl-ambient-light: #666666; /* Reduced ambient light to prevent washing out */
            --stl-directional-light: #e6e6e6; /* Slightly dimmed directional light for better contrast */
            --stl-ambient-intensity: 0.4; /* Lower ambient light intensity */
            --stl-directional-intensity: 0.8; /* Controlled directional light intensity */
        }

        /* High contrast mode specific button styling */
        [data-theme="high-contrast"] button[type="submit"] {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] button[type="submit"]:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }
        
        /* High contrast mode - Generate STL button state (blue) */
        [data-theme="high-contrast"] #action-btn.generate-state {
            background: #0201fe !important; /* Blue background for generate */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #fdfe00 !important; /* Yellow border */
        }
        
        [data-theme="high-contrast"] #action-btn.generate-state:hover {
            background: #0201fe !important; /* Blue background */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #02fe05 !important; /* Green border on hover */
        }
        
        /* High contrast mode - Download STL button state (green) */
        [data-theme="high-contrast"] #action-btn.download-state {
            background: #02fe05 !important; /* Green background for download */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }
        
        [data-theme="high-contrast"] #action-btn.download-state:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }
        
        /* High contrast mode - Disabled/Loading state */
        [data-theme="high-contrast"] #action-btn:disabled {
            background: #666666 !important; /* Gray background for disabled */
            color: #cccccc !important; /* Light gray text */
            border: 2px solid #999999 !important; /* Gray border */
            cursor: not-allowed !important;
        }

        [data-theme="high-contrast"] #download-counter-plate-btn {
            background: #ff6600 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] #download-counter-plate-btn:hover {
            background: #ff8800 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        [data-theme="high-contrast"] .expert-toggle-btn,
        [data-theme="high-contrast"] .info-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn:hover,
        [data-theme="high-contrast"] .info-toggle-btn:hover {
            background: #000000 !important; /* Black background on hover */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn.active,
        [data-theme="high-contrast"] .info-toggle-btn.active {
            background: #000000 !important; /* Black background when active */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .font-size-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .font-size-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        [data-theme="high-contrast"] .font-size-btn.reset-btn {
            background: #2a2a2a !important; /* Darker background */
            color: #00ffff !important; /* Cyan text */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .font-size-display {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        /* Apply transition to theme changes */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; /* Ensure all elements include padding/borders in width */
        }

        /* Skip Link for Keyboard Navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--border-focus);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 0 0 8px 0;
            z-index: 1000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }



        /* Font Size Controls */
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.4em 0.6em;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .font-size-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            min-width: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .font-size-btn:hover {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px var(--shadow-medium);
        }

        .font-size-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .font-size-btn.reset-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.8em;
        }

        .font-size-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 3.5em;
            text-align: center;
            user-select: none;
        }



        /* Enhanced focus indicators for all interactive elements */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        a:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Ensure proper keyboard navigation visibility */
        *:focus-visible {
            outline: 3px solid var(--border-focus) !important;
            outline-offset: 2px !important;
        }

        /* Mobile-optimized containers */
        @media (max-width: 768px) {
            .main-layout {
                overflow-y: auto; /* Allow main scroll on mobile if needed */
            }
            
            /* Sticky generate button on mobile */
            .button-row {
                position: sticky;
                bottom: 0;
                background: var(--bg-primary);
                padding: 1em 0;
                margin: 0 -1em;
                padding-left: 1em;
                padding-right: 1em;
                box-shadow: 0 -2px 8px var(--shadow-light);
                z-index: 10;
            }
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Fieldset styling */
        fieldset {
            border: none;
            padding: 0;
            margin: 0;
        }

        .line-input-fieldset {
            margin: 0;
        }

        /* Braille preview styles */
        .braille-preview {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
        }

        .preview-heading {
            margin-top: 0;
            color: var(--text-primary);
        }

        .preview-line-success {
            margin: 10px 0;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 5px;
            border: 1px solid var(--border-primary);
        }

        .preview-line-error {
            margin: 10px 0;
            padding: 10px;
            background: var(--error-bg);
            border-radius: 5px;
            border: 1px solid var(--error-border);
            color: var(--error-text);
        }

        .expert-info {
            font-size: 0.9em;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 1em;
            text-align: center;
        }

        /* High contrast text styling */
        [data-theme="high-contrast"] strong,
        [data-theme="high-contrast"] b {
            color: #02fe05 !important; /* Green for bold text */
        }

        [data-theme="high-contrast"] .grade-label[style*="font-weight: 700"] {
            color: #02fe05 !important; /* Green for bold labels */
        }

        [data-theme="high-contrast"] em,
        [data-theme="high-contrast"] i,
        [data-theme="high-contrast"] [style*="font-style: italic"] {
            color: #fdfe00 !important; /* Yellow for italic text */
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-info span {
            color: #fdfe00 !important; /* Yellow for grade info notes */
        }

        [data-theme="high-contrast"] #offset-help {
            color: #fdfe00 !important; /* Yellow for offset help text */
        }

        /* Note styling classes */
        .grade-note,
        .offset-note {
            color: var(--text-tertiary);
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-note,
        [data-theme="high-contrast"] .offset-note {
            color: #fdfe00 !important; /* Yellow for all note text */
        }

        html {
            background: linear-gradient(120deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh; /* Ensure background covers viewport */
            overscroll-behavior: none;
        }

        body {
            background: transparent; /* Inherit gradient from html */
            min-height: 100vh; /* Minimum viewport height, can grow if needed */
            font-family: 'Inter', system-ui, Arial, sans-serif;
            margin: 0;
            display: flex;
            align-items: flex-start; /* Align to top to prevent centering issues */
            justify-content: center;
            padding: 0; /* Remove padding to extend to browser edges */
            color: var(--text-primary);
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            box-sizing: border-box;
            overflow-x: hidden;
            overflow-y: auto; /* Allow scrolling if content overflows */
            overscroll-behavior: none;
        }
        
        /* Mobile-specific body adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0; /* Remove padding on mobile too */
                min-height: 100vh;
                overflow-y: auto; /* Allow scrolling on mobile if needed */
                overflow-x: hidden;
                align-items: flex-start; /* Align to top on mobile */
            }
        }
        
        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 2em;
            background: var(--bg-primary);
            border-radius: 0; /* Remove border radius to extend to edges */
            box-shadow: none; /* Remove shadow since we're edge-to-edge */
            padding: 2.5em;
            width: 100%;
            min-height: 100vh; /* Minimum full viewport height, can grow if needed */
            margin: 0;
            overflow-y: auto; /* Allow main scroll if content overflows */
            overflow-x: hidden;
            box-sizing: border-box;
        }
        
        /* Mobile layout optimization */
        @media (max-width: 768px) {
            .main-layout {
                padding: 1.5em;
                border-radius: 0; /* Remove border radius on mobile too */
                gap: 1.5em;
                box-shadow: none; /* Remove shadow on mobile too */
                min-height: 100vh; /* Minimum full height on mobile */
                overflow-y: auto; /* Allow main scroll on mobile if needed */
                overflow-x: hidden;
            }
        }
        
        @media (max-width: 480px) {
            .main-layout {
                padding: 1em;
                border-radius: 0; /* Remove border radius on small mobile too */
                gap: 1em;
            }
        }
        
        /* Title Section - Full Width at Top */
        .title-section {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 1.5em;
            width: 100%;
        }
        
        .title-section h1 {
            margin: 0;
            display: flex;
            flex-direction: row;
            align-items: baseline;
            gap: 0.4em;
            line-height: 1.1;
            white-space: nowrap;
        }
        
        .title-line-1 {
            font-size: 19.6pt;
            font-weight: 700;
            color: var(--text-primary); /* Default theme color */
        }
        
        .title-line-2 {
            font-size: 19.6pt;
            font-weight: 600;
            color: var(--text-secondary); /* Default theme color */
            margin: 0;
        }
        
        /* High contrast mode - bright violet title */
        [data-theme="high-contrast"] .title-line-1,
        [data-theme="high-contrast"] .title-line-2 {
            color: #fd01fc !important; /* Bright violet for high contrast mode */
        }
        
        /* Top Accessibility Controls */
        .accessibility-controls-top {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-end;
            gap: 0.8rem;
            margin-left: 1rem;
            flex-wrap: nowrap;
        }
        /* Ensure theme toggle appears before font-size controls (to the left) */
        .accessibility-controls-top .theme-toggle-section { order: 0; }
        .accessibility-controls-top .font-size-controls { order: 1; }
        
        /* Content Area - Two Column Layout */
        .content-area {
            display: flex;
            gap: 2.5em;
            width: 100%;
            flex: 1; /* Take remaining space after title */
            min-height: 0; /* Allow shrinking for scrolling to work */
            overflow: visible; /* Allow content to be visible */
        }
        
        /* Left Column - Preview Section (45% width) */
        .preview-section {
            flex: 0 0 45%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            /* Make left column independently scrollable without collapsing viewer */
            max-height: none;
            min-height: 0;
            overflow-y: visible;
            -webkit-overflow-scrolling: touch;
            overflow-x: hidden;
            padding-right: 1em; /* Add padding to prevent cutoff */
        }
        
        /* Right Column - Form Section (55% width) */
        .form-section {
            flex: 0 0 calc(55% - 2em); /* Subtract padding to prevent overflow */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-width: 320px;
            max-width: calc(55% - 2em); /* Prevent form from extending past background */
            /* Make right column independently scrollable - separate from left column */
            max-height: calc(100vh - 10em); /* Account for main-layout padding (5em) and title section (~5em) */
            min-height: 0;
            overflow-y: auto; /* Enable scrolling for right column menu boxes */
            -webkit-overflow-scrolling: touch;
            overflow-x: hidden; /* Prevent horizontal overflow */
            scrollbar-width: auto; /* Firefox standard scrollbar */
            scrollbar-color: var(--border-primary) var(--bg-tertiary); /* Firefox scrollbar colors */
            /* Distinct background for scrollable area */
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.2em;
            border: 1px solid var(--border-secondary);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        /* Custom scrollbar styling for webkit browsers - larger and more visible */
        .form-section::-webkit-scrollbar {
            width: 14px; /* Increased from 8px for better visibility */
        }

        .form-section::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 7px;
            margin: 4px 0; /* Add some margin at top and bottom */
        }

        .form-section::-webkit-scrollbar-thumb {
            background: var(--border-primary);
            border-radius: 7px;
            border: 2px solid var(--bg-tertiary); /* Creates space around thumb */
        }

        .form-section::-webkit-scrollbar-thumb:hover {
            background: var(--text-primary);
            border-color: var(--bg-tertiary);
        }
        
        /* Mobile layout - stack columns */
        @media (max-width: 768px) {
            .content-area {
                flex-direction: column;
                gap: 1.5em;
                overflow: visible; /* Allow content to be visible on mobile */
            }
            
            .preview-section {
                flex: none;
                width: 100%;
                height: auto;
                max-height: none;
                overflow: visible;
            }
            
            .form-section {
                flex: 1; /* Take remaining space */
                width: 100%;
                max-height: none; /* Remove height restriction on mobile */
                overflow-y: auto; /* Enable scrolling within the container */
                overflow-x: hidden;
                /* Keep scrollable styling on mobile for inner content */
                background: var(--bg-secondary);
                border: 1px solid var(--border-primary);
                border-radius: 12px;
                padding: 1.2em;
                box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            }
        }
        
        /* Desktop layout - sticky left preview, separate right column scrolling */
        @media (min-width: 769px) {
            .preview-section {
                position: sticky;
                top: 0;
                align-self: flex-start; /* ensure sticky positions relative to content area */
            }
            
            /* Ensure right column scrolling is properly configured for desktop */
            .form-section {
                max-height: calc(100vh - 10em); /* Account for main-layout padding and title section */
                overflow-y: auto;
                position: relative; /* For scroll indicator positioning */
            }
            
            /* Visual scroll indicator - shadow at bottom when scrollable */
            .form-section::after {
                content: '';
                position: sticky;
                bottom: 0;
                left: 0;
                right: 0;
                height: 20px;
                background: linear-gradient(to top, var(--bg-secondary), transparent);
                pointer-events: none;
                opacity: 0.8;
            }
        }

        #viewer {
            width: 100%;
            min-width: 320px;
            max-width: 100%;
            height: calc(100vh - 16em); /* Adjust for new layout spacing */
            border-radius: 18px;
            border: 2px solid var(--border-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 4px 24px var(--shadow-light);
            display: flex;
            align-items: center; /* vertically center canvas */
            justify-content: center; /* horizontally center canvas */
            margin: 0 0 1.5em 0;
            transition: box-shadow 0.2s;
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden; /* Ensure content doesn't overflow rounded corners */
            box-sizing: border-box; /* Include border in size calculation */
            position: relative; /* Create positioning context for overlay */
        }

        /* Canvas should fill the content box and be clipped by the rounded frame */
        #viewer canvas {
            position: relative;
            z-index: 1;
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Mobile viewer optimizations */
        @media (max-width: 768px) {
            #viewer {
                height: calc(40vh - 1em); /* Responsive height for tablets - leave more room for content */
                min-width: unset;
                width: 100%;
                max-width: 100%;
                border-radius: 12px;
                margin: 0 0 1em 0;
            }
        }
        
        @media (max-width: 480px) {
            #viewer { 
                height: calc(35vh - 1em); /* Responsive height for phones - more compact */
                border-radius: 12px; 
            }
        }
        #viewer:focus-within, #viewer:active {
            box-shadow: 0 8px 32px var(--shadow-medium);
        }

        h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 0.7em;
            color: var(--text-primary);
            text-align: left;
        }
        
        /* Mobile heading optimization */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 0.5em;
                text-align: center;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
                line-height: 1.3;
            }
        }
        .info-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .info-panel p {
            margin: 0.3em 0;
        }
        .grade-selection {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
        }
        
        /* Mobile grade selection optimization */
        @media (max-width: 768px) {
            .grade-selection {
                padding: 1.2em;
                margin-bottom: 1.2em;
            }
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.6em;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.6em;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--text-secondary);
            padding: 0.5em 0;
            margin: -0.5em 0;
        }
        
        /* Mobile radio option optimization */
        @media (max-width: 768px) {
            .radio-option {
                padding: 0.8em 0;
                font-size: 1em;
                gap: 0.8em;
            }
            
            .radio-option input[type="radio"] {
                width: 20px;
                height: 20px;
                min-width: 20px;
                min-height: 20px;
            }
        }
        .radio-option input[type="radio"] {
            margin: 0;
            cursor: pointer;
        }
        .radio-text {
            cursor: pointer;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 1.1em;
        }
        .line-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
        }
        .line-input {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.8em;
        }
        .line-translation-row,
        .line-text-row {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0.4em;
        }
        .line-text-row input[type="text"] {
            width: 100%;
        }
        /* Ensure even vertical spacing between each manual line group */
        #dynamic-line-inputs {
            display: flex;
            flex-direction: column;
            gap: 1em;
        }
        /* Normalize label spacing within rows */
        .line-translation-row .line-label,
        .line-text-row .line-label {
            margin: 0;
        }
        
        /* Mobile line input optimization */
        @media (max-width: 768px) {
            .line-input {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5em;
            }
            
            .line-label {
                font-size: 0.95em;
                font-weight: 600;
                margin-bottom: 0.2em;
            }
        }
        .line-label {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 60px;
            font-size: 0.9em;
        }
        input[type="text"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }
        
        /* Mobile-friendly input styles */
        @media (max-width: 768px) {
            input[type="text"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
            }
        }
        input[type="text"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        /* Ensure number inputs are properly styled and functional */
        input[type="number"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            min-width: 80px;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            appearance: none;
        }
        
        /* Remove spinner buttons */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Mobile-friendly number input styles */
        @media (max-width: 768px) {
            input[type="number"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
                width: 100%;
                min-width: unset;
            }
        }
        
        input[type="number"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        input[type="number"]:hover {
            border-color: var(--border-primary);
        }
        
        /* Language select dropdown styling */
        .language-select {
            width: 100%;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%23666" d="M0 0l6 6 6-6z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.8em center;
            background-size: 12px;
            padding-right: 2.5em;
        }
        
        /* Mobile select optimization */
        @media (max-width: 768px) {
            .language-select {
                padding: 1em;
                padding-right: 3em;
                font-size: 16px;
                min-height: 48px;
            }
        }
        
        .language-select:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        .language-select:hover {
            border-color: var(--border-primary);
        }
        
        /* High contrast mode select styling */
        [data-theme="high-contrast"] .language-select {
            background: #1a1a1a !important;
            color: #ffffff !important;
            border: 2px solid #ffff00 !important;
        }
        
        [data-theme="high-contrast"] .language-select:focus {
            background: #2a2a2a !important;
            color: #ffffff !important;
            border: 2px solid #ff00ff !important;
        }
        
        [data-theme="high-contrast"] .language-select option {
            background: #1a1a1a !important;
            color: #ffffff !important;
        }
        
        [data-theme="high-contrast"] .language-select optgroup {
            background: #2a2a2a !important;
            color: #ffff00 !important;
            font-weight: bold;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
            margin-top: 1em;
        }
        button {
            border: none;
            border-radius: 8px;
            padding: 0.7em 1em;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            line-height: 1.2;
            white-space: nowrap;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        /* Mobile-friendly button styles */
        @media (max-width: 768px) {
            button {
                padding: 1em 1.2em;
                font-size: 1.1em;
                min-height: 48px;
                min-width: 48px;
            }
        }
        button[type="submit"] {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        button[type="submit"]:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        /* Action button state styles */
        #action-btn {
            transition: all 0.3s ease;
            min-width: 140px;
            text-align: center;
            font-size: 0.95em;
        }
        
        #action-btn.generate-state {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        
        #action-btn.generate-state:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        #action-btn.download-state {
            background: var(--btn-success-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        
        #action-btn.download-state:hover {
            background: var(--btn-success-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            margin-bottom: 1em;
            flex-wrap: wrap;
        }
        
        /* Mobile button row optimization */
        @media (max-width: 768px) {
            .button-row {
                gap: 0.8em;
                justify-content: stretch;
            }
            
            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }
        
        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }
            
            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }


        #download-counter-plate-btn {
            background: var(--btn-tertiary-bg);
            color: #fff;
        }
        #download-counter-plate-btn:hover {
            background: var(--btn-tertiary-bg);
            opacity: 0.9;
            transform: translateY(-2px) scale(1.03);
        }
        #error-message {
            color: var(--error-text);
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            border-radius: 6px;
            padding: 0.9em 1.2em;
            margin: 0;
            font-size: 1.25em;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 0.7em;
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            width: 100%;
            text-align: center;
            z-index: 2;
            pointer-events: none;
            box-shadow: 0 6px 20px var(--shadow-light);
            box-sizing: border-box;
        }
        
        #error-message.info {
            color: var(--info-text);
            background: var(--info-bg);
            border: 1px solid var(--info-border);
        }
        
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        
        .expert-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5em;
            transition: background 0.2s, border-color 0.2s;
            width: 100%;
        }
        
        .expert-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }
        
        .expert-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        
        .expert-toggle-btn.active #expert-toggle-text {
            color: #fff;
        }
        
        .expert-toggle-btn.active #expert-toggle-icon {
            transform: rotate(180deg);
        }
        
        /* Reset to Defaults button styling */
        .reset-container {
            margin-top: 0.6em;
        }
        .reset-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em 1.2em;
            width: 100%;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .reset-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }
        [data-theme="high-contrast"] .reset-btn {
            background: #1a1a1a !important;
            color: #02fe05 !important;
            border: 2px solid #02fe05 !important;
        }
        [data-theme="high-contrast"] .reset-btn:hover {
            background: #000000 !important;
            color: #02fe05 !important;
            border: 2px solid #02fe05 !important;
        }

        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }
        
        /* Ensure Expert Mode inputs are properly spaced and visible */
        .expert-settings .grade-selection {
            margin-bottom: 1em;
        }
        
        .expert-settings input[type="number"] {
            margin-top: 0.3em;
            margin-bottom: 0.5em;
        }
        
        .expert-settings label {
            display: block;
            margin-bottom: 0.3em;
            font-weight: 500;
            color: var(--text-primary);
        }
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }
        
        .info-dropdown {
            margin-bottom: 1.5em;
        }
        
        .info-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }
        
        .info-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }
        
        .info-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        
        .info-toggle-btn.active #info-toggle-text {
            color: #fff;
        }
        
        .info-toggle-btn.active #info-toggle-icon {
            transform: rotate(180deg);
        }
        
        .info-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        /* Expert submenus */
        .expert-submenu {
            margin-top: 0.8em;
        }
        .expert-submenu-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }
        .expert-submenu-toggle:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }
        .expert-submenu-toggle.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        .expert-submenu-toggle.active .expert-submenu-title {
            color: #fff;
        }
        .expert-submenu-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
        }
        
        .info-content p {
            margin: 0.3em 0;
        }
        
        /* Additional mobile optimizations */
        @media (max-width: 768px) {
            .viewer-section, .form-section {
                max-width: 100%;
                min-width: unset;
            }
            
            .info-panel, .info-content {
                padding: 1.2em;
                font-size: 0.95em;
            }
            
            .info-toggle-btn, .expert-toggle-btn {
                padding: 1em;
                font-size: 1em;
                min-height: 48px;
            }
            
            #error-message {
                padding: 1em;
                font-size: 0.95em;
                margin: 0.8em 0;
            }
            
            .button-group {
                gap: 0.8em;
            }
            
            /* Mobile optimizations */
            html {
                scroll-behavior: smooth;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 480px) {
            .expert-settings input[type="number"] {
                width: 100%;
            }
            
            .font-size-controls {
                transform: scale(0.9);
                transform-origin: top right;
            }
        }
        

        
        /* Plate Selection Row Layout */
        .plate-selection-row {
            display: flex;
            align-items: flex-start;
            gap: 1.5em;
            margin-top: 1em;
        }
        
        .plate-type-selection {
            flex: 1;
            min-width: 250px;
        }
        
        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            flex-shrink: 0;
        }
        
        /* Mobile plate selection row optimization */
        @media (max-width: 768px) {
            .plate-selection-row {
                flex-direction: column;
                gap: 1em;
            }
            
            .plate-type-selection {
                min-width: unset;
                width: 100%;
            }
            
            .button-row {
                width: 100%;
                justify-content: stretch;
            }
            
            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }
        
        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }
            
            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }

        /* Theme Toggle Section */
        .theme-toggle-section {
            display: flex;
            align-items: center;
            gap: 0.8em;
            margin-left: 0;
        }

        .theme-label-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            color: var(--text-secondary);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.3em;
            min-height: 2.5em;
            box-sizing: border-box;
        }

        .theme-label-text {
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Theme Toggle Button */
        .theme-toggle-btn {
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .theme-toggle-btn:hover {
            background: var(--bg-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .theme-toggle-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .theme-icon {
            font-size: 1.2em;
        }

        /* Mobile title section optimization */
        @media (max-width: 768px) {
            .title-section {
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 1rem;
                margin-bottom: 1em;
            }
            
            .title-section h1 {
                text-align: center;
            }
            
            .title-line-1 {
                font-size: 16pt;
            }
            
            .title-line-2 {
                font-size: 16pt;
            }
            
            .accessibility-controls-top {
                margin-left: 0;
                align-items: center;
            }
            
            .theme-toggle-section {
                flex-direction: column;
                align-items: center;
                gap: 0.5em;
                margin-left: 0;
            }
            
            .theme-label-box {
                font-size: 0.85em;
                min-height: 2.2em;
            }
        }
        
        @media (max-width: 480px) {
            .title-line-1 {
                font-size: 13.6pt;
            }
            
            .title-line-2 {
                font-size: 13.6pt;
            }
        }
        
        /* Form Section Accessibility Controls */
        [data-theme="high-contrast"] .theme-label-box {
            background: #1a1a1a !important; /* Dark background for high contrast */
            border: 2px solid #ffff00 !important; /* Yellow border for high contrast */
        }
        
        [data-theme="high-contrast"] .theme-label-text {
            color: #02fe05 !important; /* Green text for high contrast */
        }
        
        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow instead of yellow */
            color: #0201fe !important; /* Blue instead of black */
            border: 2px solid #0201fe !important; /* Blue instead of black */
        }

        [data-theme="high-contrast"] input[type="text"],
        [data-theme="high-contrast"] input[type="number"] {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] input[type="text"]:focus,
        [data-theme="high-contrast"] input[type="number"]:focus {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ff00ff !important; /* Magenta border on focus */
        }

        [data-theme="high-contrast"] .info-panel,
        [data-theme="high-contrast"] .grade-selection,
        [data-theme="high-contrast"] .info-content {
            background: #1a1a1a !important; /* Dark background for panels */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .braille-preview {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .preview-line-success {
            background: #2a2a2a !important; /* Darker background */
            color: #02fe05 !important; /* Green text for success */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .preview-line-error {
            background: #ff0000 !important;
            color: #02fe05 !important; /* Green text */
            border: 2px solid #ff0000 !important;
        }

        /* Subline under each preview line for computer shorthand */
        .preview-subline {
            font-size: 0.9em;
            opacity: 0.85;
            margin-top: 0.25em;
        }

        /* Section Title Styling - Larger Font for All Themes */
        .info-panel strong,
        .info-panel p strong {
            font-size: 1.3em !important;
            font-weight: 700 !important;
        }
        
        #info-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }
        
        .grade-label {
            font-weight: 600;
            color: var(--text-primary);
            display: block;
            margin-bottom: 0.8em;
            font-size: 1.2em !important; /* Increased from 0.9em */
        }
        
        .expert-toggle-btn #expert-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }

        /* Auto placement textarea styling to visually align with manual inputs */
        #auto-input-container textarea#auto-text {
            width: 100%;
            min-height: 6.5em; /* approx 4 lines */
            line-height: 1.4;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }
        #auto-input-container textarea#auto-text:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        /* High contrast maintains theme variables already set */
    </style>
</head>
<body>
    <!-- Skip Navigation Link for Keyboard Users -->
    <a href="#main-content" class="skip-link" tabindex="0">Skip to main content</a>
    

    
    <div class="main-layout" role="main" id="main-content">
        <!-- Title Section at the top -->
        <div class="title-section">
            <h1 id="main-heading">
                <span class="title-line-1">Custom Braille</span>
                <span class="title-line-2">STL Generator</span>
            </h1>
            
            <!-- Accessibility Controls in top right -->
            <div class="accessibility-controls-top" role="group" aria-label="Accessibility controls">
                <!-- Font Size Controls -->
                <div class="font-size-controls" role="group" aria-label="Font size adjustment">
                    <button id="font-decrease" class="font-size-btn" aria-label="Decrease font size" title="Decrease font size">
                        <span aria-hidden="true">A-</span>
                        <span class="sr-only">Decrease font size</span>
                    </button>
                    <span class="font-size-display" aria-label="Current font size">
                        <span id="current-font-size">100</span>%
                    </span>
                    <button id="font-increase" class="font-size-btn" aria-label="Increase font size" title="Increase font size">
                        <span aria-hidden="true">A+</span>
                        <span class="sr-only">Increase font size</span>
                    </button>
                    <button id="font-reset" class="font-size-btn reset-btn" aria-label="Reset font size to default" title="Reset font size to default">
                        <span aria-hidden="true">G</span>
                        <span class="sr-only">Reset font size</span>
                    </button>
                </div>
                
                <!-- Theme Toggle Section -->
                <div class="theme-toggle-section" role="group" aria-labelledby="theme-label">
                    <div id="theme-label" class="theme-label-box">
                        <span class="theme-label-text">Change Theme to G</span>
                    </div>
                    <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle theme" title="Toggle between light, dark, and high contrast themes">
                        <span class="theme-icon" aria-hidden="true">G</span>
                        <span class="theme-text">High Contrast</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area - Two Column Layout -->
        <div class="content-area">
            <!-- Left Column - STL Preview Section (45% width) -->
            <div class="preview-section" role="region" aria-label="3D STL Preview">
                <div id="viewer" role="img" aria-label="3D preview of braille business card STL file" tabindex="0">
                    <div id="error-message" role="alert" aria-live="assertive" aria-atomic="true">
                        <span style="font-weight:bold;" aria-hidden="true">G</span> 
                        <span id="error-text"></span>
                    </div>
                </div>
                <!-- Action Button moved here -->
                <div class="button-row" style="margin-top: 1em;">
                    <button type="button" id="action-btn" class="generate-state" aria-label="Generate STL file from entered text" data-state="generate">Generate STL</button>
                </div>
            </div>
            
            <!-- Right Column - Form Controls Section (55% width) -->
            <div class="form-section" role="region" aria-label="Braille Card Configuration">
                <div class="info-panel">
                    <p><strong>Program Description:</strong></p>
                    <p>Creates two matching STLs for a standard 3.5G + 2G card.</p>
                    <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                        <li><strong>Embossing Plate</strong> (cone dots)</li>
                        <li><strong>Universal Counter Plate</strong> (hemispherical recessed dots)</li>
                    </ol>
                </div>
                
                <div class="info-dropdown">
                    <button type="button" id="info-toggle" class="info-toggle-btn">
                        <span id="info-toggle-text">More Info</span>
                        <span id="info-toggle-icon">G+</span>
                    </button>
                    <div id="info-content" class="info-content" style="display: none;">
                        <p><strong>Instructions:</strong></p>
                        <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Enter any number of lines (set in <strong>Expert Mode G Number of Braille Lines</strong>), then click <strong>"Generate STL."</strong> The app auto-translates to <strong>Unified English Braille (UEB)</strong>.</li>
                            <li>Review the 3D preview. If it looks correct, click <strong>"Download STL."</strong></li>
                            <li>Click <strong>"Universal Counter Plate"</strong> and repeat the steps to generate and download the matching counter plate (if you haven't printed one yet).</li>
                            <li>Need specific dimensions? Open <strong>Expert Mode</strong> to adjust card size, spacing, and dot parameters.</li>
                        </ol>
                        <p><strong>Business card guidance:</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li><strong>Default:</strong> English (UEB), United States G uncontracted (grade 1). See BANAGs <a href="https://www.brailleauthority.org/bana-position-statements-and-fact-sheets" target="_blank" style="color: #3182ce; text-decoration: none;">Business Cards Fact Sheet (March 2024)</a>.</li>
                            <li><strong>What to include:</strong> pick two key items (e.g., your name and either email or phone). ItGs fine to break long emails across lines at logical places.</li>
                            <li><em>GBraille business cards G work best with letter-for-letter substitution G known as Grade 1 Braille. It helps to cut down on potential confusion or misinterpretationG Grade 2 G is an option if youGre unable to fit the information you need.G</em> G <a href="https://brailleworks.com/braille-business-cards-411/" target="_blank" style="color: #3182ce; text-decoration: none;">Braille Works, The 411 on Braille Business Cards</a></li>
                        </ul>
                        <p><strong>Acknowledgements:</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Powered by <a href="https://liblouis.io/" target="_blank" style="color: #3182ce; text-decoration: none;"><strong>Liblouis</strong></a>, an open-source professional braille translator.</li>
                            <li>Extra thanks to <strong>Tobi Weinberg</strong> for the substantial time and effort he volunteered to help start this project and see it through.</li>
                        </ul>
                    </div>
                </div>
                
                <form id="braille-form" aria-labelledby="main-heading">
                    <!-- Text Input Section moved into form (separate scrollable pane) -->
                    <div class="line-input-group">
                        <fieldset class="line-input-fieldset">
                            <legend class="grade-label">Enter Text for Braille Translation</legend>
                            <div class="grade-note" style="margin-bottom: 0.8em; font-size: 0.85em;">
                                <strong>Note:</strong> Contracted braille combines letters into single cells, so the character limit is only confirmed <em>after translation</em> G the program will warn you automatically if it's too long.
                            </div>
                            <!-- Placement mode toggle -->
                            <div class="line-input-mode-toggle" style="margin-bottom: 0.8em; display: flex; align-items: center; gap: 1em;">
                                <label class="line-label" for="placement_mode_auto" style="margin: 0;">Placement Mode:</label>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="placement_mode" value="auto" id="placement_mode_auto" checked>
                                    Auto Placement
                                </label>
                                <label style="display: inline-flex; align-items: center; gap: 0.4em;">
                                    <input type="radio" name="placement_mode" value="manual" id="placement_mode_manual">
                                    Manual Placement
                                </label>
                            </div>
                            <!-- Auto placement textarea (hidden by default) -->
                            <div id="auto-input-container" style="display: none;">
                                <label for="auto-text" class="line-label">Auto Placement Text</label>
                                <textarea id="auto-text" rows="4" placeholder="Type all your text here. It will be translated to braille and auto-wrapped across rows based on available cells." style="width: 100%; resize: vertical;"></textarea>
                                <div id="auto-overflow-warning" class="grade-note" style="margin-top: 0.6em; color: #d73502; display: none;">
                                    <strong>Warning:</strong> <span id="auto-overflow-message"></span>
                                </div>
                            </div>
                            <!-- Dynamic line inputs container -->
                            <div id="dynamic-line-inputs">
                                <!-- Line inputs will be dynamically generated here based on grid_rows value -->
                            </div>
                        </fieldset>
                    </div>
                    <!-- Language Selection -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Language:</legend>
                            <div style="margin-bottom: 0.8em;">
                                <select id="language-table" name="language_table" class="language-select" aria-describedby="language-help">
                                    <option value="en-ueb-g2.ctb">English (UEB), United States G contracted (grade 2)</option>
                                    <option value="en-ueb-g1.ctb" selected>English (UEB), United States G uncontracted (grade 1)</option>
                                    <option value="en-us-g2.ctb">English (EBAE), United States G contracted (grade 2)</option>
                                    <option value="en-us-g1.ctb">English (EBAE), United States G uncontracted (grade 1)</option>
                                </select>
                                <div id="language-help" class="grade-note" style="margin-top: 6px; font-size: 0.85em;">
                                    Default: English (UEB), United States G uncontracted (grade 1). Chosen to align with BANA guidance for business cards and to minimize ambiguity for names, emails, and short contact info. Use contracted (grade 2) only when space is limited.
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    
                    <!-- Plate Type Selection moved here -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Plate to Generate</legend>
                            <div class="radio-group" role="radiogroup" aria-required="true">
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="positive" checked aria-describedby="emboss-plate-desc">
                                    <span class="radio-text">Embossing Plate</span>
                                </label>
                                <span id="emboss-plate-desc" class="sr-only">Creates raised braille dots for embossing cards</span>
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="negative" aria-describedby="counter-plate-desc">
                                    <span class="radio-text">Universal Counter Plate</span>
                                </label>
                                <span id="counter-plate-desc" class="sr-only">Creates recessed dots to support embossing process</span>

                            </div>
                        </fieldset>
                    </div>
                    <!-- Reset Settings menu box -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Reset Settings</legend>
                            <div class="reset-container">
                                <button type="button" id="reset-defaults-btn" class="reset-btn" aria-label="Reset all settings to default">Reset all settings to default</button>
                            </div>
                        </fieldset>
                    </div>
                    
                    
                    


                    <div class="expert-mode-toggle">
                        <button type="button" id="expert-toggle" class="expert-toggle-btn">
                            <span id="expert-toggle-text">Show Expert Mode</span>
                            <span id="expert-toggle-icon">G+</span>
                        </button>
                    </div>

                    <div id="expert-settings" class="expert-settings" style="display: none;">
                        <div class="expert-info" role="note" aria-label="Expert mode information">
                            Any changes made here will affect both plates.
                        </div>

                        <!-- Preview button moved to the top of Expert Mode -->
                        <div style="margin-top: 1em; margin-bottom: 0.5em; text-align: center;">
                            <button type="button" id="preview-braille-btn">Preview Braille Translation</button>
                        </div>

                        <div id="braille-preview" class="braille-preview" style="display: none;" role="region" aria-label="Braille translation preview">
                            <h3 class="preview-heading">Braille Translation Preview:</h3>
                            <div id="preview-content"></div>
                        </div>

                        <!-- Submenu: Shape Selection -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Shape Selection</span>
                                <span class="expert-submenu-icon">G+</span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <!-- Output Shape Selection (moved into Expert Mode) -->
                                <div class="grade-selection">
                                    <fieldset>
                                        <legend class="grade-label">Output Shape (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-required="true">
                                            <label class="radio-option">
                                                <input type="radio" name="shape_type" value="cylinder" checked aria-describedby="cylinder-shape-desc">
                                                <span class="radio-text">Cylinder</span>
                                            </label>
                                            <span id="cylinder-shape-desc" class="sr-only">Creates a cylindrical braille surface</span>
                                            <label class="radio-option">
                                                <input type="radio" name="shape_type" value="card" aria-describedby="card-shape-desc">
                                                <span class="radio-text">Flat Card</span>
                                            </label>
                                            <span id="card-shape-desc" class="sr-only">Creates a flat rectangular braille card</span>
                                        </div>
                                    </fieldset>
                                </div>

                                <!-- Combined Shape Selection (for both Embossing Plate and Counter Plate) -->
                                <div class="grade-selection" id="combined-shape-selection" style="display: block;">
                                    <fieldset>
                                        <legend class="grade-label">Braille Dot Shape (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-required="true">
                                            <label class="radio-option">
                                                <input type="radio" name="combined_shape" value="rounded" checked aria-describedby="rounded-combined-desc">
                                                <span class="radio-text">Rounded</span>
                                            </label>
                                            <span id="rounded-combined-desc" class="sr-only">Creates rounded dome dots for emboss plate and spherical-cap bowl recess for counter plate</span>
                                            <label class="radio-option">
                                                <input type="radio" name="combined_shape" value="cone" aria-describedby="cone-combined-desc">
                                                <span class="radio-text">Cone</span>
                                            </label>
                                            <span id="cone-combined-desc" class="sr-only">Creates cone frustum dots for emboss plate and conical frustum recess for counter plate</span>
                                        </div>
                                    </fieldset>
                                </div>

                                <!-- Hidden radio buttons for backend compatibility -->
                                <div style="display: none;">
                                    <input type="radio" name="dot_shape" value="rounded" checked>
                                    <input type="radio" name="dot_shape" value="cone">
                                    <input type="radio" name="recess_shape" value="1" checked>
                                    <input type="radio" name="recess_shape" value="2">
                                </div>

                                <!-- Indicator Shape toggle -->
                                <div class="grade-selection">
                                    <fieldset>
                                        <legend class="grade-label" style="font-size: 1.2em; font-weight: 700;">Indicator Shapes (Emboss and Counter)</legend>
                                        <div class="radio-group" role="radiogroup" aria-label="Indicator Shape toggle">
                                            <label class="radio-option">
                                                <input type="radio" name="indicator_shapes" id="indicator_on" value="1" checked>
                                                <span class="radio-text">On</span>
                                            </label>
                                            <label class="radio-option">
                                                <input type="radio" name="indicator_shapes" id="indicator_off" value="0">
                                                <span class="radio-text">Off</span>
                                            </label>
                                        </div>
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            When On: 2 cells are reserved per row for start/end markers. When Off: all cells are available for text.
                                        </div>
                                    </fieldset>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Braille Spacing -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Braille Spacing</span>
                                <span class="expert-submenu-icon">G+</span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille Dimensions</label>
                                    <div>
                                        <label for="grid_columns" id="grid_columns_label">Number of Braille Cells (Characters):</label>
                                        <input type="number" id="grid_columns" name="grid_columns" value="13" style="width: 110px;">
                                        <div id="grid_columns_note" class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            For embossing plates: 2 cells are reserved for row indicators (start/end markers), leaving 13 cells available for text.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="grid_rows">Number of Braille Lines:</label>
                                        <input type="number" id="grid_rows" name="grid_rows" value="4" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cell_spacing">Braille Cell Spacing:</label>
                                        <input type="number" id="cell_spacing" name="cell_spacing" value="6.5" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="line_spacing">Braille Line Spacing:</label>
                                        <input type="number" id="line_spacing" name="line_spacing" value="10.0" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="dot_spacing">Braille Dot Spacing:</label>
                                        <input type="number" id="dot_spacing" name="dot_spacing" value="2.5" step="0.1" style="width: 110px;">
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille / Card Positioning</label>
                                    <div>
                                        <label for="braille_y_adjust">Y Adjust:</label>
                                        <input type="number" id="braille_y_adjust" name="braille_y_adjust" value="0.0" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="braille_x_adjust">X Adjust:</label>
                                        <input type="number" id="braille_x_adjust" name="braille_x_adjust" value="0.0" step="0.1" style="width: 110px;">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Braille Dot Adjustments -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Braille Dot Adjustments</span>
                                <span class="expert-submenu-icon">G+</span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection" id="rounded_dot_group" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Embossing Braille Dot Dimensions (Rounded Shape)</label>
                                    <div>
                                        <label for="rounded_dot_base_diameter">Rounded braille dot base diameter (cone base) (mm):</label>
                                        <input type="number" id="rounded_dot_base_diameter" name="rounded_dot_base_diameter" value="2.0" step="0.1" min="0.5" max="3" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_base_height">Rounded braille dot base height (cone height) (mm):</label>
                                        <input type="number" id="rounded_dot_base_height" name="rounded_dot_base_height" value="0.2" step="0.1" min="0" max="2.0" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_dome_diameter">Rounded braille dome diameter (linked to cone flat top) (mm):</label>
                                        <input type="number" id="rounded_dot_dome_diameter" name="rounded_dot_dome_diameter" value="1.5" step="0.1" min="0.5" max="3.0" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="rounded_dot_dome_height">Rounded braille dot dome height (mm):</label>
                                        <input type="number" id="rounded_dot_dome_height" name="rounded_dot_dome_height" value="0.6" step="0.1" min="0.1" max="2.0" style="width: 110px;">
                                    </div>
                                    <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                        The cone base sits on the surface; the dome grows from the cone's flat top. Dome diameter is always equal to the cone flat-top diameter.
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Embossing Braille Dot Dimensions (Cone Shape)</label>
                                    <div>
                                        <label for="emboss_dot_base_diameter">Dot diameter:</label>
                                        <input type="number" id="emboss_dot_base_diameter" name="emboss_dot_base_diameter" value="1.8" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="emboss_dot_height">Dot height:</label>
                                        <input type="number" id="emboss_dot_height" name="emboss_dot_height" value="1.0" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="emboss_dot_flat_hat">Flat hat diameter:</label>
                                        <input type="number" id="emboss_dot_flat_hat" name="emboss_dot_flat_hat" value="0.4" step="0.1" style="width: 110px;">
                                    </div>
                                </div>

                                <!-- Counter Braille Recessed Dot Dimensions (Rounded Shape) -->
                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Braille Recessed Dot Dimensions (Rounded Shape)</label>
                                    <!-- Hidden hemisphere dial for future use -->
                                    <div style="display: none;">
                                        <label for="hemi_counter_dot_base_diameter">Hemisphere Recess Dot Base Diameter (mm):</label>
                                        <input type="number" id="hemi_counter_dot_base_diameter" name="hemi_counter_dot_base_diameter" value="1.6" step="0.1" min="0.5" max="5">
                                    </div>
                                    <div id="hemisphere_dimensions_group" style="margin-top: 6px; display: none;">
                                        <div class="grade-note" style="font-size: 0.85em;">
                                            Hemisphere depth equals radius at the opening.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="bowl_counter_dot_base_diameter">Bowl Recess Dot Base Diameter (mm):</label>
                                        <input type="number" id="bowl_counter_dot_base_diameter" name="bowl_counter_dot_base_diameter" value="1.8" step="0.1" min="0.5" max="5" style="width: 110px;">
                                    </div>
                                    <div id="bowl_dimensions_group" style="margin-top: 6px;">
                                        <div>
                                            <label for="counter_dot_depth">Bowl Recess Dot Depth (mm):</label>
                                            <input type="number" id="counter_dot_depth" name="counter_dot_depth" value="0.8" step="0.1" min="0" max="5" style="width: 110px;">
                                        </div>
                                    </div>
                                </div>

                                <!-- Counter Braille Recessed Dot Dimensions (Cone Shape) -->
                                <div class="grade-selection" id="cone_dimensions_group" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Braille Recessed Dot Dimensions (Cone Shape)</label>
                                    <div>
                                        <label for="cone_counter_dot_base_diameter">Dot Base Diameter (mm):</label>
                                        <input type="number" id="cone_counter_dot_base_diameter" name="cone_counter_dot_base_diameter" value="1.6" step="0.1" min="0.1" max="5" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cone_counter_dot_height">Dot Height (mm):</label>
                                        <input type="number" id="cone_counter_dot_height" name="cone_counter_dot_height" value="0.8" step="0.1" min="0" max="5" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cone_counter_dot_flat_hat">Dot Flat Hat Diameter (mm):</label>
                                        <input type="number" id="cone_counter_dot_flat_hat" name="cone_counter_dot_flat_hat" value="0.4" step="0.1" min="0" max="5" style="width: 110px;">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Submenu: Surface Dimensions -->
                        <div class="expert-submenu">
                            <button type="button" class="expert-submenu-toggle" aria-expanded="false">
                                <span class="expert-submenu-title">Surface Dimensions</span>
                                <span class="expert-submenu-icon">G+</span>
                            </button>
                            <div class="expert-submenu-content" style="display: none;">
                                <div class="grade-selection">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Cylinder Dimensions</label>
                                    <div>
                                        <label for="cylinder_diameter_mm">Cylinder Diameter (mm):</label>
                                        <input type="number" id="cylinder_diameter_mm" name="cylinder_diameter_mm" value="30.75" step="0.1" min="10" max="200" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_height_mm">Cylinder Height (mm):</label>
                                        <input type="number" id="cylinder_height_mm" name="cylinder_height_mm" value="52" step="0.1" min="10" max="200" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_polygonal_cutout_radius_mm">Polygonal Cutout Circumscribed Radius (mm):</label>
                                        <input type="number" id="cylinder_polygonal_cutout_radius_mm" name="cylinder_polygonal_cutout_radius_mm" value="13" step="0.1" min="0" max="50" style="width: 110px;">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Creates a polygonal cutout along the cylinder's length. Set to 0 for no cutout.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="cylinder_polygonal_cutout_sides">Polygonal Cutout Points:</label>
                                        <input type="number" id="cylinder_polygonal_cutout_sides" name="cylinder_polygonal_cutout_sides" value="12" step="1" min="3" max="60" style="width: 110px;">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Lower values create simpler shapes (e.g., 6); higher values approximate a circle.
                                        </div>
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="seam_offset_deg">Seam Offset (degrees):</label>
                                        <input type="number" id="seam_offset_deg" name="seam_offset_deg" value="355" step="1" min="0" max="360" style="width: 110px;">
                                        <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                            Rotates the starting position of braille text around the cylinder
                                        </div>
                                    </div>
                                    <div id="cylinder-overflow-warning" class="grade-note" style="margin-top: 10px; color: #d73502; display: none;">
                                        <strong>Warning:</strong> <span id="cylinder-overflow-message"></span>
                                    </div>
                                </div>

                                <div class="grade-selection" style="margin-top: 8px;">
                                    <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Plate Dimensions</label>
                                    <div>
                                        <label for="card_width">Plate Width:</label>
                                        <input type="number" id="card_width" name="card_width" value="90" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="card_height">Plate Height:</label>
                                        <input type="number" id="card_height" name="card_height" value="52" step="0.1" style="width: 110px;">
                                    </div>
                                    <div style="margin-top: 6px;">
                                        <label for="card_thickness">Plate Thickness:</label>
                                        <input type="number" id="card_thickness" name="card_thickness" value="2.0" step="0.1" style="width: 110px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="button-group">
                        <!-- Test buttons removed as they are no longer needed -->
                    </div>
                </form>
            </div>
        </div>
    </div>
    

    
    <!-- Load the real liblouis JavaScript implementation from static files -->
    <script src="/static/liblouis/build-no-tables-utf16.js"></script>
    <script src="/static/liblouis/easy-api.js"></script>
    
    <script type="module">
        import * as THREE from '/static/three.module.js';
        import { STLLoader } from '/static/STLLoader.js';
        import { OrbitControls } from '/static/OrbitControls.js';
        async function loadLanguageOptions() {
            const select = document.getElementById('language-table');
            if (!select) return;

            // Preserve the four top U.S. English defaults (UEB and EBAE)
            const defaultValues = new Set(['en-ueb-g2.ctb', 'en-ueb-g1.ctb', 'en-us-g2.ctb', 'en-us-g1.ctb']);
            const defaultOptions = Array.from(select.querySelectorAll('option')).filter(o => defaultValues.has(o.value));

            // Clear existing and re-add defaults in an optgroup
            select.innerHTML = '';
            const defaultGroup = document.createElement('optgroup');
            defaultGroup.label = 'Default';
            defaultOptions.forEach(o => defaultGroup.appendChild(o));
            select.appendChild(defaultGroup);

            // Fetch available tables from backend
            let resp;
            try {
                resp = await fetch('/liblouis/tables', { credentials: 'same-origin' });
            } catch (e) {
                return; // Fail silently; defaults remain
            }
            if (!resp || !resp.ok) return;
            const data = await resp.json().catch(() => null);
            if (!data || !Array.isArray(data.tables)) return;

            // Build label for each entry (native-language autonyms)
            const otherGroup = document.createElement('optgroup');
            otherGroup.label = 'Other';

            const seen = new Set(defaultValues);
            const entries = data.tables.slice();

            // Sort: English first, then by locale and file name
            entries.sort((a, b) => {
                const aEn = (a.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                const bEn = (b.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                if (aEn !== bEn) return aEn - bEn;
                const al = (a.locale || '').toLowerCase();
                const bl = (b.locale || '').toLowerCase();
                if (al !== bl) return al < bl ? -1 : 1;
                const af = (a.file || '').toLowerCase();
                const bf = (b.file || '').toLowerCase();
                return af < bf ? -1 : af > bf ? 1 : 0;
            });

            // Name helpers using Intl.DisplayNames for correctness
            const getLanguageAutonym = (lang) => {
                try {
                    // Use the language's own locale to get its autonym
                    const dn = new Intl.DisplayNames([lang], { type: 'language' });
                    return dn.of(lang) || lang;
                } catch (e) {
                    // Fallback capitalization
                    return lang.charAt(0).toUpperCase() + lang.slice(1);
                }
            };

            const getLanguageEnglish = (lang) => {
                try {
                    const dn = new Intl.DisplayNames(['en'], { type: 'language' });
                    return dn.of(lang) || lang;
                } catch (e) {
                    return lang.charAt(0).toUpperCase() + lang.slice(1);
                }
            };

            const getRegionEnglish = (region) => {
                if (!region) return '';
                try {
                    const dn = new Intl.DisplayNames(['en'], { type: 'region' });
                    return dn.of(region) || region;
                } catch (e) {
                    return region;
                }
            };

            // Helper to get full display name: autonym first, then English
            const getDisplayName = (t) => {
                const locale = (t.locale || '').replace('_', '-');
                const parts = locale.split('-');
                const langCode = (parts[0] || 'und').toLowerCase();
                const region = parts[1] ? parts[1].toUpperCase() : '';

                const auto = getLanguageAutonym(langCode);
                const eng = getLanguageEnglish(langCode);
                const regionEng = getRegionEnglish(region);

                let displayName = auto === eng ? auto : `${auto} G ${eng}`;
                if (regionEng) displayName += `, ${regionEng}`;

                return displayName;
            };

            // Process entries
            const usedSemantic = new Set(); // Deduplicate by semantic identity (locale+variant+grade+type+dots)

            for (const t of entries) {
                const file = t.file;
                if (!file || seen.has(file)) continue;
                seen.add(file);

                // Get base language name
                let baseName = getDisplayName(t);
                
                // Build description parts
                const parts = [];
                
                // Grade/contraction info
                if (t.grade === '2') {
                    parts.push('contracted');
                } else if (t.grade === '1') {
                    parts.push('uncontracted');
                } else if (t.grade === '0') {
                    parts.push('computer');
                }
                
                // Type info
                if (t.type === 'computer' && !parts.includes('computer')) {
                    if (t.dots === 8) {
                        parts.push('8-dot computer');
                    } else {
                        parts.push('computer');
                    }
                } else if (t.type === 'literary' && t.contraction === 'full') {
                    if (!parts.includes('contracted')) {
                        parts.push('literary');
                    }
                }
                
                // Variant info (UEB, EBAE, etc)
                if (t.variant) {
                    parts.push(t.variant);
                }
                
                // Special naming for specific files
                if (file === 'en-ueb-g2.ctb') {
                    baseName = 'English (UEB), United States';
                    parts.length = 0;
                    parts.push('contracted', 'grade 2');
                } else if (file === 'en-ueb-g1.ctb') {
                    baseName = 'English (UEB), United States';
                    parts.length = 0;
                    parts.push('uncontracted', 'grade 1');
                } else if (file === 'en-us-g2.ctb') {
                    baseName = 'English (EBAE), United States';
                    parts.length = 0;
                    parts.push('contracted', 'grade 2');
                } else if (file === 'en-us-g1.ctb') {
                    baseName = 'English (EBAE), United States';
                    parts.length = 0;
                    parts.push('uncontracted', 'grade 1');
                } else if (file.includes('-comp')) {
                    if (!parts.includes('computer') && !parts.includes('8-dot computer')) {
                        parts.push('computer braille');
                    }
                }
                
                // Build final label
                let label = baseName;
                if (parts.length > 0) {
                    label += ` (${parts.join(', ')})`;
                }

                // Deduplicate by semantic identity to avoid near-duplicate entries
                const semanticKey = [
                    (t.locale || '').toLowerCase(),
                    (t.variant || '').toLowerCase(),
                    (t.grade || '').toString().toLowerCase(),
                    (t.type || '').toLowerCase(),
                    (t.dots == null ? '' : String(t.dots))
                ].join('|');
                if (usedSemantic.has(semanticKey)) {
                    continue; // Skip duplicates
                }
                usedSemantic.add(semanticKey);

                const opt = document.createElement('option');
                opt.value = file;
                opt.textContent = label;
                otherGroup.appendChild(opt);
            }

            select.appendChild(otherGroup);
            
            // Default to UEB grade 1 unless user has a saved preference (business card-friendly)
            try {
                const saved = localStorage.getItem('braille_prefs_language_table');
                const hasSaved = saved && Array.from(select.options).some(o => o.value === saved);
                select.value = hasSaved ? saved : 'en-ueb-g1.ctb';
            } catch (e) {
                select.value = 'en-ueb-g1.ctb';
            }
        }

        // Kick off language options load ASAP
        loadLanguageOptions().then(() => {
            try {
                const select = document.getElementById('language-table');
                // Force default to English (UEB) uncontracted grade 1 if available
                try {
                    const desiredDefault = 'en-ueb-g1.ctb';
                    const hasDesired = Array.from(select.options).some(o => o.value === desiredDefault);
                    if (hasDesired) select.value = desiredDefault;
                } catch (e) {}
                select.addEventListener('change', () => {
                    try { localStorage.setItem('braille_prefs_language_table', select.value); } catch (e) {}
                    // Keep per-line language dropdowns in sync with available options
                    try { syncLineLanguageSelects(); } catch (e) {}
                });
                // Populate per-line selects once options are loaded
                try { syncLineLanguageSelects(); } catch (e) {}
            } catch (e) {}
        });
        

        // Declare 3D scene variables at module scope
        let renderer, scene, camera, mesh, controls;
        let lastSTLUrl = null;
        
        // Production logging - only log errors in production
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        const log = {
            debug: isProduction ? () => {} : console.log,
            info: isProduction ? () => {} : console.log,
            error: console.error // Always log errors
        };

        // Theme switching functionality
        const themes = ['dark', 'high-contrast', 'light'];
        const themeIcons = {
            'dark': '=',
            'high-contrast': 'G',
            'light': '=P'
        };
        const themeNames = {
            'dark': 'Dark',
            'high-contrast': 'High Contrast',
            'light': 'Light'
        };
        
        let currentThemeIndex = 0;
        // Always start in dark mode; do not persist theme
        applyTheme('dark');

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');
            
            // Find the next theme in the cycle
            const currentIndex = themes.indexOf(theme);
            const nextIndex = (currentIndex + 1) % themes.length;
            const nextTheme = themes[nextIndex];
            
            // Show the next theme that will be applied when clicked
            themeIcon.textContent = themeIcons[nextTheme];
            themeText.textContent = themeNames[nextTheme];
            
            // Update aria-label to show current theme and what will happen next
            themeToggle.setAttribute('aria-label', `Current theme: ${themeNames[theme]}. Click to switch to ${themeNames[nextTheme]} theme`);
            
            // Announce theme change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Theme changed to ${themeNames[theme]}`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
            
            // Update 3D scene colors for new theme
            update3DSceneColors();
        }

        document.getElementById('theme-toggle').addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(themes[currentThemeIndex]);
        });

        // Function to update 3D scene colors when theme changes
        function update3DSceneColors() {
            if (typeof scene !== 'undefined' && scene && typeof renderer !== 'undefined' && renderer) {
                const styles = getComputedStyle(document.documentElement);
                const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
                const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
                const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
                const stlMeshColor = styles.getPropertyValue('--stl-mesh-color').trim() || '#6699cc';
                const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
                const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;
                
                // Update scene background
                scene.background = new THREE.Color(stlBackground);
                
                // Remove existing lights to rebuild them with proper configuration
                const sceneLightsToRemove = scene.children.filter(child => 
                    child instanceof THREE.DirectionalLight || child instanceof THREE.AmbientLight
                );
                sceneLightsToRemove.forEach(light => scene.remove(light));
                
                // Also remove camera-attached directional lights
                const cameraLightsToRemove = camera.children.filter(child => 
                    child instanceof THREE.DirectionalLight
                );
                cameraLightsToRemove.forEach(light => camera.remove(light));
                
                // Rebuild lighting based on current theme
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);
                
                if (currentTheme === 'high-contrast') {
                    // High contrast mode: conventional three-point lighting for better detail visibility
                    // Key light: 45- horizontal, 30- vertical (right side) - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);
                    
                    // Fill light: 45- horizontal, 15- vertical (left side) for shadow softening - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                    fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                    camera.add(fillLight);
                    
                    // Subtle back light for edge definition - camera-relative
                    const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                    backLight.position.set(0, 0.5, -0.866).normalize();
                    camera.add(backLight);
                } else {
                    // Standard lighting: conventional angle for optimal detail visibility
                    // Key light: 45- horizontal, 30- vertical - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);
                    
                    // Add subtle fill light for standard modes too - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                    fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                    camera.add(fillLight);
                }
                
                // Add ambient light
                scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));
                
                // Update mesh color and material properties if mesh exists
                if (mesh && mesh.material) {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    mesh.material.color = new THREE.Color(stlMeshColor);
                    
                    // Update specular properties for high contrast mode
                    if (currentTheme === 'high-contrast') {
                        mesh.material.specular = new THREE.Color(0xffffff); // White specular highlights
                        mesh.material.shininess = 300; // Higher shininess for sharper highlights
                    } else {
                        mesh.material.specular = new THREE.Color(0x111111); // Standard specular
                        mesh.material.shininess = 200; // Standard shininess
                    }
                    
                    mesh.material.needsUpdate = true;
                }
                
                // Force a re-render
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }
        }

        // Theme initialization is handled above in the main theme logic

        // Font size adjustment functionality
        const fontSizes = [75, 87.5, 100, 112.5, 125, 150, 175, 200];
        let currentFontSizeIndex = 2; // Start at 100%
        
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Always start at default 100%; do not persist font size
        currentFontSizeIndex = 2;
        
        function applyFontSize(sizeIndex) {
            const size = fontSizes[sizeIndex];
            document.documentElement.style.fontSize = size + '%';
            document.getElementById('current-font-size').textContent = size;
            currentFontSizeIndex = sizeIndex;
            
            // Announce font size change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Font size changed to ${size}%`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
        }
        
        // Initialize font size
        applyFontSize(currentFontSizeIndex);
        
        // Font size control event listeners
        document.getElementById('font-decrease').addEventListener('click', () => {
            if (currentFontSizeIndex > 0) {
                applyFontSize(currentFontSizeIndex - 1);
            }
        });
        
        document.getElementById('font-increase').addEventListener('click', () => {
            if (currentFontSizeIndex < fontSizes.length - 1) {
                applyFontSize(currentFontSizeIndex + 1);
            }
        });
        
        document.getElementById('font-reset').addEventListener('click', () => {
            applyFontSize(2); // Reset to 100%
        });

        const form = document.getElementById('braille-form');
        const viewer = document.getElementById('viewer');
        const actionBtn = document.getElementById('action-btn');
        let lastGeneratedSTLUrl = null;
        let lastGeneratedFilename = null;

        const previewBrailleBtn = document.getElementById('preview-braille-btn');
        const errorDiv = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        
        // Function to reset button to generate state
        function resetToGenerateState() {
            actionBtn.textContent = 'Generate STL';
            actionBtn.className = 'generate-state';
            actionBtn.setAttribute('data-state', 'generate');
            actionBtn.setAttribute('aria-label', 'Generate STL file from entered text');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }
        
        // Function to set button to download state
        function setToDownloadState() {
            actionBtn.textContent = 'Download STL';
            actionBtn.className = 'download-state';
            actionBtn.setAttribute('data-state', 'download');
            actionBtn.setAttribute('aria-label', 'Download generated STL file');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }
        
        // Store the current plate type for download naming
        let currentPlateType = 'positive';
        
        // Add event handler for the action button
        actionBtn.addEventListener('click', () => {
            if (actionBtn.getAttribute('data-state') === 'generate') {
                form.dispatchEvent(new Event('submit'));
            } else if (actionBtn.getAttribute('data-state') === 'download') {
                // Download the generated STL
                if (lastGeneratedSTLUrl) {
                    const a = document.createElement('a');
                    a.href = lastGeneratedSTLUrl;
                    // Use the filename generated on the frontend
                    if (lastGeneratedFilename) {
                        a.download = lastGeneratedFilename;
                    }
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }
        });
        const expertToggleBtn = document.getElementById('expert-toggle');
        const expertSettings = document.getElementById('expert-settings');
        const expertToggleText = document.getElementById('expert-toggle-text');
        const expertToggleIcon = document.getElementById('expert-toggle-icon');
        const braillePreview = document.getElementById('braille-preview');
        const previewContent = document.getElementById('preview-content');
        const infoToggleBtn = document.getElementById('info-toggle');
        const infoContent = document.getElementById('info-content');
        const infoToggleText = document.getElementById('info-toggle-text');
        const infoToggleIcon = document.getElementById('info-toggle-icon');



        // Add event listeners to reset button state when inputs change
        function addInputChangeListeners() {
            // Dynamic text input fields
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                if (input) {
                    // Remove existing listener to prevent duplicates
                    input.removeEventListener('input', resetToGenerateState);
                    input.addEventListener('input', resetToGenerateState);
                }
            }
            
            // Language selection
            const languageSelect = document.getElementById('language-table');
            if (languageSelect) {
                languageSelect.addEventListener('change', function() {
                    resetToGenerateState();
                });
            }
            
            // Function to update grid columns based on plate type (promoted to top-level scope below)
            function updateGridColumnsForPlateType(preserveValue = false) {
                const plateType = document.querySelector('input[name="plate_type"]:checked').value;
                const gridColumnsInput = document.getElementById('grid_columns');
                const gridColumnsLabel = document.getElementById('grid_columns_label');
                const gridColumnsNote = document.getElementById('grid_columns_note');
                const indicatorOn = document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';
                
                // Store current value before update
                const currentValue = parseInt(gridColumnsInput.value);
                
                if (plateType === 'positive') {
                    // Embossing plate - available cells depend on indicator toggle
                    gridColumnsLabel.textContent = 'Number of Available Braille Cells:';
                    gridColumnsNote.style.display = 'block';
                    gridColumnsNote.textContent = indicatorOn
                        ? 'For embossing plates: 2 cells are reserved for row indicators (start/end markers).'
                        : 'Indicators off: all columns are available for text.';
                    // Always normalize the dial to the recommended default to avoid drift
                    gridColumnsInput.value = indicatorOn ? '13' : '15';
                } else {
                    // Counter plate - available cells depend on indicator toggle
                    gridColumnsLabel.textContent = 'Available Braille Cells for Text:';
                    gridColumnsNote.textContent = indicatorOn
                        ? 'For counter plates: 2 cells are reserved for row indicators (start/end markers), leaving 13 cells available for text.'
                        : 'Indicators off: all columns are available for text.';
                    gridColumnsNote.style.display = 'block';
                    // Always normalize the dial to the recommended default to avoid drift
                    gridColumnsInput.value = indicatorOn ? '13' : '15';
                }
            }
            // Expose for other handlers safely
            try { window.updateGridColumnsForPlateType = updateGridColumnsForPlateType; } catch (e) {}
            
            // Plate type radio buttons
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateGridColumnsForPlateType();
                    const combinedShapeSel = document.getElementById('combined-shape-selection');
                    if (combinedShapeSel) { combinedShapeSel.style.display = 'block'; }
                    const roundedGroup = document.getElementById('rounded_dot_group');
                    if (roundedGroup) roundedGroup.style.display = '';
                    if (document.querySelector('input[name="placement_mode"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                });
            });
            
            // Initialize grid columns on page load
            updateGridColumnsForPlateType();
            // Wire indicator toggle listeners
            document.querySelectorAll('input[name="indicator_shapes"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateGridColumnsForPlateType(true);
                    if (document.querySelector('input[name=\"placement_mode\"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                });
            });
            
            // Shape type radio buttons
            document.querySelectorAll('input[name="shape_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                    if (document.querySelector('input[name=\"placement_mode\"]:checked')?.value === 'auto') {
                        computeAutoOverflow();
                    }
                    // Do not persist shape selection; always reset on reload
                });
            });
            // Plate type radio buttons (update dependent UI; recess controls always visible)
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                });
            });
            
            // Counter plate controls
            const hemiCounterBase = document.getElementById('hemi_counter_dot_base_diameter');
            const bowlCounterBase = document.getElementById('bowl_counter_dot_base_diameter');
            const counterDotDepth = document.getElementById('counter_dot_depth');
            const coneCounterBase = document.getElementById('cone_counter_dot_base_diameter');
            const coneCounterHeight = document.getElementById('cone_counter_dot_height');
            const coneCounterHat = document.getElementById('cone_counter_dot_flat_hat');
            if (hemiCounterBase) hemiCounterBase.addEventListener('input', resetToGenerateState);
            if (bowlCounterBase) bowlCounterBase.addEventListener('input', resetToGenerateState);
            if (counterDotDepth) counterDotDepth.addEventListener('input', resetToGenerateState);
            if (coneCounterBase) coneCounterBase.addEventListener('input', resetToGenerateState);
            if (coneCounterHeight) coneCounterHeight.addEventListener('input', resetToGenerateState);
            if (coneCounterHat) coneCounterHat.addEventListener('input', resetToGenerateState);

            // Combined shape selection - sets both emboss and counter shapes
            document.querySelectorAll('input[name="combined_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    resetToGenerateState();
                    const combinedVal = document.querySelector('input[name="combined_shape"]:checked')?.value || 'rounded';
                    const isRounded = combinedVal === 'rounded';
                    const isCone = combinedVal === 'cone';
                    
                    console.log('Combined shape changed to:', combinedVal, 'isRounded:', isRounded, 'isCone:', isCone);
                    
                    // Set emboss plate shape (dot_shape)
                    const dotShapeRadios = document.querySelectorAll('input[name="dot_shape"]');
                    dotShapeRadios.forEach(radio => {
                        if (isRounded && radio.value === 'rounded') {
                            radio.checked = true;
                            console.log('Set dot_shape to rounded');
                        }
                        if (isCone && radio.value === 'cone') {
                            radio.checked = true;
                            console.log('Set dot_shape to cone');
                        }
                    });
                    
                    // Set counter plate shape (recess_shape)
                    const recessShapeRadios = document.querySelectorAll('input[name="recess_shape"]');
                    recessShapeRadios.forEach(radio => {
                        if (isRounded && radio.value === '1') {
                            radio.checked = true; // Bowl (rounded)
                            console.log('Set recess_shape to 1 (bowl)');
                        }
                        if (isCone && radio.value === '2') {
                            radio.checked = true; // Cone
                            console.log('Set recess_shape to 2 (cone)');
                        }
                    });
                    
                    // Update dimension groups visibility
                    const bowlGroup = document.getElementById('bowl_dimensions_group');
                    const coneGroup = document.getElementById('cone_dimensions_group');
                    if (bowlGroup) bowlGroup.style.display = '';
                    if (coneGroup) coneGroup.style.display = '';
                    
                    // Debug: Log current values
                    const currentDotShape = document.querySelector('input[name="dot_shape"]:checked')?.value;
                    const currentRecessShape = document.querySelector('input[name="recess_shape"]:checked')?.value;
                    console.log('After sync - dot_shape:', currentDotShape, 'recess_shape:', currentRecessShape);
                });
            });
            
            // Expert mode parametric dials
            const expertInputs = [
                'emboss_dot_base_diameter',
                'emboss_dot_height', 
                'emboss_dot_flat_hat',
                'hemi_counter_dot_base_diameter',
                'bowl_counter_dot_base_diameter',
                'counter_dot_depth',
                'cone_counter_dot_base_diameter',
                'cone_counter_dot_height',
                'cone_counter_dot_flat_hat',
                // use_bowl_recess handled via radios
                'rounded_dot_base_diameter',
                'rounded_dot_cylinder_height',
                'rounded_dot_base_height',
                'rounded_dot_dome_diameter',
                'rounded_dot_dome_height',
                'grid_columns',
                'grid_rows',
                'cell_spacing',
                'line_spacing',
                'dot_spacing',
                'card_width',
                'card_height',
                'card_thickness',
                'braille_x_adjust',
                'braille_y_adjust',
                // Custom: indicator shapes toggle changes available cells view
                'indicator_shapes'
            ];
            
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        if (inputId === 'indicator_shapes') {
                            updateGridColumnsForPlateType(true);
                        }
                    });
                }
            });
            
            // Cylinder parameter inputs
            const cylinderInputs = [
                'cylinder_diameter_mm',
                'cylinder_height_mm',
                'cylinder_polygonal_cutout_radius_mm',
                'cylinder_polygonal_cutout_sides',
                'seam_offset_deg'
            ];
            
            cylinderInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        checkCylinderOverflow();
                    });
                }
            });
        }
        
        // Function to show/hide cylinder settings based on shape selection
        function updateShapeSettings() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement) {
                console.warn('No shape type selected');
                return;
            }
            const shapeType = shapeTypeElement.value;
            const cylinderSettings = document.querySelector('.grade-selection:has(#cylinder_diameter_mm)');
            
            // Always show cylinder dimensions in expert mode
            if (cylinderSettings) {
                cylinderSettings.style.display = 'block';
            }
            // Recess controls always visible; toggle sub-groups by chosen recess
            const recessSel = document.getElementById('recess-shape-selection');
            const recessValInit = document.querySelector('input[name="recess_shape"]:checked')?.value || '1';
            const isBowl = recessValInit === '1';
            const isCone = recessValInit === '2';
            if (recessSel) recessSel.style.display = '';
            const bowlGroup = document.getElementById('bowl_dimensions_group');
            const hemiGroup = document.getElementById('hemisphere_dimensions_group');
            const coneGroup = document.getElementById('cone_dimensions_group');
            if (bowlGroup) bowlGroup.style.display = '';
            if (hemiGroup) hemiGroup.style.display = 'none';
            if (coneGroup) coneGroup.style.display = '';
            
            // Initialize cylinder height with current card height when cylinder is selected
            if (shapeType === 'cylinder') {
                const cardHeight = document.getElementById('card_height').value;
                const cylinderHeightInput = document.getElementById('cylinder_height_mm');
                if (cylinderHeightInput) {
                    cylinderHeightInput.value = cardHeight;
                }
                checkCylinderOverflow();
            }
        }
        
        // Function to check cylinder text overflow
        function checkCylinderOverflow() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement || shapeTypeElement.value !== 'cylinder') return;
            const shapeType = shapeTypeElement.value;
            
            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const dotSpacing = parseFloat(document.getElementById('dot_spacing').value) || 2.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;
            
            // Calculate how many cells fit around circumference
            // cellSpacing is the center-to-center distance between cells
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);
            
            // Calculate how many rows fit on cylinder
            const rowsOnCylinder = Math.floor(height / lineSpacing);
            
            // Get total cells needed from text
            const lines = getDynamicLineValues();
            let totalCellsNeeded = 0;
            lines.forEach(line => {
                if (line.trim()) {
                    totalCellsNeeded += line.trim().length;
                }
            });
            
            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;
            
            const warningDiv = document.getElementById('cylinder-overflow-warning');
            const warningMessage = document.getElementById('cylinder-overflow-message');
            
            if (totalCellsNeeded > totalCellsAvailable) {
                warningMessage.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        }

        // Function to create dynamic line inputs based on grid_rows value
        function createDynamicLineInputs(numLines) {
            const container = document.getElementById('dynamic-line-inputs');
            container.innerHTML = ''; // Clear existing inputs
            
            for (let i = 1; i <= numLines; i++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'line-input';
                lineDiv.innerHTML = `
                    <div class="line-translation-row">
                        <label for="line_lang_${i}" class="line-label">Line ${i} Translation</label>
                        <select id="line_lang_${i}" name="line_lang_${i}" class="language-select line-language-select" aria-describedby="line${i}-lang-help"></select>
                        <span id="line${i}-lang-help" class="sr-only">Select translation language for line ${i}</span>
                    </div>
                    <div class="line-text-row">
                        <label for="line${i}" class="line-label">Line ${i}</label>
                        <input type="text" id="line${i}" name="line${i}" placeholder="Enter English text here..." maxlength="50" aria-describedby="line${i}-help">
                        <span id="line${i}-help" class="sr-only">Maximum 50 characters for line ${i}</span>
                    </div>
                `;
                container.appendChild(lineDiv);
            }
            
            // Populate per-line language selects with available options
            syncLineLanguageSelects();
            
            // Re-add event listeners for the new inputs
            addInputChangeListeners();
        }

        // Populate all per-line language selects from the master language-table options
        function syncLineLanguageSelects() {
            const master = document.getElementById('language-table');
            if (!master) return;
            const optionsHTML = master.innerHTML;
            const masterValue = master.value;
            document.querySelectorAll('.line-language-select').forEach(sel => {
                const previous = sel.value;
                sel.innerHTML = optionsHTML;
                // Prefer keeping prior choice; otherwise prefer English UEB Grade 1; otherwise fallback to master
                const hasPrev = previous && Array.from(sel.options).some(o => o.value === previous);
                const desiredDefault = 'en-ueb-g1.ctb';
                const hasDesired = Array.from(sel.options).some(o => o.value === desiredDefault);
                sel.value = hasPrev ? previous : (hasDesired ? desiredDefault : masterValue);
            });
        }

        // Function to collect all dynamic line values
        function getDynamicLineValues() {
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            const lines = [];
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                lines.push(input ? input.value : '');
            }
            return lines;
        }

        // When in auto mode, show overall overflow for cylinders too
        const cylinderOverflowDiv = document.getElementById('cylinder-overflow-warning');
        const cylinderOverflowMsg = document.getElementById('cylinder-overflow-message');
        const originalCheckCylinderOverflow = checkCylinderOverflow;
        checkCylinderOverflow = function() {
            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            if (placementMode === 'manual') {
                return originalCheckCylinderOverflow();
            }
            // Auto mode: compute based on auto text
            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);
            const rowsOnCylinder = Math.floor(height / lineSpacing);
            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;
            const src = (document.getElementById('auto-text')?.value || '').trim();
            if (!src) {
                cylinderOverflowDiv.style.display = 'none';
                return;
            }
            // Translate then compare
            translateWithLiblouis(src, 'g2', document.getElementById('language-table')?.value || 'en-ueb-g1.ctb')
                .then(braille => {
                    const totalCellsNeeded = braille.length;
                    if (totalCellsNeeded > totalCellsAvailable) {
                        cylinderOverflowMsg.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                        cylinderOverflowDiv.style.display = 'block';
                    } else {
                        cylinderOverflowDiv.style.display = 'none';
                    }
                })
                .catch(() => {
                    // Ignore
                });
        };

        // Function to add listener for grid_rows changes
        function addGridRowsListener() {
            const gridRowsInput = document.getElementById('grid_rows');
            if (gridRowsInput) {
                gridRowsInput.addEventListener('input', () => {
                    const numLines = parseInt(gridRowsInput.value) || 4;
                    // Enforce only a minimum of 1 line; no artificial upper bound
                    const safeLines = Math.max(1, numLines);
                    if (safeLines !== numLines) {
                        gridRowsInput.value = safeLines;
                    }
                    createDynamicLineInputs(safeLines);
                    resetToGenerateState();
                });
            }
        }
        
        // Initialize dynamic line inputs and listeners (force default 4 on first load)
        const gridRowsEl = document.getElementById('grid_rows');
        if (gridRowsEl) gridRowsEl.value = '4';
        createDynamicLineInputs(4);
        addInputChangeListeners();
        addGridRowsListener();

        // Placement mode logic
        const placementRadios = document.querySelectorAll('input[name="placement_mode"]');
        const autoContainer = document.getElementById('auto-input-container');
        const dynamicContainer = document.getElementById('dynamic-line-inputs');
        const autoText = document.getElementById('auto-text');
        const autoWarning = document.getElementById('auto-overflow-warning');
        const autoWarningMsg = document.getElementById('auto-overflow-message');

        function isIndicatorsOn() {
            return document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';
        }

        function getAvailableColumns() {
            const gridColumnsValue = parseInt(document.getElementById('grid_columns').value) || 15;
            // The UI dial shows usable text cells; use it directly for wrapping
            return gridColumnsValue;
        }

        function getTotalCellsAvailable() {
            const rows = parseInt(document.getElementById('grid_rows').value) || 4;
            const cols = getAvailableColumns();
            return rows * cols;
        }

        function updatePlacementUI() {
            const mode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            if (mode === 'auto') {
                autoContainer.style.display = '';
                dynamicContainer.style.display = 'none';
            } else {
                autoContainer.style.display = 'none';
                dynamicContainer.style.display = '';
                // Ensure per-line language selects are populated when switching to manual
                syncLineLanguageSelects();
            }
            resetToGenerateState();
        }

        placementRadios.forEach(r => r.addEventListener('change', () => {
            updatePlacementUI();
        }));

        // Update UI on relevant changes to show/compute warnings
        ['grid_rows','grid_columns','cell_spacing','line_spacing','cylinder_diameter_mm','cylinder_height_mm','indicator_shapes']
            .forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        if (document.querySelector('input[name="placement_mode"]:checked')?.value === 'auto') {
                            computeAutoOverflow();
                        }
                    });
                }
            });

        async function computeAutoOverflow() {
            autoWarning.style.display = 'none';
            autoWarningMsg.textContent = '';
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect?.value || 'en-ueb-g1.ctb';
            const src = (autoText?.value || '').trim();
            if (!src) return;
            try {
                const braille = await translateWithLiblouis(src, 'g2', tableName);
                const totalCellsNeeded = braille.length;
                const totalCellsAvailable = getTotalCellsAvailable();
                if (totalCellsNeeded > totalCellsAvailable) {
                    const over = totalCellsNeeded - totalCellsAvailable;
                    autoWarningMsg.textContent = `Your text exceeds the number of available braille cells by ${over} cells.`;
                    autoWarning.style.display = 'block';
                }
            } catch (e) {
                // Ignore preview warning if translation not available
            }
        }

        if (autoText) {
            autoText.addEventListener('input', () => {
                resetToGenerateState();
                computeAutoOverflow();
            });
        }

        // Initialize placement UI
        updatePlacementUI();
        
        // Persistence: save and restore user settings
        function persistValue(key, value) {
            try { localStorage.setItem(key, value); } catch (e) {}
        }
        function readPersisted(key) {
            try { return localStorage.getItem(key); } catch (e) { return null; }
        }
        function clearAllPersistence() {
            const keys = [
                'braille_prefs_language_table',
                'braille_prefs_plate_type',
                'braille_prefs_shape_type',
                'braille_prefs_dot_shape',
                'braille_prefs_expert_visible',
                'braille_prefs_grid_columns',
                'braille_prefs_grid_rows',
                'braille_prefs_cell_spacing',
                'braille_prefs_line_spacing',
                'braille_prefs_dot_spacing',
                'braille_prefs_card_width',
                'braille_prefs_card_height',
                'braille_prefs_card_thickness',
                'braille_prefs_braille_x_adjust',
                'braille_prefs_braille_y_adjust',
                'braille_prefs_emboss_dot_base_diameter',
                'braille_prefs_emboss_dot_height',
                'braille_prefs_emboss_dot_flat_hat',
                'braille_prefs_hemi_counter_dot_base_diameter',
                'braille_prefs_bowl_counter_dot_base_diameter',
                'braille_prefs_counter_dot_depth',
                'braille_prefs_use_bowl_recess', // legacy
                'braille_prefs_recess_shape',
                'braille_prefs_cone_counter_dot_base_diameter',
                'braille_prefs_cone_counter_dot_height',
                'braille_prefs_cone_counter_dot_flat_hat',
                'braille_prefs_rounded_dot_base_diameter',
                'braille_prefs_rounded_dot_base_height',
                'braille_prefs_rounded_dot_dome_diameter',
                'braille_prefs_rounded_dot_dome_height',
                'braille_prefs_cylinder_diameter_mm',
                'braille_prefs_cylinder_height_mm',
                'braille_prefs_cylinder_polygonal_cutout_radius_mm',
                'braille_prefs_cylinder_polygonal_cutout_sides',
                'braille_prefs_seam_offset_deg'
            ];
            keys.forEach(k => { try { localStorage.removeItem(k); } catch (e) {} });
        }
        
        function applyPersistedSettings() {
            // Plate type
            const savedPlate = readPersisted('braille_prefs_plate_type');
            if (savedPlate === 'positive' || savedPlate === 'negative') {
                const radio = document.querySelector(`input[name="plate_type"][value="${savedPlate}"]`);
                if (radio) radio.checked = true;
            }
            // Shape type
            const savedShape = readPersisted('braille_prefs_shape_type');
            if (savedShape === 'card' || savedShape === 'cylinder') {
                const radio = document.querySelector(`input[name="shape_type"][value="${savedShape}"]`);
                if (radio) radio.checked = true;
            }
            // Dot shape
            const savedDot = readPersisted('braille_prefs_dot_shape');
            if (savedDot === 'cone' || savedDot === 'rounded') {
                const radio = document.querySelector(`input[name="dot_shape"][value="${savedDot}"]`);
                if (radio) radio.checked = true;
            }
            // Combined shape - initialize based on saved dot shape or default to rounded
            const savedCombined = readPersisted('braille_prefs_combined_shape') || savedDot || 'rounded';
            if (savedCombined === 'cone' || savedCombined === 'rounded') {
                const radio = document.querySelector(`input[name="combined_shape"][value="${savedCombined}"]`);
                if (radio) radio.checked = true;
                
                console.log('Initializing combined shape to:', savedCombined);
                
                // Sync individual values for backend compatibility
                const dotShapeRadios = document.querySelectorAll('input[name="dot_shape"]');
                const recessShapeRadios = document.querySelectorAll('input[name="recess_shape"]');
                
                if (savedCombined === 'rounded') {
                    dotShapeRadios.forEach(r => { if (r.value === 'rounded') r.checked = true; });
                    recessShapeRadios.forEach(r => { if (r.value === '1') r.checked = true; }); // Bowl
                    console.log('Initialized to rounded - dot_shape: rounded, recess_shape: 1');
                } else if (savedCombined === 'cone') {
                    dotShapeRadios.forEach(r => { if (r.value === 'cone') r.checked = true; });
                    recessShapeRadios.forEach(r => { if (r.value === '2') r.checked = true; }); // Cone
                    console.log('Initialized to cone - dot_shape: cone, recess_shape: 2');
                }
            }
            // Expert visibility
            const savedExpert = readPersisted('braille_prefs_expert_visible');
            if (savedExpert === 'true' || savedExpert === 'false') {
                const visible = savedExpert === 'true';
                expertSettings.style.display = visible ? 'block' : 'none';
                expertToggleText.textContent = visible ? 'Hide Expert Mode' : 'Show Expert Mode';
                expertToggleIcon.textContent = visible ? 'G' : 'G+';
                expertToggleBtn.classList.toggle('active', visible);
            }
            // Numeric/text inputs
            const map = [
                ['cell_spacing','braille_prefs_cell_spacing'],
                ['line_spacing','braille_prefs_line_spacing'],
                ['dot_spacing','braille_prefs_dot_spacing'],
                ['card_width','braille_prefs_card_width'],
                ['card_height','braille_prefs_card_height'],
                ['card_thickness','braille_prefs_card_thickness'],
                ['braille_x_adjust','braille_prefs_braille_x_adjust'],
                ['braille_y_adjust','braille_prefs_braille_y_adjust'],
                ['emboss_dot_base_diameter','braille_prefs_emboss_dot_base_diameter'],
                ['emboss_dot_height','braille_prefs_emboss_dot_height'],
                ['emboss_dot_flat_hat','braille_prefs_emboss_dot_flat_hat'],
                ['hemi_counter_dot_base_diameter','braille_prefs_hemi_counter_dot_base_diameter'],
                ['bowl_counter_dot_base_diameter','braille_prefs_bowl_counter_dot_base_diameter'],
                ['counter_dot_depth','braille_prefs_counter_dot_depth'],
                ['cone_counter_dot_base_diameter','braille_prefs_cone_counter_dot_base_diameter'],
                ['cone_counter_dot_height','braille_prefs_cone_counter_dot_height'],
                ['cone_counter_dot_flat_hat','braille_prefs_cone_counter_dot_flat_hat'],
                ['recess_shape','braille_prefs_recess_shape'],
                ['rounded_dot_base_diameter','braille_prefs_rounded_dot_base_diameter'],
                ['rounded_dot_base_height','braille_prefs_rounded_dot_base_height'],
                ['rounded_dot_dome_diameter','braille_prefs_rounded_dot_dome_diameter'],
                ['rounded_dot_dome_height','braille_prefs_rounded_dot_dome_height'],
                ['cylinder_diameter_mm','braille_prefs_cylinder_diameter_mm'],
                ['cylinder_height_mm','braille_prefs_cylinder_height_mm'],
                ['cylinder_polygonal_cutout_radius_mm','braille_prefs_cylinder_polygonal_cutout_radius_mm'],
                ['cylinder_polygonal_cutout_sides','braille_prefs_cylinder_polygonal_cutout_sides'],
                ['seam_offset_deg','braille_prefs_seam_offset_deg']
            ];
            map.forEach(([id,key]) => {
                const v = readPersisted(key);
                if (v !== null && v !== undefined) {
                    const el = document.getElementById(id);
                    if (el) el.value = v;
                }
            });
            // Restore recess shape selection (default to Bowl when no saved value)
            const savedRecessShape = readPersisted('braille_prefs_recess_shape');
            if (savedRecessShape === '0' || savedRecessShape === '1' || savedRecessShape === '2') {
                const r = document.querySelector(`input[name="recess_shape"][value="${savedRecessShape}"]`);
                if (r) r.checked = true;
            } else {
                const r = document.querySelector('input[name="recess_shape"][value="1"]');
                if (r) r.checked = true;
            }
            // grid_columns handled last to avoid preserve conversion
            const savedCols = readPersisted('braille_prefs_grid_columns');
            updateShapeSettings();
            updateGridColumnsForPlateType(true);
            if (savedCols !== null && savedCols !== undefined) {
                const gridColsEl = document.getElementById('grid_columns');
                if (gridColsEl) gridColsEl.value = savedCols;
            }
            // Recreate dynamic line inputs in case grid_rows changed
            const numLines = parseInt(document.getElementById('grid_rows').value) || 4;
            createDynamicLineInputs(numLines);
        }
        
        function wirePersistenceListeners() {
            // Plate type
            document.querySelectorAll('input[name="plate_type"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_plate_type', document.querySelector('input[name="plate_type"]:checked').value));
            });
            // Shape type
            document.querySelectorAll('input[name="shape_type"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_shape_type', document.querySelector('input[name="shape_type"]:checked').value));
            });
            // Dot shape (now handled by combined shape)
            document.querySelectorAll('input[name="dot_shape"]').forEach(r => {
                r.addEventListener('change', () => persistValue('braille_prefs_dot_shape', document.querySelector('input[name="dot_shape"]:checked').value));
            });
            // Combined shape (new primary control)
            document.querySelectorAll('input[name="combined_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    const val = document.querySelector('input[name="combined_shape"]:checked')?.value || 'rounded';
                    persistValue('braille_prefs_combined_shape', val);
                    // Also persist the individual values for backend compatibility
                    persistValue('braille_prefs_dot_shape', val);
                    persistValue('braille_prefs_recess_shape', val === 'rounded' ? '1' : '2');
                });
            });
            // Expert visibility
            expertToggleBtn.addEventListener('click', () => {
                const isVisible = expertSettings.style.display !== 'none';
                // After toggle above, visibility will invert; persist the next state
                const nextVisible = !isVisible;
                persistValue('braille_prefs_expert_visible', String(nextVisible));
            });
            // Numeric/text inputs
            const map = [
                ['grid_columns','braille_prefs_grid_columns'],
                ['cell_spacing','braille_prefs_cell_spacing'],
                ['line_spacing','braille_prefs_line_spacing'],
                ['dot_spacing','braille_prefs_dot_spacing'],
                ['card_width','braille_prefs_card_width'],
                ['card_height','braille_prefs_card_height'],
                ['card_thickness','braille_prefs_card_thickness'],
                ['braille_x_adjust','braille_prefs_braille_x_adjust'],
                ['braille_y_adjust','braille_prefs_braille_y_adjust'],
                ['emboss_dot_base_diameter','braille_prefs_emboss_dot_base_diameter'],
                ['emboss_dot_height','braille_prefs_emboss_dot_height'],
                ['emboss_dot_flat_hat','braille_prefs_emboss_dot_flat_hat'],
                ['hemi_counter_dot_base_diameter','braille_prefs_hemi_counter_dot_base_diameter'],
                ['bowl_counter_dot_base_diameter','braille_prefs_bowl_counter_dot_base_diameter'],
                ['counter_dot_depth','braille_prefs_counter_dot_depth'],
                ['cone_counter_dot_base_diameter','braille_prefs_cone_counter_dot_base_diameter'],
                ['cone_counter_dot_height','braille_prefs_cone_counter_dot_height'],
                ['cone_counter_dot_flat_hat','braille_prefs_cone_counter_dot_flat_hat'],
                ['recess_shape','braille_prefs_recess_shape'],
                ['rounded_dot_base_diameter','braille_prefs_rounded_dot_base_diameter'],
                ['rounded_dot_base_height','braille_prefs_rounded_dot_base_height'],
                ['rounded_dot_dome_diameter','braille_prefs_rounded_dot_dome_diameter'],
                ['rounded_dot_dome_height','braille_prefs_rounded_dot_dome_height'],
                ['cylinder_diameter_mm','braille_prefs_cylinder_diameter_mm'],
                ['cylinder_height_mm','braille_prefs_cylinder_height_mm'],
                ['cylinder_polygonal_cutout_radius_mm','braille_prefs_cylinder_polygonal_cutout_radius_mm'],
                ['cylinder_polygonal_cutout_sides','braille_prefs_cylinder_polygonal_cutout_sides'],
                ['seam_offset_deg','braille_prefs_seam_offset_deg']
            ];
            map.forEach(([id,key]) => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => persistValue(key, el.value));
                }
            });
            // Recess shape radio persistence (now handled by combined shape)
            document.querySelectorAll('input[name="recess_shape"]').forEach(r => {
                r.addEventListener('change', () => {
                    const val = document.querySelector('input[name="recess_shape"]:checked')?.value || '1';
                    persistValue('braille_prefs_recess_shape', val);
                });
            });
        }
        
        // On load, restore persisted settings, then wire listeners
        try { applyPersistedSettings(); } catch (e) {}
        try { wirePersistenceListeners(); } catch (e) {}

        // Reset to defaults button
        const resetBtn = document.getElementById('reset-defaults-btn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                clearAllPersistence();
                // Reset selects to their default option values
                const selectEls = Array.from(document.querySelectorAll('select'));
                selectEls.forEach(sel => { sel.value = sel.options[0]?.value || sel.defaultValue; });
                // Ensure language resets to UEB Grade 1
                try {
                    const langSelect = document.getElementById('language-table');
                    if (langSelect) {
                        langSelect.value = 'en-ueb-g1.ctb';
                        try { localStorage.setItem('braille_prefs_language_table', 'en-ueb-g1.ctb'); } catch (e) {}
                    }
                } catch (e) {}
                // Reset radio groups to defaultChecked
                const radioGroups = new Map();
                document.querySelectorAll('input[type="radio"]').forEach(r => {
                    if (!radioGroups.has(r.name)) radioGroups.set(r.name, []);
                    radioGroups.get(r.name).push(r);
                });
                radioGroups.forEach(group => {
                    const def = group.find(r => r.defaultChecked);
                    if (def) def.checked = true;
                });
                // Reset all inputs to their defaultValue
                document.querySelectorAll('input[type="number"], input[type="text"]').forEach(inp => {
                    if (inp.defaultValue !== undefined) inp.value = inp.defaultValue;
                });
                // Expert visibility default (hidden)
                expertSettings.style.display = 'none';
                expertToggleText.textContent = 'Show Expert Mode';
                expertToggleIcon.textContent = 'G+';
                expertToggleBtn.classList.remove('active');
                updateShapeSettings();
                updateGridColumnsForPlateType();
                checkCylinderOverflow();
                resetToGenerateState();

                // Inform the user to refresh the page to fully reset preview and state
                try {
                    errorText.textContent = 'Settings reset to defaults. Please refresh the page to fully reset and clear the preview.';
                    errorDiv.style.display = 'flex';
                    errorDiv.className = 'error-message info';
                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                        errorDiv.className = 'error-message';
                    }, 5000);
                } catch (e) { /* ignore */ }
            });
        }
        
        // Initialize shape settings to show/hide cylinder parameters correctly
        updateShapeSettings();

        expertToggleBtn.addEventListener('click', () => {
            const isVisible = expertSettings.style.display !== 'none';
            expertSettings.style.display = isVisible ? 'none' : 'block';
            expertToggleText.textContent = isVisible ? 'Show Expert Mode' : 'Hide Expert Mode';
            expertToggleIcon.textContent = isVisible ? 'G+' : 'G';
            expertToggleBtn.classList.toggle('active', !isVisible);
        });

        // Dot shape radio buttons
        document.querySelectorAll('input[name="dot_shape"]').forEach(radio => {
            radio.addEventListener('change', function() {
                resetToGenerateState();
            });
        });

        // Removed redundant toggle-dot-shape button

        infoToggleBtn.addEventListener('click', () => {
            const isVisible = infoContent.style.display !== 'none';
            infoContent.style.display = isVisible ? 'none' : 'block';
                                        infoToggleText.textContent = isVisible ? 'More Info' : 'Hide Information';
            infoToggleIcon.textContent = isVisible ? 'G+' : 'G';
            infoToggleBtn.classList.toggle('active', !isVisible);
        });

        // Wire Expert submenus (expand/collapse)
        (function initExpertSubmenus() {
            const submenuToggles = Array.from(document.querySelectorAll('.expert-submenu-toggle'));
            submenuToggles.forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const content = toggle.parentElement?.querySelector('.expert-submenu-content');
                    if (!content) return;
                    const isOpen = content.style.display !== 'none';
                    content.style.display = isOpen ? 'none' : 'block';
                    toggle.classList.toggle('active', !isOpen);
                    toggle.setAttribute('aria-expanded', String(!isOpen));
                    const icon = toggle.querySelector('.expert-submenu-icon');
                    if (icon) icon.textContent = isOpen ? 'G+' : 'G';
                });
            });
        })();

        // Add real-time debugging for Expert Mode parametric dials
        const expertInputs = [
            'emboss_dot_base_diameter',
            'emboss_dot_height', 
            'emboss_dot_flat_hat',
            'hemi_counter_dot_base_diameter',
            'bowl_counter_dot_base_diameter',
            'counter_dot_depth',
            'grid_columns',
            'grid_rows',
            'cell_spacing',
            'line_spacing',
            'dot_spacing',
            'card_width',
            'card_height',
            'card_thickness',
            'braille_x_adjust',
            'braille_y_adjust',
            'cylinder_diameter_mm',
            'cylinder_height_mm',
            'cylinder_polygonal_cutout_radius_mm',
            'cylinder_polygonal_cutout_sides',
            'seam_offset_deg'
        ];
        
        expertInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', (e) => {
                    log.debug(`Expert Mode Input Changed: ${inputId} = ${e.target.value}`);
                    
                    // If grid_columns changed, update the label/note but preserve the value
                    if (inputId === 'grid_columns') {
                        updateGridColumnsForPlateType(true);
                    }
                });
                
                // Also log the initial values
                log.debug(`Initial value for ${inputId}: ${input.value}`);
            }
        });
        // Log initial recess shape radio value too
        (function logInitialRecessShape() {
            const v = document.querySelector('input[name="use_bowl_recess"]:checked')?.value;
            if (v !== undefined) {
                log.debug('Initial value for use_bowl_recess:', v);
            }
        })();
        
        // Function to get current Expert Mode values
        window.getCurrentExpertModeValues = function() {
            const values = {};
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    values[inputId] = input.value;
                }
            });
            return values;
        };

        // Convert a unicode braille string to computer shorthand tokens with brief indicators
        function brailleToComputerShorthand(brailleStr) {
            // Common UEB contractions and indicators
            const contractionMap = {
                'G': 'ch',
                'G': 'sh',
                'G': 'th',
                'G': 'wh',
                'G': 'ed',
                'G+': 'er',
                'G': 'ou',
                'G': 'ow',
                'G': 'ar',
                'G': 'ing',
                'G': 'en',
                'G': 'in',
                'G': 'st',
                'G': 'the',
                'G': 'and',
                'G+': 'of',
                'G+': 'for',
                'G+': 'with'
            };

            const indicatorMap = {
                'G': '[Capital Symbol]',
                'G+': '[Number Symbol]'
            };

            const punctuationMap = {
                'G': ',',
                'G': ';',
                'G': ':',
                'G': '.',
                'G': '!',
                'G': '?',
                'G': '-',
                'G': '\''
            };

            const letterMap = {
                'G':'a','G':'b','G':'c','G':'d','G':'e','G':'f','G':'g','G':'h','G':'i','G':'j',
                'G':'k','G':'l','G':'m','G':'n','G':'o','G':'p','G':'q','G':'r','G':'s','GP':'t',
                'G':'u','G':'v','G':'w','G':'x','G+':'y','G':'z'
            };

            const digitMap = {
                'G':'1','G':'2','G':'3','G':'4','G':'5','G':'6','G':'7','G':'8','G':'9','G':'0'
            };

            let result = '';
            let numericMode = false;
            let pendingWordGap = false;

            for (const ch of brailleStr) {
                if (ch === ' ') {
                    // Word boundary
                    numericMode = false;
                    pendingWordGap = true;
                    continue;
                }

                if (indicatorMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += indicatorMap[ch];
                    pendingWordGap = false;
                    if (ch === 'G+') numericMode = true;
                    continue;
                }

                if (contractionMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += `[${contractionMap[ch]}]`;
                    pendingWordGap = false;
                    // contractions end numeric mode
                    numericMode = false;
                    continue;
                }

                if (numericMode && digitMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += digitMap[ch];
                    pendingWordGap = false;
                    continue;
                }

                if (letterMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += letterMap[ch];
                    pendingWordGap = false;
                    // letters in numeric mode that are not digits will end numeric mode
                    numericMode = false;
                    continue;
                }

                if (punctuationMap[ch]) {
                    if (result.length > 0) {
                        result += pendingWordGap ? '  ' : ' ';
                    }
                    result += punctuationMap[ch];
                    pendingWordGap = false;
                    numericMode = false;
                    continue;
                }

                // Fallback: show the braille cell itself
                if (result.length > 0) {
                    result += pendingWordGap ? '  ' : ' ';
                }
                result += ch;
                pendingWordGap = false;
                numericMode = false;
            }

            return result;
        }

        // Preview braille translation using real liblouis (supports manual and auto placement)
        previewBrailleBtn.addEventListener('click', async () => {
            // Reset button state when previewing (user is making changes)
            resetToGenerateState();

            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect.value;

            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            errorDiv.style.display = 'none';
            let previewHTML = '';

            if (placementMode === 'manual') {
                const lines = getDynamicLineValues();
                if (lines.every(line => !line.trim())) {
                    errorText.textContent = 'Please enter text in at least one line.';
                    errorDiv.style.display = 'flex';
                    return;
                }
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        try {
                            const perLineTable = (document.getElementById(`line_lang_${i+1}`)?.value) || tableName;
                            const braille = await translateWithLiblouis(lines[i].trim(), 'g2', perLineTable);
                            const shorthand = brailleToComputerShorthand(braille);
                            previewHTML += `<div class="preview-line-success">
                                <div><strong>Line ${i + 1}:</strong> "${lines[i].trim()}" G "${braille}"</div>
                                <div class="preview-subline">Computer shorthand: "${shorthand}"</div>
                            </div>`;
                        } catch (error) {
                            log.error('Translation failed for line', i + 1, ':', error);
                            previewHTML += `<div class="preview-line-error">
                                <strong>Line ${i + 1}:</strong> "${lines[i].trim()}" G Error: ${error.message}
                            </div>`;
                        }
                    }
                }
            } else {
                // Auto mode: translate full text then wrap into rows for preview
                const src = (document.getElementById('auto-text')?.value || '').trim();
                if (!src) {
                    errorText.textContent = 'Please enter text in the Auto Placement field.';
                    errorDiv.style.display = 'flex';
                    return;
                }
                try {
                    const brailleText = await translateWithLiblouis(src, 'g2', tableName);
                    const shapeTypeEl = document.querySelector('input[name="shape_type"]:checked');
                    const shapeTypeVal = shapeTypeEl ? shapeTypeEl.value : 'card';
                    let cols;
                    if (shapeTypeVal === 'cylinder') {
                        const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
                        const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
                        const circumference = Math.PI * diameter;
                        cols = Math.floor(circumference / cellSpacing);
                    } else {
                        const gridColumnsValue = parseInt(document.getElementById('grid_columns').value) || 15;
                        cols = gridColumnsValue;
                    }
                    const rows = parseInt(document.getElementById('grid_rows').value) || 4;
                    const totalCellsAvailable = cols * rows;
                    if (brailleText.length > totalCellsAvailable) {
                        const over = brailleText.length - totalCellsAvailable;
                        errorText.textContent = `Text requires ${brailleText.length} cells but only ${totalCellsAvailable} are available. Over by ${over} cells.`;
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                    }
                    let idx = 0;
                    for (let r = 0; r < rows; r++) {
                        const slice = brailleText.slice(idx, idx + cols);
                        if (slice) {
                            const shorthand = brailleToComputerShorthand(slice);
                            previewHTML += `<div class="preview-line-success">
                                <div><strong>Row ${r + 1}:</strong> "${slice}"</div>
                                <div class="preview-subline">Computer shorthand: "${shorthand}"</div>
                            </div>`;
                        } else {
                            previewHTML += `<div class="preview-line-success">
                                <strong>Row ${r + 1}:</strong> ""
                            </div>`;
                        }
                        idx += cols;
                    }
                } catch (error) {
                    log.error('Translation failed for auto text:', error);
                    previewHTML += `<div class="preview-line-error">
                        <strong>Auto Placement:</strong> Error: ${error.message}
                    </div>`;
                }
            }

            previewContent.innerHTML = previewHTML;
            braillePreview.style.display = 'block';
        });

        function init3D() {
            // Mobile-optimized renderer settings
            const isMobile = window.innerWidth <= 768;
            renderer = new THREE.WebGLRenderer({ 
                antialias: !isMobile, // Disable antialiasing on mobile for performance
                powerPreference: isMobile ? "low-power" : "high-performance"
            });
            const initW = viewer.clientWidth;
            const initH = viewer.clientHeight || 420;
            renderer.setSize(initW, initH, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
            // Preserve overlay children inside #viewer; only remove previous canvas if present
            const existingCanvas = viewer.querySelector('canvas');
            if (existingCanvas) viewer.removeChild(existingCanvas);
            viewer.appendChild(renderer.domElement);
            
            // Get theme-appropriate colors with proper fallbacks
            const styles = getComputedStyle(document.documentElement);
            const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
            const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
            const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
            const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
            const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(stlBackground);
            
            camera = new THREE.PerspectiveCamera(45, initW / initH, 0.1, 1000);
            camera.position.set(0, 0, 120);
            camera.up.set(0, 1, 0); // Default Y-up
            camera.lookAt(0, 0, 0);
            
            // Add camera to scene so attached lights will work
            scene.add(camera);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            
            // Mobile-optimized controls
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = isMobile ? 0.5 : 1.0;
            controls.zoomSpeed = isMobile ? 0.8 : 1.2;
            controls.panSpeed = isMobile ? 0.5 : 0.8;
            
            // Touch-specific settings
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            
            controls.update();
            
            // Theme-appropriate lighting with intensity control
            const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);
            
            // Position the directional light for optimal detail visibility
            // Use conventional 3D modeling lighting angles
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'high-contrast') {
                // High contrast mode: conventional three-point lighting for better detail visibility
                // Key light: 45- horizontal, 30- vertical (right side) - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);
                
                // Fill light: 45- horizontal, 15- vertical (left side) for shadow softening - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                camera.add(fillLight);
                
                // Subtle back light for edge definition - camera-relative
                const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                backLight.position.set(0, 0.5, -0.866).normalize();
                camera.add(backLight);
            } else {
                // Standard lighting: conventional angle for optimal detail visibility
                // Key light: 45- horizontal, 30- vertical - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);
                
                // Add subtle fill light for standard modes too - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                camera.add(fillLight);
            }
            
            scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));
            
            // Handle window resize for mobile orientation changes
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onWindowResize() {
            const targetW = viewer.clientWidth;
            const targetH = viewer.clientHeight || 420;
            camera.aspect = targetW / targetH;
            camera.updateProjectionMatrix();
            renderer.setSize(targetW, targetH, false);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        form.onsubmit = async (e) => {
            e.preventDefault();
            errorDiv.style.display = 'none';
            errorText.textContent = '';
            
            // Collect input depending on placement mode
            const placementMode = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
            let lines = [];
            let originalLines = [];
            if (placementMode === 'manual') {
                lines = getDynamicLineValues();
                originalLines = [...lines];
            } else {
                const src = (document.getElementById('auto-text')?.value || '').trim();
                originalLines = [src];
                // We'll translate the whole text, then wrap to rows based on available cells
            }
            
            const plateTypeEl = document.querySelector('input[name="plate_type"]:checked');
            const plateType = plateTypeEl ? plateTypeEl.value : 'positive';
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect?.value || 'en-ueb-g1.ctb';
            
            // Translate text to braille only for positive plates
            let translatedLines = [];
            let perLineLanguageTables = [];
            let translationErrors = [];
            if (plateType === 'positive') {
                if (placementMode === 'manual') {
                    // Per-line translation
                    perLineLanguageTables = new Array(lines.length).fill(tableName);
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line) {
                            try {
                                const perLineTable = (document.getElementById(`line_lang_${i+1}`)?.value) || tableName;
                                perLineLanguageTables[i] = perLineTable;
                                log.debug(`Translating line ${i + 1}: '${line}' to braille using table: ${perLineTable}...`);
                                const brailleText = await translateWithLiblouis(line, 'g2', perLineTable);
                                log.debug(`Line ${i + 1} translated: '${line}' G '${brailleText}'`);
                                translatedLines.push(brailleText);
                            } catch (error) {
                                log.error(`Failed to translate line ${i + 1}:`, error);
                                translationErrors.push({ line: i + 1, text: line, error: error.toString() });
                                translatedLines.push('');
                            }
                        } else {
                            translatedLines.push('');
                        }
                    }
                } else {
                    // Auto mode: translate entire text, then wrap to rows
                    const src = (document.getElementById('auto-text')?.value || '').trim();
                    if (!src) {
                        translatedLines = Array(parseInt(document.getElementById('grid_rows').value) || 4).fill('');
                    } else {
                        try {
                            const brailleText = await translateWithLiblouis(src, 'g2', tableName);
                            const shapeTypeEl = document.querySelector('input[name="shape_type"]:checked');
                            const shapeTypeVal = shapeTypeEl ? shapeTypeEl.value : 'card';
                            let totalCellsAvailable;
                            let cols;
                            if (shapeTypeVal === 'cylinder') {
                                // Derive cells per row from cylinder geometry
                                const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30.75;
                                const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
                                const circumference = Math.PI * diameter;
                                cols = Math.floor(circumference / cellSpacing);
                            } else {
                                const gridColumnsValue = parseInt(document.getElementById('grid_columns').value) || 15;
                                cols = gridColumnsValue; // indicators reserved are handled in mesh/layout
                            }
                            const rows = parseInt(document.getElementById('grid_rows').value) || 4;
                            totalCellsAvailable = cols * rows;
                            // Warn if overflow (global)
                            if (brailleText.length > totalCellsAvailable) {
                                const over = brailleText.length - totalCellsAvailable;
                                errorText.textContent = `Text requires ${brailleText.length} cells but only ${totalCellsAvailable} are available. Over by ${over} cells.`;
                                errorDiv.style.display = 'flex';
                                errorDiv.className = 'error-message';
                            }
                            // Wrap into row strings left-to-right
                            translatedLines = [];
                            let idx = 0;
                            for (let r = 0; r < rows; r++) {
                                const slice = brailleText.slice(idx, idx + cols);
                                translatedLines.push(slice);
                                idx += cols;
                            }
                        } catch (error) {
                            log.error('Failed to translate auto text:', error);
                            translationErrors.push({ line: 1, text: src, error: error.toString() });
                            translatedLines = Array(parseInt(document.getElementById('grid_rows').value) || 4).fill('');
                        }
                    }
                }
                log.debug('Original lines:', lines);
                log.debug('Translated lines:', translatedLines);
                
                // Check if any translation errors occurred
                if (translationErrors.length > 0) {
                    let errorMessage = '<strong>Translation failed for the following lines:</strong><br><br>';
                    translationErrors.forEach(err => {
                        errorMessage += `Line ${err.line}: "${err.text}"<br>`;
                    });
                    errorMessage += '<br><strong>Please check your text and try again.</strong><br><br>';
                    errorMessage += 'Common issues include:<br>';
                    errorMessage += 'G Special characters that cannot be translated<br>';
                    errorMessage += 'G Text that is incompatible with the selected braille table<br>';
                    errorMessage += 'G System errors during translation<br><br>';
                    errorMessage += '<em>The STL file was not generated to prevent producing incorrect braille.</em>';
                    
                    errorText.innerHTML = errorMessage;  // Use innerHTML for HTML formatting
                    errorDiv.style.display = 'flex';
                    errorDiv.className = 'error-message';
                    
                    // Re-enable button and reset to generate state
                    resetToGenerateState();
                    return;
                }
            } else {
                // Counter plates don't need text - just pass empty lines
                translatedLines = ['', '', '', ''];
                log.debug('Counter plate selected - no text translation needed');
            }
            const settings = {
                // Add 2 only if indicator shapes are ON; otherwise send exact cells
                grid_columns: (document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1')
                    ? String(parseInt(document.getElementById('grid_columns').value) + 2)
                    : String(parseInt(document.getElementById('grid_columns').value)),
                grid_rows: document.getElementById('grid_rows').value,
                cell_spacing: document.getElementById('cell_spacing').value,
                line_spacing: document.getElementById('line_spacing').value,
                dot_spacing: document.getElementById('dot_spacing').value,
                emboss_dot_base_diameter: document.getElementById('emboss_dot_base_diameter').value,
                emboss_dot_height: document.getElementById('emboss_dot_height').value,
                emboss_dot_flat_hat: document.getElementById('emboss_dot_flat_hat').value,
                // Back-compat: if backend expects offset, compute from difference
                // but we also send independent counter base diameter explicitly
                // Separate diameters per recess shape
                hemi_counter_dot_base_diameter: document.getElementById('hemi_counter_dot_base_diameter')?.value || '1.6',
                bowl_counter_dot_base_diameter: document.getElementById('bowl_counter_dot_base_diameter')?.value || '1.6',
                // Back-compat: provide unified base diameter reflecting current recess selection
                counter_dot_base_diameter: (() => {
                    const recessVal = document.querySelector('input[name="recess_shape"]:checked')?.value || '1';
                    if (recessVal === '1') return (document.getElementById('bowl_counter_dot_base_diameter')?.value || '1.6');
                    if (recessVal === '0') return (document.getElementById('hemi_counter_dot_base_diameter')?.value || '1.6');
                    return (document.getElementById('cone_counter_dot_base_diameter')?.value || '1.6');
                })(),
                counter_dot_depth: document.getElementById('counter_dot_depth')?.value || '0.6',
                use_bowl_recess: (document.querySelector('input[name="recess_shape"]:checked')?.value === '1') ? 1 : 0,
                recess_shape: parseInt(document.querySelector('input[name="recess_shape"]:checked')?.value || '1'),
                // Cone parameters
                cone_counter_dot_base_diameter: document.getElementById('cone_counter_dot_base_diameter')?.value || '1.6',
                cone_counter_dot_height: document.getElementById('cone_counter_dot_height')?.value || '0.8',
                cone_counter_dot_flat_hat: document.getElementById('cone_counter_dot_flat_hat')?.value || '0.4',
                card_width: document.getElementById('card_width').value,
                card_height: document.getElementById('card_height').value,
                card_thickness: document.getElementById('card_thickness').value,
                braille_x_adjust: document.getElementById('braille_x_adjust').value,
                braille_y_adjust: document.getElementById('braille_y_adjust').value,
                // Rounded dome settings (optional)
                use_rounded_dots: (document.querySelector('input[name="dot_shape"]:checked')?.value === 'rounded') ? 1 : 0,
                dot_shape: document.querySelector('input[name="dot_shape"]:checked')?.value || 'rounded',
                // Legacy fallbacks retained for backend compatibility
                rounded_dot_diameter: document.getElementById('rounded_dot_dome_diameter')?.value || '1.5',
                rounded_dot_height: document.getElementById('rounded_dot_dome_height')?.value || '0.6',
                // New explicit params
                rounded_dot_base_diameter: document.getElementById('rounded_dot_base_diameter')?.value || '2.0',
                rounded_dot_base_height: document.getElementById('rounded_dot_base_height')?.value || document.getElementById('rounded_dot_cylinder_height')?.value || '0.2',
                rounded_dot_cylinder_height: document.getElementById('rounded_dot_base_height')?.value || document.getElementById('rounded_dot_cylinder_height')?.value || '0.2',
                rounded_dot_dome_diameter: document.getElementById('rounded_dot_dome_diameter')?.value || '1.5',
                rounded_dot_dome_height: document.getElementById('rounded_dot_dome_height')?.value || '0.6',
                // New: indicator shapes toggle
                indicator_shapes: (document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1') ? 1 : 0
            };
            
            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Settings object keys:', Object.keys(settings));
            log.debug('Settings object values:', Object.values(settings));
            
            // Debug shape values specifically
            const currentDotShape = document.querySelector('input[name="dot_shape"]:checked')?.value;
            const currentRecessShape = document.querySelector('input[name="recess_shape"]:checked')?.value;
            const currentCombinedShape = document.querySelector('input[name="combined_shape"]:checked')?.value;
            log.debug('Shape values - combined:', currentCombinedShape, 'dot_shape:', currentDotShape, 'recess_shape:', currentRecessShape, 'use_rounded_dots:', settings.use_rounded_dots);
            // Rounded-dome inputs are always visible for embossing plate; no dynamic toggle
            
            // Check if at least one line has content (only for positive plates)
            const hasContent = placementMode === 'manual' ? lines.some(l => l && l.trim()) : ((originalLines[0] || '').trim().length > 0);
            if (plateType === 'positive' && !hasContent) {
                errorText.textContent = 'Please enter text in at least one line.';
                errorDiv.style.display = 'flex';
                return;
            }
            
            // Validate braille character limits AFTER translation
            const gridColumnsValue = parseInt(document.getElementById('grid_columns').value);
            const indicatorsOn = document.querySelector('input[name="indicator_shapes"]:checked')?.value === '1';
            if (plateType === 'positive') {
                const availableColumns = gridColumnsValue;
                // In auto mode, we already wrapped by row capacity; skip line-specific error.
                if (placementMode === 'manual') {
                    for (let i = 0; i < translatedLines.length; i++) {
                        const brailleLine = translatedLines[i];
                        if (brailleLine && brailleLine.length > availableColumns) {
                            const over = brailleLine.length - availableColumns;
                            errorText.textContent = `Line ${i + 1} exceeds ${availableColumns} available braille cells by ${over} cells after translation. Please shorten your text.`;
                            errorDiv.style.display = 'flex';
                            errorDiv.className = 'error-message';
                            return;
                        }
                    }
                }
            } else {
                // For counter plates, all grid columns are available
                for (let i = 0; i < translatedLines.length; i++) {
                    const brailleLine = translatedLines[i];
                    if (brailleLine && brailleLine.length > gridColumnsValue) {
                        const over = brailleLine.length - gridColumnsValue;
                        errorText.textContent = `Line ${i + 1} exceeds ${gridColumnsValue} braille cells by ${over} cells after translation. Please shorten your text.`;
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        return;
                    }
                }
            }
            
            // Show loading message
            errorText.textContent = plateType === 'positive' ? 'Translating text to braille...' : 'Generating counter plate...';
            errorDiv.style.display = 'flex';
            errorDiv.className = 'error-message info';
            
            // Update button to show loading state
            actionBtn.disabled = true;
            actionBtn.textContent = 'Generating...';
            actionBtn.style.opacity = '0.7';
            
            // Get shape type and cylinder params
            const shapeTypeElGen = document.querySelector('input[name="shape_type"]:checked');
            const shapeType = shapeTypeElGen ? shapeTypeElGen.value : 'card';
            let cylinderParams = {};
            
            if (shapeType === 'cylinder') {
                cylinderParams = {
                    diameter_mm: document.getElementById('cylinder_diameter_mm')?.value || '30.75',
                    height_mm: document.getElementById('cylinder_height_mm')?.value || '52',
                    polygonal_cutout_radius_mm: document.getElementById('cylinder_polygonal_cutout_radius_mm')?.value || '13',
                    polygonal_cutout_sides: document.getElementById('cylinder_polygonal_cutout_sides')?.value || '12',
                    seam_offset_deg: document.getElementById('seam_offset_deg')?.value || '355'
                };
            }
            
            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Shape Type:', shapeType);
            log.debug('Cylinder Params:', cylinderParams);
            
            // Build original_lines for indicators
            let originalForIndicators = null;
            if (placementMode === 'manual') {
                originalForIndicators = lines;
            } else {
                const srcAuto = (document.getElementById('auto-text')?.value || '').trim();
                const tokens = srcAuto.split(/\s+/).filter(Boolean);
                const rowsCount = parseInt(document.getElementById('grid_rows').value) || 4;
                // Derive per-row indicator from first alphanumeric of each token
                const indicators = tokens.map(tok => {
                    const m = tok.match(/[A-Za-z0-9]/);
                    return m ? m[0] : '';
                });
                // Map indicators to rows cyclically or truncated
                originalForIndicators = new Array(rowsCount).fill('');
                for (let r = 0; r < rowsCount; r++) {
                    originalForIndicators[r] = indicators[r] || '';
                }
            }

            const res = await fetch('/generate_braille_stl', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    lines: translatedLines,
                    original_lines: originalForIndicators,
                    placement_mode: placementMode,
                    grade: 'g2', 
                    plate_type: plateType, 
                    shape_type: shapeType,
                    cylinder_params: cylinderParams,
                    per_line_language_tables: perLineLanguageTables,
                    settings: settings 
                })
            });
            
            // Hide loading message
            errorDiv.style.display = 'none';
            
            if (!res.ok) {
                let msg = 'Error generating STL';
                try {
                    const data = await res.json();
                    if (data.error) msg = data.error;
                } catch (e) {
                    msg = `Server error: ${res.status} ${res.statusText}`;
                }
                errorText.textContent = msg;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message'; // Reset to error style
                // Re-enable button on error and reset to generate state
                resetToGenerateState();
                return;
            }
            
            
            try {
                // Create blob and URL for 3D preview
                const blob = await res.blob();
                if (lastSTLUrl) URL.revokeObjectURL(lastSTLUrl);
                lastSTLUrl = URL.createObjectURL(blob);
                
                // Generate filename on frontend to match backend logic
                const plateType = document.querySelector('input[name="plate_type"]:checked').value;
                const shapeType = document.querySelector('input[name="shape_type"]:checked').value;
                let filename = plateType === 'positive' ? 'braille_embossing_plate' : 'braille_counter_plate';
                
                if (plateType === 'positive') {
                    // Get the current lines from the form
                    const placementModeNow = document.querySelector('input[name="placement_mode"]:checked')?.value || 'manual';
                    let lines = [];
                    if (placementModeNow === 'manual') {
                        const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
                        for (let i = 1; i <= gridRows; i++) {
                            const input = document.getElementById(`line${i}`);
                            lines.push(input ? input.value : '');
                        }
                    } else {
                        lines = [document.getElementById('auto-text')?.value || ''];
                    }
                    
                    // Find first non-empty line (prioritizing Line 1)
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            // Sanitize filename: remove special characters and limit length
                            let sanitized = lines[i].trim().substring(0, 30);
                            sanitized = sanitized.replace(/[^\w\s-]/g, '');
                            sanitized = sanitized.replace(/[-\s]+/g, '_').replace(/^_+|_+$/g, '');
                            
                            if (sanitized) {
                                filename = `braille_embossing_plate_${sanitized}-${shapeType}`;
                                break;
                            }
                        }
                    }
                    // If no text was found, still append shape type
                    if (!filename.includes(shapeType)) {
                        filename = `braille_embossing_plate-${shapeType}`;
                    }
                } else {
                    // For counter plates, include actual counter base diameter in filename
                    const isBowlSel = document.querySelector('input[name="use_bowl_recess"]:checked')?.value === '1';
                    let baseStr = '0';
                    if (isBowlSel) {
                        baseStr = document.getElementById('bowl_counter_dot_base_diameter')?.value
                            || document.getElementById('counter_dot_base_diameter')?.value
                            || '0';
                    } else {
                        baseStr = document.getElementById('hemi_counter_dot_base_diameter')?.value
                            || document.getElementById('counter_dot_base_diameter')?.value
                            || '0';
                    }
                    const totalDiameter = parseFloat(baseStr) || 0;
                    filename = `braille_counter_plate_${totalDiameter}mm-${shapeType}`;
                }
                
                // Store the generated STL URL and filename for download
                lastGeneratedSTLUrl = lastSTLUrl;
                lastGeneratedFilename = `${filename}.stl`;
                loadSTL(lastSTLUrl);
                
                // Change button to download state after successful generation
                actionBtn.disabled = false;
                setToDownloadState();
            } catch (e) {
                errorText.textContent = 'Failed to process STL file: ' + e.message;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message'; // Reset to error style
                // Re-enable button on error and reset to generate state
                resetToGenerateState();
            }
        };



        function loadSTL(url) {
            init3D();
            const loader = new STLLoader();
            loader.load(url, function (geometry) {
                if (mesh) scene.remove(mesh);
                
                // Center the geometry first
                geometry.center();
                
                // Compute bounding box after centering to detect object type
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const width = bbox.max.x - bbox.min.x;
                const height = bbox.max.y - bbox.min.y; 
                const depth = bbox.max.z - bbox.min.z;
                
                // Check if this is a cylinder
                const shapeType = document.querySelector('input[name="shape_type"]:checked')?.value;
                const isCylinder = shapeType === 'cylinder' || height > Math.max(width, depth) * 1.5;
                
                // Get theme-appropriate mesh color with proper fallback
                const styles = getComputedStyle(document.documentElement);
                const meshColorVar = styles.getPropertyValue('--stl-mesh-color').trim();
                const meshColor = meshColorVar || '#6699cc';
                // Enhanced material for high contrast mode
                const currentTheme = document.documentElement.getAttribute('data-theme');
                let material;
                
                if (currentTheme === 'high-contrast') {
                    // High contrast material with enhanced specular highlights
                    material = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color(meshColor), 
                        specular: 0xffffff, // White specular highlights for maximum contrast
                        shininess: 300, // Higher shininess for sharper highlights
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                } else {
                    // Standard material for other themes
                    material = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color(meshColor), 
                        specular: 0x111111, 
                        shininess: 200,
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                }
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = 0;
                scene.add(mesh);
                
                // Adjust camera position based on object type
                if (isCylinder) {
                    // For cylinders: view from the side
                    // After centering, the cylinder is at origin (0,0,0)
                    // The cylinder's axis is along the Z-direction

                    // Ensure camera up vector is correct for upright viewing BEFORE lookAt
                    camera.up.set(0, 0, 1); // Z-axis is up for the cylinder

                    // Position camera to view cylinder upright from the side
                    // Set camera on the +X axis looking toward origin
                    camera.position.set(120, 0, 0);
                    controls.target.set(0, 0, 0);
                    camera.lookAt(0, 0, 0);

                    // Recreate controls so internal up-vector transform matches camera.up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(0, 0, 0);
                    // Reapply standard control settings
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    // Panning orthogonal to world up for Z-up scenes
                    controls.screenSpacePanning = false;

                    camera.updateProjectionMatrix();
                } else {
                    // For cards: keep default front view with Y-up
                    camera.position.set(0, 0, 120);
                    camera.up.set(0, 1, 0); // Y-axis is up for cards (default)
                    camera.lookAt(0, 0, 0);
                    // Recreate controls to ensure correct up-vector mapping when switching back to Y-up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(0, 0, 0);
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    controls.screenSpacePanning = true;
                    camera.updateProjectionMatrix();
                }
                
                // Force controls to update with new camera settings
                controls.update();
                controls.saveState(); // Save the new camera state as default
                
                animate();
            }, undefined, function (error) {
                errorText.textContent = 'Failed to load STL: ' + error;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message';
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls && controls.update();
            render();
        }
        
        // Initialize liblouis web worker and 3D viewer on page load
        let liblouisWorker = null;
        let liblouisReady = false;
        let workerMessageId = 0;
        let pendingWorkerMessages = new Map();
        
        // Function to send message to worker and get response
        function sendWorkerMessage(type, data = {}) {
            return new Promise((resolve, reject) => {
                if (!liblouisWorker) {
                    reject(new Error('Worker not initialized'));
                    return;
                }
                
                const id = ++workerMessageId;
                pendingWorkerMessages.set(id, { resolve, reject });
                
                liblouisWorker.postMessage({ id, type, data });
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (pendingWorkerMessages.has(id)) {
                        pendingWorkerMessages.delete(id);
                        reject(new Error('Worker message timeout'));
                    }
                }, 10000);
            });
        }
        
        // Mobile-specific utilities
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Prevent double-tap zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
        
        // Handle mobile keyboard visibility and orientation changes
        if (isMobileDevice()) {
            const inputs = document.querySelectorAll('input[type="text"], input[type="number"], select');
            inputs.forEach(input => {
                input.addEventListener('focus', () => {
                    // Scroll input into view when keyboard appears
                    setTimeout(() => {
                        const scrollParent = input.closest('.preview-section, .form-section') || document.scrollingElement;
                        if (scrollParent && scrollParent !== document.scrollingElement) {
                            const parentRect = scrollParent.getBoundingClientRect();
                            const inputRect = input.getBoundingClientRect();
                            const offset = (inputRect.top + inputRect.height / 2) - (parentRect.top + parentRect.height / 2);
                            scrollParent.scrollBy({ top: offset, behavior: 'smooth' });
                        } else {
                            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 300);
                });
            });
            
            // Handle orientation changes to maintain 200% zoom
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (window.innerWidth <= 768) {
                        applyFontSize(6); // Reset to 200% on orientation change
                    }
                }, 100);
            });
        }
        
        window.addEventListener('load', async () => {
            try {
                // Initialize liblouis web worker
                log.debug('Initializing liblouis web worker...');
                
                // Test if worker file is accessible first
                try {
                    const workerResponse = await fetch('/static/liblouis-worker.js');
                    if (!workerResponse.ok) {
                        throw new Error(`Worker file not accessible: ${workerResponse.status}`);
                    }
                    log.debug('Worker file is accessible');
                } catch (fetchError) {
                    log.error('Worker file test failed:', fetchError);
                    throw new Error('Cannot access worker file: ' + fetchError.message);
                }
                
                liblouisWorker = new Worker('/static/liblouis-worker.js');
                
                // Handle worker messages
                liblouisWorker.onmessage = function(e) {
                    const { id, type, result } = e.data;
                    
                    if (pendingWorkerMessages.has(id)) {
                        const { resolve, reject } = pendingWorkerMessages.get(id);
                        pendingWorkerMessages.delete(id);
                        
                        if (result.success) {
                            resolve(result);
                        } else {
                            reject(new Error(result.error));
                        }
                    }
                };
                
                liblouisWorker.onerror = function(error) {
                    log.error('Worker error:', error);
                };
                
                // Initialize liblouis in the worker
                const initResult = await sendWorkerMessage('init');
                if (initResult.success) {
                    liblouisReady = true;
                    log.debug('Liblouis web worker initialized successfully');
                } else {
                    throw new Error('Failed to initialize liblouis worker: ' + initResult.error);
                }
                
            } catch (error) {
                log.error('Failed to initialize liblouis worker:', error);
                
                // Fallback: disable liblouis and show error message
                log.debug('Web worker failed - disabling liblouis translation');
                liblouisReady = false;
                liblouisWorker = null;
                
                // Show user that translation is disabled
                const errorDiv = document.getElementById('error-message');
                const errorText = document.getElementById('error-text');
                if (errorDiv && errorText) {
                    errorText.textContent = 'Web worker failed to initialize. Braille translation preview is disabled on this deployment.';
                    errorDiv.style.display = 'flex';
                }
            }
            
            // Always default to cylinder on load; do not restore from storage
            const cyl = document.querySelector('input[name="shape_type"][value="cylinder"]');
            if (cyl) cyl.checked = true;
            
            init3D();
            animate();
        });

        // Function to translate text using liblouis web worker
        async function translateWithLiblouis(text, grade, tableName = null) {
            if (!liblouisReady || !liblouisWorker) {
                throw new Error('Liblouis worker not initialized - translation preview unavailable on this deployment');
            }
            
            try {
                log.debug('Sending translation request to worker:', text, 'grade:', grade, 'table:', tableName);
                const result = await sendWorkerMessage('translate', { text, grade, tableName });
                
                if (result.success && result.translation) {
                    log.debug('Translation successful:', result.translation);
                    return result.translation;
                } else {
                    throw new Error('Translation failed: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                log.error('Worker translation failed:', error);
                throw error;
            }
        }




    </script>
</body>
</html> 
</html> 